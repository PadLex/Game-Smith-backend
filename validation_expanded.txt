5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; when one tiger is blocked the other must be blocked on the next turn. The goal of the tigers is to capture all the goats.
(game "Bagh Batti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))}) (rules (start {(place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5}) (place "Tiger2" (sites {"C1" "C5"}))}) (play (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece top:True))) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; when one tiger is blocked the other must be blocked on the next turn. The goal of the tigers is to capture all the goats.
(game "Bagh Batti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))}) (rules (start {(place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5}) (place "Tiger2" (sites {"C1" "C5"}))}) (play (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece top:True))) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; when one tiger is blocked the other must be blocked on the next turn. The goal of the tigers is to capture all the goats.
(game "Bagh Batti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))}) (rules (start {(place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5}) (place "Tiger2" (sites {"C1" "C5"}))}) (play (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece top:True))) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays with a tiger piece, placed anywhere on the board. The other player plays with 21 goats, placed on the central point of the board. The goats move first. Goats may move one at a time to any adjacent vacant spot along the lines of the board. The tiger moves in the same manner, but also may capture a piece by hopping over it to an empty space immediate on the opposite side of a goat. The tiger may hop the stack of goats, but may only capture one. The goal of the goats is to surround the tiger so it cannot move. The goal of the tiger is to capture all the goats.
(game "Bagha Guti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place Stack "Goat2" 12 count:21) (place "Tiger1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece top:True)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays with a tiger piece, placed anywhere on the board. The other player plays with 21 goats, placed on the central point of the board. The goats move first. Goats may move one at a time to any adjacent vacant spot along the lines of the board. The tiger moves in the same manner, but also may capture a piece by hopping over it to an empty space immediate on the opposite side of a goat. The tiger may hop the stack of goats, but may only capture one. The goal of the goats is to surround the tiger so it cannot move. The goal of the tiger is to capture all the goats.
(game "Bagha Guti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place Stack "Goat2" 12 count:21) (place "Tiger1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece top:True)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays with a tiger piece, placed anywhere on the board. The other player plays with 21 goats, placed on the central point of the board. The goats move first. Goats may move one at a time to any adjacent vacant spot along the lines of the board. The tiger moves in the same manner, but also may capture a piece by hopping over it to an empty space immediate on the opposite side of a goat. The tiger may hop the stack of goats, but may only capture one. The goal of the goats is to surround the tiger so it cannot move. The goal of the tiger is to capture all the goats.
(game "Bagha Guti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place Stack "Goat2" 12 count:21) (place "Tiger1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece top:True)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
One player plays with one piece "presumably the coyote," the other with the other twelve pieces, placed on intersections of the lines. Pieces move to an adjacent intersection connected to the present position by a line. The "coyote" may take the opponent's pieces by hopping over them. Multiple captures are allowed if possible, Captures are obligatory. The goal of the coyote is to capture all of the opponent's pieces; the other player's goal is to block the coyote so it cannot move. The coyote can jump to capture.
(game "Coyote" (players 2) (equipment {(board (rectangle 5 5 diagonals:Radiating) use:Vertex) (piece "Sheep" P1 (move Step (to if:(is Empty (to))))) (piece "Coyote" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (if (is Prev Mover) (move Pass) (move Step (to if:(is Empty (to)))))))}) (rules (start {(place "Sheep1" (union (expand (sites Bottom)) (sites {"A3" "E3"}))) (place "Coyote2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 9) (result P1 Loss))}))) 
One player plays with one piece "presumably the coyote," the other with the other twelve pieces, placed on intersections of the lines. Pieces move to an adjacent intersection connected to the present position by a line. The "coyote" may take the opponent's pieces by hopping over them. Multiple captures are allowed if possible, Captures are obligatory. The goal of the coyote is to capture all of the opponent's pieces; the other player's goal is to block the coyote so it cannot move. The coyote can jump a sequence of pieces to capture.
(game "Coyote" (players 2) (equipment {(board (rectangle 5 5 diagonals:Radiating) use:Vertex) (piece "Sheep" P1 (move Step (to if:(is Empty (to))))) (piece "Coyote" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (if (is Prev Mover) (move Pass) (move Step (to if:(is Empty (to)))))))}) (rules (start {(place "Sheep1" (union (expand (sites Bottom)) (sites {"A3" "E3"}))) (place "Coyote2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 9) (result P1 Loss))}))) 
One player plays with one piece "presumably the coyote," the other with the other twelve pieces, placed on intersections of the lines. Pieces move to an adjacent intersection connected to the present position by a line. The "coyote" may take the opponent's pieces by hopping over them. Multiple captures are allowed if possible, Captures are obligatory. The goal of the coyote is to capture all of the opponent's pieces; the other player's goal is to block the coyote so it cannot move. The coyote can jump to capture.
(game "Coyote" (players 2) (equipment {(board (rectangle 5 5 diagonals:Radiating) use:Vertex) (piece "Sheep" P1 (move Step (to if:(is Empty (to))))) (piece "Coyote" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (if (is Prev Mover) (move Pass) (move Step (to if:(is Empty (to)))))))}) (rules (start {(place "Sheep1" (union (expand (sites Bottom)) (sites {"A3" "E3"}))) (place "Coyote2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 9) (result P1 Loss))}))) 
The game is played on a triangle board divided in half on its height and then in thirds with lines crossing the height perpendicularly. One player plays as the tiger, and the other plays as seven leopards. The tiger plays their piece on a point where lines intersect first, and then on subsequent turns the leopards are placed one-by-one. Moves occur along the lines to an adjacent intersection. The tiger captures may capture a leopard by hopping over it. The tiger's goal is to capture four of the leopards; the leopards' goal is to block the tiger so it cannot move. Played on the board described in Ludovici and Parker.
(game "Hat Diviyan Keliya" (players 2) (equipment {(board (scale 1 2 (wedge 4)) use:Vertex) (hand Each) (piece "Tiger" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Leopard" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (handSite P1) count:1) (place "Leopard2" (handSite P2) count:7)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 3) (result P2 Loss))}))})) 
The game is played on a triangle board divided in half on its height and then in thirds with lines crossing the height perpendicularly. One player plays as the tiger, and the other plays as seven leopards. The tiger plays their piece on a point where lines intersect first, and then on subsequent turns the leopards are placed one-by-one. Moves occur along the lines to an adjacent intersection. The tiger captures may capture a leopard by hopping over it. The tiger's goal is to capture four of the leopards; the leopards' goal is to block the tiger so it cannot move. Played on a larger Board.
(game "Hat Diviyan Keliya" (players 2) (equipment {(board (scale 1 2 (wedge 5)) use:Vertex) (hand Each) (piece "Tiger" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Leopard" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (handSite P1) count:2) (place "Leopard2" (handSite P2) count:8)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 5) (result P2 Loss))}))})) 
The game is played on a triangle board divided in half on its height and then in thirds with lines crossing the height perpendicularly. One player plays as the tiger, and the other plays as seven leopards. The tiger plays their piece on a point where lines intersect first, and then on subsequent turns the leopards are placed one-by-one. Moves occur along the lines to an adjacent intersection. The tiger captures may capture a leopard by hopping over it. The tiger's goal is to capture four of the leopards; the leopards' goal is to block the tiger so it cannot move. Played on the board described in Ludovici and Parker.
(game "Hat Diviyan Keliya" (players 2) (equipment {(board (scale 1 2 (wedge 4)) use:Vertex) (hand Each) (piece "Tiger" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Leopard" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (handSite P1) count:1) (place "Leopard2" (handSite P2) count:7)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 3) (result P2 Loss))}))})) 
A triangle, with a line drawn from the apex to the base, and two lines drawn through the height connecting the opposite two sides. One player plays as one tiger, the other as five lambs. The tiger begins on the apex of the triangle. The tiger moves to an empty adjacent spot along the lines of the board. The player who plays as the lambs plays first, placing a lamb on an empty spot on the board, and then the tiger player moves. When all of the lambs are placed, the lambs move in the same manner as the tiger. The tiger may capture a lamb by hopping over it to an empty space on the opposite adjacent side of the lamb along the lines on the board. The lambs win when they block the tiger from being able to move, the tiger wins by capturing enough lambs so that it cannot be blocked.
(game "Huli-Mane Ata" (players 2) (equipment {(board (scale 1 2 (wedge 4 3)) use:Vertex) (hand P1) (piece "Lamb" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Lamb1" (handSite P1) count:5) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 4) (result P2 Win))}))) 
A triangle, with a line drawn from the apex to the base, and two lines drawn through the height connecting the opposite two sides. One player plays as one tiger, the other as five lambs. The tiger begins on the apex of the triangle. The tiger moves to an empty adjacent spot along the lines of the board. The player who plays as the lambs plays first, placing a lamb on an empty spot on the board, and then the tiger player moves. When all of the lambs are placed, the lambs move in the same manner as the tiger. The tiger may capture a lamb by hopping over it to an empty space on the opposite adjacent side of the lamb along the lines on the board. The lambs win when they block the tiger from being able to move, the tiger wins by capturing enough lambs so that it cannot be blocked.
(game "Huli-Mane Ata" (players 2) (equipment {(board (scale 1 2 (wedge 4 3)) use:Vertex) (hand P1) (piece "Lamb" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Lamb1" (handSite P1) count:5) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 4) (result P2 Win))}))) 
A triangle, with a line drawn from the apex to the base, and two lines drawn through the height connecting the opposite two sides. One player plays as one tiger, the other as five lambs. The tiger begins on the apex of the triangle. The tiger moves to an empty adjacent spot along the lines of the board. The player who plays as the lambs plays first, placing a lamb on an empty spot on the board, and then the tiger player moves. When all of the lambs are placed, the lambs move in the same manner as the tiger. The tiger may capture a lamb by hopping over it to an empty space on the opposite adjacent side of the lamb along the lines on the board. The lambs win when they block the tiger from being able to move, the tiger wins by capturing enough lambs so that it cannot be blocked.
(game "Huli-Mane Ata" (players 2) (equipment {(board (scale 1 2 (wedge 4 3)) use:Vertex) (hand P1) (piece "Lamb" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Lamb1" (handSite P1) count:5) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 4) (result P2 Win))}))) 
3x5 intersecting lines, with diagonals in the four quadrants created. On either short end, an arc connects the two corner points, and the center line is extended to the arc. One player plays as four hounds, which begin on the four points to the left side of the board. The other player plays as one hare, which begins on the point where the center line and the second line cross. Players alternate turns moving a piece to an empty adjacent spot along the lines. The hounds may only move forward. The hounds win when they block the hare from being able to move. The game has an ending condition only for P2.
(game "Hund efter Hare (Thy)" (players 2) (equipment {(board (remove (add (merge {(rectangle 3 5) (shift 1 0 (scale 0.5 (rectangle 5 1))) (shift 3 0 (scale 0.5 (rectangle 5 1))) (shift -1 1 (rectangle 1 7))}) edges:{{0 15} {15 7} {7 18} {18 14} {17 4} {7 17} {7 16} {16 10} {19 10} {0 19} {20 14} {20 4} {12 16} {16 5} {5 15} {15 2} {2 17} {17 9} {9 18} {18 12}}) edges:{{11 6} {6 1} {13 8} {8 3}}) use:Vertex) (piece "Hare" P1 (move Step (to if:(is Empty (to))))) (piece "Dog" P2 E (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Hare1" coord:"C3") (place "Dog2" (sites {"B3" "B1" "A3" "B5"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win))}))) 
3x5 intersecting lines, with diagonals in the four quadrants created. On either short end, an arc connects the two corner points, and the center line is extended to the arc. One player plays as four hounds, which begin on the four points to the left side of the board. The other player plays as one hare, which begins on the point where the center line and the second line cross. Players alternate turns moving a piece to an empty adjacent spot along the lines. The hounds may only move forward. The hounds win when they block the hare from being able to move. The game has an ending condition for each player.
(game "Hund efter Hare (Thy)" (players 2) (equipment {(board (remove (add (merge {(rectangle 3 5) (shift 1 0 (scale 0.5 (rectangle 5 1))) (shift 3 0 (scale 0.5 (rectangle 5 1))) (shift -1 1 (rectangle 1 7))}) edges:{{0 15} {15 7} {7 18} {18 14} {17 4} {7 17} {7 16} {16 10} {19 10} {0 19} {20 14} {20 4} {12 16} {16 5} {5 15} {15 2} {2 17} {17 9} {9 18} {18 12}}) edges:{{11 6} {6 1} {13 8} {8 3}}) use:Vertex) (piece "Hare" P1 (move Step (to if:(is Empty (to))))) (piece "Dog" P2 E (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Hare1" coord:"C3") (place "Dog2" (sites {"B3" "B1" "A3" "B5"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (or (>= (count Moves) (- (value MoveLimit) 10)) (>= (count Turns) (- (value TurnLimit) 5))) (result P1 Win))}))) 
3x5 intersecting lines, with diagonals in the four quadrants created. On either short end, an arc connects the two corner points, and the center line is extended to the arc. One player plays as four hounds, which begin on the four points to the left side of the board. The other player plays as one hare, which begins on the point where the center line and the second line cross. Players alternate turns moving a piece to an empty adjacent spot along the lines. The hounds may only move forward. The hounds win when they block the hare from being able to move. The game has an ending condition only for P2.
(game "Hund efter Hare (Thy)" (players 2) (equipment {(board (remove (add (merge {(rectangle 3 5) (shift 1 0 (scale 0.5 (rectangle 5 1))) (shift 3 0 (scale 0.5 (rectangle 5 1))) (shift -1 1 (rectangle 1 7))}) edges:{{0 15} {15 7} {7 18} {18 14} {17 4} {7 17} {7 16} {16 10} {19 10} {0 19} {20 14} {20 4} {12 16} {16 5} {5 15} {15 2} {2 17} {17 9} {9 18} {18 12}}) edges:{{11 6} {6 1} {13 8} {8 3}}) use:Vertex) (piece "Hare" P1 (move Step (to if:(is Empty (to))))) (piece "Dog" P2 E (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Hare1" coord:"C3") (place "Dog2" (sites {"B3" "B1" "A3" "B5"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win))}))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as the notched stick, called the hare, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When a player has placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. When the hounds block the hare from being able to move, the hounds win. The game has an ending condition only for P1.
(game "Janes Soppi" (players 2) (equipment {(board (merge {(rectangle 3 3) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win))}))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as the notched stick, called the hare, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When a player has placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. When the hounds block the hare from being able to move, the hounds win. The game has an ending condition for each player.
(game "Janes Soppi" (players 2) (equipment {(board (merge {(rectangle 3 3) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (or (>= (count Moves) (- (value MoveLimit) 10)) (>= (count Turns) (- (value TurnLimit) 5))) (result P2 Win))}))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as the notched stick, called the hare, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When a player has placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. When the hounds block the hare from being able to move, the hounds win. The game has an ending condition only for P1.
(game "Janes Soppi" (players 2) (equipment {(board (merge {(rectangle 3 3) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intesecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho ("general"), the other as sixteen musashi ("soliders"). The Taisho begins in the central point, the musashi on each point of the perimeter of the square board. Players take turns moving from one point to an adjacent point along the lines on the board. The Taisho may capture a musashi by hopping over it. The Taisho wins if it captures all the musashi. The musashi win if they are able to immobilize the Taisho. 
(game "Juroku Musashi" (players 2) (equipment {(board (add (merge (scale 2 (square 5 diagonals:Alternating)) (shift 2 -2 (wedge 3))) vertices:{{3 -2} {5 -2}} edges:{{25 31} {25 29} {27 29} {27 32}}) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (difference (sites Outer) (expand (sites Bottom)))) (place "Marker2" (ahead (centrePoint) N))}) (play (forEach Piece)) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intesecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho ("general"), the other as sixteen musashi ("soliders"). The Taisho begins in the central point, the musashi on each point of the perimeter of the square board. Players take turns moving from one point to an adjacent point along the lines on the board. The Taisho may capture a musashi by hopping over it. The Taisho wins if it captures all the musashi. The musashi win if they are able to immobilize the Taisho. The triangle has no diagonal and only P2 can enter in the triangle.
(game "Juroku Musashi" (players 2) (equipment {(board (add (merge (scale 2 (square 5 diagonals:Alternating)) (shift 2 -2 (wedge 3))) vertices:{{3 -2} {5 -2}} edges:{{25 31} {27 32}}) use:Vertex) (piece "Marker" P1 (move Step (to if:(and (is Empty (to)) (not (is In (to) (expand (sites Bottom) steps:2))))))) (piece "Marker" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (difference (sites Outer) (expand (sites Bottom)))) (place "Marker2" (ahead (centrePoint) N))}) (play (forEach Piece)) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intesecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho ("general"), the other as sixteen musashi ("soliders"). The Taisho begins in the central point, the musashi on each point of the perimeter of the square board. Players take turns moving from one point to an adjacent point along the lines on the board. The Taisho may capture a musashi by hopping over it. The Taisho wins if it captures all the musashi. The musashi win if they are able to immobilize the Taisho. 
(game "Juroku Musashi" (players 2) (equipment {(board (add (merge (scale 2 (square 5 diagonals:Alternating)) (shift 2 -2 (wedge 3))) vertices:{{3 -2} {5 -2}} edges:{{25 31} {25 29} {27 29} {27 32}}) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (difference (sites Outer) (expand (sites Bottom)))) (place "Marker2" (ahead (centrePoint) N))}) (play (forEach Piece)) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
One player has 12 dogs, the other one lion. The dogs may move one space forward, the lion may move one space in any direction, and may also hop over a dog to capture it. The lion may make multiple hops in one turn. The goal of the dogs is to block the lion from moving; the lion's goal is to capture all the dogs." The dogs moves forwards.
(game "Komikan" (players 2) (equipment {(board (merge (scale 2 (square 5 diagonals:Alternating)) (graph vertices:{{4 8} {3 9} {4 9} {5 9} {2 10} {3 10} {4 10} {5 10} {6 10} {1 11} {3 11} {4 11} {5 11} {7 11}} edges:{{0 1} {0 2} {0 3} {1 4} {1 5} {1 2} {2 6} {2 3} {3 7} {3 8} {4 9} {4 5} {5 10} {5 6} {6 11} {6 7} {7 12} {7 8} {8 13} {9 10} {10 11} {11 12} {12 13}})) use:Vertex) (piece "MountainLion" P1 (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))) (piece "Dog" P2 N (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom)) (sites {"A3" "I3"}))) (place "MountainLion1" (coord "E7"))}) (play (forEach Piece)) (end {(if (no Pieces P2) (result P1 Win)) (if (no Moves P1) (result P2 Win)) (if (no Moves P2) (result Mover Draw))}))) 
One player has 12 dogs, the other one lion. The dogs may move one space forward, the lion may move one space in any direction, and may also hop over a dog to capture it. The lion may make multiple hops in one turn. The goal of the dogs is to block the lion from moving; the lion's goal is to capture all the dogs." The dogs moves forward.
(game "Komikan" (players 2) (equipment {(board (merge (scale 2 (square 5 diagonals:Alternating)) (graph vertices:{{4 8} {3 9} {4 9} {5 9} {2 10} {3 10} {4 10} {5 10} {6 10} {1 11} {3 11} {4 11} {5 11} {7 11}} edges:{{0 1} {0 2} {0 3} {1 4} {1 5} {1 2} {2 6} {2 3} {3 7} {3 8} {4 9} {4 5} {5 10} {5 6} {6 11} {6 7} {7 12} {7 8} {8 13} {9 10} {10 11} {11 12} {12 13}})) use:Vertex) (piece "MountainLion" P1 (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))) (piece "Dog" P2 N (move Step Forward (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom)) (sites {"A3" "I3"}))) (place "MountainLion1" (coord "E7"))}) (play (forEach Piece)) (end {(if (no Pieces P2) (result P1 Win)) (if (no Moves P1) (result P2 Win)) (if (no Moves P2) (result Mover Draw))}))) 
One player has 12 dogs, the other one lion. The dogs may move one space forward, the lion may move one space in any direction, and may also hop over a dog to capture it. The lion may make multiple hops in one turn. The goal of the dogs is to block the lion from moving; the lion's goal is to capture all the dogs." The dogs moves in any direction.
(game "Komikan" (players 2) (equipment {(board (merge (scale 2 (square 5 diagonals:Alternating)) (graph vertices:{{4 8} {3 9} {4 9} {5 9} {2 10} {3 10} {4 10} {5 10} {6 10} {1 11} {3 11} {4 11} {5 11} {7 11}} edges:{{0 1} {0 2} {0 3} {1 4} {1 5} {1 2} {2 6} {2 3} {3 7} {3 8} {4 9} {4 5} {5 10} {5 6} {6 11} {6 7} {7 12} {7 8} {8 13} {9 10} {10 11} {11 12} {12 13}})) use:Vertex) (piece "MountainLion" P1 (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))) (piece "Dog" P2 N (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom)) (sites {"A3" "I3"}))) (place "MountainLion1" (coord "E7"))}) (play (forEach Piece)) (end {(if (no Pieces P2) (result P1 Win)) (if (no Moves P1) (result P2 Win)) (if (no Moves P2) (result Mover Draw))}))) 
12x12 checkered board. One player plays with six "cattle" or "dogs," the other plays as the "leopard." The cattle start on the white spaces along one side of the board, the leopard may be placed on any white square. Cattle move one space forward diagonally. The leopard may move one or two spaces diagonally in any one direction. If the leopard moves past the line of cattle, the leopard wins. If the cattle block the leopard from being able to move, the cattle win.
(game "Koti Keliya" (players 2) (equipment {(board (square 12)) (piece "Leopard" P1 (move Slide Diagonal (between (max 2)))) (piece "Cow" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to)))))}) (rules (start {(place "Cow2" (difference (sites Bottom) (sites Phase 0)))}) phases:{(phase "Placement" (play (move Add (to (intersection (sites Phase 1) (sites Empty))))) (nextPhase (not (no Pieces P1)) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (and (no Moves P1) (is Mover P1)) (result P2 Win)) (if (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(< (row of:(site)) (row of:(where "Leopard" P1)))))) (result P1 Win))}))) 
12x12 checkered board. One player plays with six "cattle" or "dogs," the other plays as the "leopard." The cattle start on the white spaces along one side of the board, the leopard may be placed on any white square. Cattle move one space forward diagonally. The leopard may move one or two spaces diagonally in any one direction. If the leopard moves past the line of cattle, the leopard wins. If the cattle block the leopard from being able to move, the cattle win.
(game "Koti Keliya" (players 2) (equipment {(board (square 12)) (piece "Leopard" P1 (move Slide Diagonal (between (max 2)))) (piece "Cow" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to)))))}) (rules (start {(place "Cow2" (difference (sites Bottom) (sites Phase 0)))}) phases:{(phase "Placement" (play (move Add (to (intersection (sites Phase 1) (sites Empty))))) (nextPhase (not (no Pieces P1)) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (and (no Moves P1) (is Mover P1)) (result P2 Win)) (if (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(< (row of:(site)) (row of:(where "Leopard" P1)))))) (result P1 Win))}))) 
12x12 checkered board. One player plays with six "cattle" or "dogs," the other plays as the "leopard." The cattle start on the white spaces along one side of the board, the leopard may be placed on any white square. Cattle move one space forward diagonally. The leopard may move one or two spaces diagonally in any one direction. If the leopard moves past the line of cattle, the leopard wins. If the cattle block the leopard from being able to move, the cattle win.
(game "Koti Keliya" (players 2) (equipment {(board (square 12)) (piece "Leopard" P1 (move Slide Diagonal (between (max 2)))) (piece "Cow" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to)))))}) (rules (start {(place "Cow2" (difference (sites Bottom) (sites Phase 0)))}) phases:{(phase "Placement" (play (move Add (to (intersection (sites Phase 1) (sites Empty))))) (nextPhase (not (no Pieces P1)) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (and (no Moves P1) (is Mover P1)) (result P2 Win)) (if (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(< (row of:(site)) (row of:(where "Leopard" P1)))))) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, places on the four corners of the board. The other player plays as twenty goats, which are placed on the remaining points, leaving the central point open. Players alternate turns moving a piece to an empty adjacent point along the lines. The tigers may capture a goat by hopping over it to an empty adjacent spot immediately on the opposite side of the goat along the lines. The tigers win when they capture all of the goats; the goats win by blocking the tigers from being able to move.
(game "Kulaochal" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Goat" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (sites Corners)) (place "Goat2" (difference (sites Board) (union (sites Corners) (sites Centre))))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, places on the four corners of the board. The other player plays as twenty goats, which are placed on the remaining points, leaving the central point open. Players alternate turns moving a piece to an empty adjacent point along the lines. The tigers may capture a goat by hopping over it to an empty adjacent spot immediately on the opposite side of the goat along the lines. The tigers win when they capture all of the goats; the goats win by blocking the tigers from being able to move.
(game "Kulaochal" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Goat" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (sites Corners)) (place "Goat2" (difference (sites Board) (union (sites Corners) (sites Centre))))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, places on the four corners of the board. The other player plays as twenty goats, which are placed on the remaining points, leaving the central point open. Players alternate turns moving a piece to an empty adjacent point along the lines. The tigers may capture a goat by hopping over it to an empty adjacent spot immediately on the opposite side of the goat along the lines. The tigers win when they capture all of the goats; the goats win by blocking the tigers from being able to move.
(game "Kulaochal" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Goat" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (sites Corners)) (place "Goat2" (difference (sites Board) (union (sites Corners) (sites Centre))))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 grid, with diagonals in each quadrant. A triangle, with the apex connecting to the midpoint of one side of the grid. A line is drawn connecting the apex of the triangle to the midpoint of its base, and another triangle is drawn within the triangle connecting the midpoints of the larger triangle. One player plays as twelve dogs, arranged on the lower two rows of points and the two outer points on the central line; the other plays as one jaguar, placed on the apex of the smaller triangle. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain.
(game "La Yagua" (players 2) (equipment {(board (add (rotate 180 (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3))) edges:{{27 29} {29 25}}) use:Vertex) (piece "Jaguar" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom) steps:1) (sites {"A3" "E3"}))) (place "Jaguar1" coord:"C7")}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 6) (result P2 Loss))}))) 
5x5 grid, with diagonals in each quadrant. A triangle, with the apex connecting to the midpoint of one side of the grid. A line is drawn connecting the apex of the triangle to the midpoint of its base, and another triangle is drawn within the triangle connecting the midpoints of the larger triangle. One player plays as twelve dogs, arranged on the lower two rows of points and the two outer points on the central line; the other plays as one jaguar, placed on the apex of the smaller triangle. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain.
(game "La Yagua" (players 2) (equipment {(board (add (rotate 180 (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3))) edges:{{27 29} {29 25}}) use:Vertex) (piece "Jaguar" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom) steps:1) (sites {"A3" "E3"}))) (place "Jaguar1" coord:"C7")}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 6) (result P2 Loss))}))) 
5x5 grid, with diagonals in each quadrant. A triangle, with the apex connecting to the midpoint of one side of the grid. A line is drawn connecting the apex of the triangle to the midpoint of its base, and another triangle is drawn within the triangle connecting the midpoints of the larger triangle. One player plays as twelve dogs, arranged on the lower two rows of points and the two outer points on the central line; the other plays as one jaguar, placed on the apex of the smaller triangle. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain.
(game "La Yagua" (players 2) (equipment {(board (add (rotate 180 (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3))) edges:{{27 29} {29 25}}) use:Vertex) (piece "Jaguar" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom) steps:1) (sites {"A3" "E3"}))) (place "Jaguar1" coord:"C7")}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 6) (result P2 Loss))}))) 
A triangle, with a point in the center and lines connecting it to the apex and the midpoints of the two sides which meet at the apex. One person plays as the tiger, which begins on the apex. The other person plays as three people. Players alternate turns, with the person playing as the people first placing a person on the board, and then the tiger moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tiger may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tiger wins when it captures one person, the people win when they can block the tiger from being able to move.
(game "Mysore Tiger Game" (players 2) (equipment {(board (add (remove (scale 1 2 (wedge 3)) vertices:{5}) edges:{{4 5}}) use:Vertex) (hand P1) (piece "Human" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Human1" (handSite P1) count:3) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 3) (result P2 Win))}))) 
A triangle, with a point in the center and lines connecting it to the apex and the midpoints of the two sides which meet at the apex. One person plays as the tiger, which begins on the apex. The other person plays as three people. Players alternate turns, with the person playing as the people first placing a person on the board, and then the tiger moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tiger may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tiger wins when it captures one person, the people win when they can block the tiger from being able to move.
(game "Mysore Tiger Game" (players 2) (equipment {(board (add (remove (scale 1 2 (wedge 3)) vertices:{5}) edges:{{4 5}}) use:Vertex) (hand P1) (piece "Human" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Human1" (handSite P1) count:3) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 3) (result P2 Win))}))) 
A triangle, with a point in the center and lines connecting it to the apex and the midpoints of the two sides which meet at the apex. One person plays as the tiger, which begins on the apex. The other person plays as three people. Players alternate turns, with the person playing as the people first placing a person on the board, and then the tiger moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tiger may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tiger wins when it captures one person, the people win when they can block the tiger from being able to move.
(game "Mysore Tiger Game" (players 2) (equipment {(board (add (remove (scale 1 2 (wedge 3)) vertices:{5}) edges:{{4 5}}) use:Vertex) (hand P1) (piece "Human" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Human1" (handSite P1) count:3) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 3) (result P2 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays as four tigers, the other as twenty goats. The tigers begin, two on the top two corners of the board, and two in the centers of the two bottom quadrants. Four of the goats are placed on any available points. The tigers move first, to an empty adjacent spot along the lines on the board. The player playing as the goats places one of the remaining goats on any available point. The goats cannot move until all of the goats are placed. Once they are all placed, the goats move as the tigers do. The tigers alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tigers win by capturing all the goats; the goats win by blocking the tigers from being able to move.
(game "Orissa Tiger Game (Four Tigers)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites {"A5" "E5" "B2" "D2"}))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (if (< 16 (count Cell at:(handSite P1))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays as four tigers, the other as twenty goats. The tigers begin, two on the top two corners of the board, and two in the centers of the two bottom quadrants. Four of the goats are placed on any available points. The tigers move first, to an empty adjacent spot along the lines on the board. The player playing as the goats places one of the remaining goats on any available point. The goats cannot move until all of the goats are placed. Once they are all placed, the goats move as the tigers do. The tigers alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tigers win by capturing all the goats; the goats win by blocking the tigers from being able to move.
(game "Orissa Tiger Game (Four Tigers)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites {"A5" "E5" "B2" "D2"}))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (if (< 16 (count Cell at:(handSite P1))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays as four tigers, the other as twenty goats. The tigers begin, two on the top two corners of the board, and two in the centers of the two bottom quadrants. Four of the goats are placed on any available points. The tigers move first, to an empty adjacent spot along the lines on the board. The player playing as the goats places one of the remaining goats on any available point. The goats cannot move until all of the goats are placed. Once they are all placed, the goats move as the tigers do. The tigers alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tigers win by capturing all the goats; the goats win by blocking the tigers from being able to move.
(game "Orissa Tiger Game (Four Tigers)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites {"A5" "E5" "B2" "D2"}))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (if (< 16 (count Cell at:(handSite P1))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
A triangle, with a line drawn from the apex to the base. A rectangle intersects with the triangle, and has a line connecting the midpoints of the short sides. One player plays as the tiger(s), one to four in number. The other player plays as five to 23 goats (or dogs, or lambs). The tiger begins on the apex of the triangle, and any other tigers on the spots adjacent to the apex. The tiger player moves by moving a piece to an empty adjacent spot along the lines of the board. The goat player begins the game by placing a goat on an empty point on the board, and then the tiger player moves. When all of the goats are placed, they move like the tiger. The tiger may capture a goat by hopping over it to an empty spot on the opposite adjacent side of the goat along the lines of the board. The goats win by blocking the tiger(s) from being able to move; the tiger(s) win by capturing enough goats to prevent them from blocking it/them. 1 Tiger. 5 Goats.
(game "Pulijudamu" (players 2) (equipment {(board (add (remove (merge (scale 1 2 (wedge 5 3)) (shift 0 2 (scale 8 2 (rectangle 3 2)))) edges:{{17 18} {15 16} {13 14}}) edges:{{13 7} {15 4} {17 1} {3 18} {6 16} {9 14}}) use:Vertex) (hand Each) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Goat2" (handSite P2) count:5) (place "Tiger1" (handSite P1) count:1)}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (if (= 0 (count Sites in:(intersection (sites Top) (sites Occupied by:Mover)))) (sites Top) (intersection (sites Empty) (sites {1 2 3})))) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Opening" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
A triangle, with a line drawn from the apex to the base. A rectangle intersects with the triangle, and has a line connecting the midpoints of the short sides. One player plays as the tiger(s), one to four in number. The other player plays as five to 23 goats (or dogs, or lambs). The tiger begins on the apex of the triangle, and any other tigers on the spots adjacent to the apex. The tiger player moves by moving a piece to an empty adjacent spot along the lines of the board. The goat player begins the game by placing a goat on an empty point on the board, and then the tiger player moves. When all of the goats are placed, they move like the tiger. The tiger may capture a goat by hopping over it to an empty spot on the opposite adjacent side of the goat along the lines of the board. The goats win by blocking the tiger(s) from being able to move; the tiger(s) win by capturing enough goats to prevent them from blocking it/them. 2 Tigers. 6 Goats.
(game "Pulijudamu" (players 2) (equipment {(board (add (remove (merge (scale 1 2 (wedge 5 3)) (shift 0 2 (scale 8 2 (rectangle 3 2)))) edges:{{17 18} {15 16} {13 14}}) edges:{{13 7} {15 4} {17 1} {3 18} {6 16} {9 14}}) use:Vertex) (hand Each) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Goat2" (handSite P2) count:6) (place "Tiger1" (handSite P1) count:2)}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (if (= 0 (count Sites in:(intersection (sites Top) (sites Occupied by:Mover)))) (sites Top) (intersection (sites Empty) (sites {1 2 3})))) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Opening" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
A triangle, with a line drawn from the apex to the base. A rectangle intersects with the triangle, and has a line connecting the midpoints of the short sides. One player plays as the tiger(s), one to four in number. The other player plays as five to 23 goats (or dogs, or lambs). The tiger begins on the apex of the triangle, and any other tigers on the spots adjacent to the apex. The tiger player moves by moving a piece to an empty adjacent spot along the lines of the board. The goat player begins the game by placing a goat on an empty point on the board, and then the tiger player moves. When all of the goats are placed, they move like the tiger. The tiger may capture a goat by hopping over it to an empty spot on the opposite adjacent side of the goat along the lines of the board. The goats win by blocking the tiger(s) from being able to move; the tiger(s) win by capturing enough goats to prevent them from blocking it/them. 3 Tigers. 7 Goats.
(game "Pulijudamu" (players 2) (equipment {(board (add (remove (merge (scale 1 2 (wedge 5 3)) (shift 0 2 (scale 8 2 (rectangle 3 2)))) edges:{{17 18} {15 16} {13 14}}) edges:{{13 7} {15 4} {17 1} {3 18} {6 16} {9 14}}) use:Vertex) (hand Each) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Goat2" (handSite P2) count:7) (place "Tiger1" (handSite P1) count:3)}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (if (= 0 (count Sites in:(intersection (sites Top) (sites Occupied by:Mover)))) (sites Top) (intersection (sites Empty) (sites {1 2 3})))) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Opening" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a diamond intersects with the central point of that side, with diagonals drawn in the diamond. One player plays as the monk, placed at the intersection of the diamond and the main board. The other player plays as fifteen water pieces, placed on each point along the perimeter of the main board. Players take turns moving their pieces to one adjacent point following the lines on the board. The monk may capture two water pieces by moving to an empty space between two water pieces. The goal of the water pieces is to trap the monk on the far point of the diamond. The monk wins by capturing all of the water.
(game "Shui Yen Ho-Shang" (players 2) (equipment {(board (merge (rotate 45 (shift 1.5 4.2 (square 2 diagonals:Solid))) (square 5 diagonals:Alternating)) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (move Step (to if:(is Empty (to))) (then (intervene (from (last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))}) (rules (start {(place "Marker2" coord:"C5") (place "Marker1" (difference (sites Outer) (sites {"B6" "C7" "D6"})))}) (play (forEach Piece)) (end {(if (no Pieces P1) (result P2 Win)) (if (and (no Moves P2) (is In (where "Marker" P2) (sites {"C7"}))) (result P1 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a diamond intersects with the central point of that side, with diagonals drawn in the diamond. One player plays as the monk, placed at the intersection of the diamond and the main board. The other player plays as fifteen water pieces, placed on each point along the perimeter of the main board. Players take turns moving their pieces to one adjacent point following the lines on the board. The monk may capture two water pieces by moving to an empty space between two water pieces. The goal of the water pieces is to trap the monk on the far point of the diamond. The monk wins by capturing all of the water.
(game "Shui Yen Ho-Shang" (players 2) (equipment {(board (merge (rotate 45 (shift 1.5 4.2 (square 2 diagonals:Solid))) (square 5 diagonals:Alternating)) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (move Step (to if:(is Empty (to))) (then (intervene (from (last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))}) (rules (start {(place "Marker2" coord:"C5") (place "Marker1" (difference (sites Outer) (sites {"B6" "C7" "D6"})))}) (play (forEach Piece)) (end {(if (no Pieces P1) (result P2 Win)) (if (and (no Moves P2) (is In (where "Marker" P2) (sites {"C7"}))) (result P1 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a diamond intersects with the central point of that side, with diagonals drawn in the diamond. One player plays as the monk, placed at the intersection of the diamond and the main board. The other player plays as fifteen water pieces, placed on each point along the perimeter of the main board. Players take turns moving their pieces to one adjacent point following the lines on the board. The monk may capture two water pieces by moving to an empty space between two water pieces. The goal of the water pieces is to trap the monk on the far point of the diamond. The monk wins by capturing all of the water.
(game "Shui Yen Ho-Shang" (players 2) (equipment {(board (merge (rotate 45 (shift 1.5 4.2 (square 2 diagonals:Solid))) (square 5 diagonals:Alternating)) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (move Step (to if:(is Empty (to))) (then (intervene (from (last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))}) (rules (start {(place "Marker2" coord:"C5") (place "Marker1" (difference (sites Outer) (sites {"B6" "C7" "D6"})))}) (play (forEach Piece)) (end {(if (no Pieces P1) (result P2 Win)) (if (and (no Moves P2) (is In (where "Marker" P2) (sites {"C7"}))) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, which begin on the four corners of the board. The other player plays as twenty goats, which begin off the board. Play begins by placing one of the goats on an empty spot. The other player then moves the tiger to an empty adjacent spot along the lines on the board. The tiger may hop over an adjacent goat, to an empty space on the opposite adjacent side of the goat along the lines. Play continues like this until all of the goats are placed, after which the goats also move to one adjacent spot along the lines. The tigers win by capturing all of the goats; the goats win by blocking the tigers from being able to move.
(game "Sumi Naga Game (Hunt)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites Corners))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Moving")) (phase "Moving" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, which begin on the four corners of the board. The other player plays as twenty goats, which begin off the board. Play begins by placing one of the goats on an empty spot. The other player then moves the tiger to an empty adjacent spot along the lines on the board. The tiger may hop over an adjacent goat, to an empty space on the opposite adjacent side of the goat along the lines. Play continues like this until all of the goats are placed, after which the goats also move to one adjacent spot along the lines. The tigers win by capturing all of the goats; the goats win by blocking the tigers from being able to move.
(game "Sumi Naga Game (Hunt)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites Corners))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Moving")) (phase "Moving" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, which begin on the four corners of the board. The other player plays as twenty goats, which begin off the board. Play begins by placing one of the goats on an empty spot. The other player then moves the tiger to an empty adjacent spot along the lines on the board. The tiger may hop over an adjacent goat, to an empty space on the opposite adjacent side of the goat along the lines. Play continues like this until all of the goats are placed, after which the goats also move to one adjacent spot along the lines. The tigers win by capturing all of the goats; the goats win by blocking the tigers from being able to move.
(game "Sumi Naga Game (Hunt)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites Corners))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Moving")) (phase "Moving" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
Two arcs which meet, in the shape of a horn, curving to the left. Nine points along the left side, and eight along the right, with one at the apex. Zig-zag lines connect points on either side of the board, connecting the first on the left to the first on the right, the first on the right to the second on the left, the second on the left to the second on the right, and so on. One player plays as the cow and the calf (black). The cow begins on the first point on the left, the calf on the second point on the right. The other player plays as two children (white), which begin on the second point on the left and the first point on the right. Players alternate turns moving a piece to an empty adjacent spot along the lines on the board. The cow never moves from its position. The calf plays first. The calf wins when it reaches the cow; the children win when they force the calf onto the apex of the board (the pasture).
(game "Uxrijn Ever" (players 2) (equipment {(board (graph vertices:{{0 0} {5 0} {0.17 1} {4.65 1} {0.3 2} {4.3 2} {0.38 3} {3.9 3} {0.25 4} {3.5 4} {-0.13 5} {2.97 5} {-0.75 6} {2.2 6} {-1.47 7} {0.95 7} {-2.22 8} {-3 9}} edges:{{0 1} {0 2} {2 4} {4 6} {6 8} {8 10} {10 12} {12 14} {14 16} {16 17} {1 3} {3 5} {5 7} {7 9} {9 11} {11 13} {13 15} {1 2} {2 3} {3 4} {4 5} {5 6} {6 7} {7 8} {8 9} {9 10} {10 11} {11 12} {12 13} {13 14} {14 15} {15 16} {15 17}}) use:Vertex) (piece "Cow" P1) (piece "Calf" P1 (move Step (to if:(or (= (what at:(to)) (id "Cow" P1)) (is Empty (to))) (apply (remove (to)))))) (piece "Human" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Cow1" 0) (place "Calf1" 3) (place "Human2" (sites {1 2}))}) (play (forEach Piece)) (end {(if (is In (where "Calf" P1) (sites Top)) (result P2 Win)) (if (= 1 (count Sites in:(sites Occupied by:P1))) (result P1 Win))}))) 
Two arcs which meet, in the shape of a horn, curving to the left. Nine points along the left side, and eight along the right, with one at the apex. Zig-zag lines connect points on either side of the board, connecting the first on the left to the first on the right, the first on the right to the second on the left, the second on the left to the second on the right, and so on. One player plays as the cow and the calf (black). The cow begins on the first point on the left, the calf on the second point on the right. The other player plays as two children (white), which begin on the second point on the left and the first point on the right. Players alternate turns moving a piece to an empty adjacent spot along the lines on the board. The cow never moves from its position. The calf plays first. The calf wins when it reaches the cow; the children win when they force the calf onto the apex of the board (the pasture).
(game "Uxrijn Ever" (players 2) (equipment {(board (graph vertices:{{0 0} {5 0} {0.17 1} {4.65 1} {0.3 2} {4.3 2} {0.38 3} {3.9 3} {0.25 4} {3.5 4} {-0.13 5} {2.97 5} {-0.75 6} {2.2 6} {-1.47 7} {0.95 7} {-2.22 8} {-3 9}} edges:{{0 1} {0 2} {2 4} {4 6} {6 8} {8 10} {10 12} {12 14} {14 16} {16 17} {1 3} {3 5} {5 7} {7 9} {9 11} {11 13} {13 15} {1 2} {2 3} {3 4} {4 5} {5 6} {6 7} {7 8} {8 9} {9 10} {10 11} {11 12} {12 13} {13 14} {14 15} {15 16} {15 17}}) use:Vertex) (piece "Cow" P1) (piece "Calf" P1 (move Step (to if:(or (= (what at:(to)) (id "Cow" P1)) (is Empty (to))) (apply (remove (to)))))) (piece "Human" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Cow1" 0) (place "Calf1" 3) (place "Human2" (sites {1 2}))}) (play (forEach Piece)) (end {(if (is In (where "Calf" P1) (sites Top)) (result P2 Win)) (if (= 1 (count Sites in:(sites Occupied by:P1))) (result P1 Win))}))) 
Two arcs which meet, in the shape of a horn, curving to the left. Nine points along the left side, and eight along the right, with one at the apex. Zig-zag lines connect points on either side of the board, connecting the first on the left to the first on the right, the first on the right to the second on the left, the second on the left to the second on the right, and so on. One player plays as the cow and the calf (black). The cow begins on the first point on the left, the calf on the second point on the right. The other player plays as two children (white), which begin on the second point on the left and the first point on the right. Players alternate turns moving a piece to an empty adjacent spot along the lines on the board. The cow never moves from its position. The calf plays first. The calf wins when it reaches the cow; the children win when they force the calf onto the apex of the board (the pasture).
(game "Uxrijn Ever" (players 2) (equipment {(board (graph vertices:{{0 0} {5 0} {0.17 1} {4.65 1} {0.3 2} {4.3 2} {0.38 3} {3.9 3} {0.25 4} {3.5 4} {-0.13 5} {2.97 5} {-0.75 6} {2.2 6} {-1.47 7} {0.95 7} {-2.22 8} {-3 9}} edges:{{0 1} {0 2} {2 4} {4 6} {6 8} {8 10} {10 12} {12 14} {14 16} {16 17} {1 3} {3 5} {5 7} {7 9} {9 11} {11 13} {13 15} {1 2} {2 3} {3 4} {4 5} {5 6} {6 7} {7 8} {8 9} {9 10} {10 11} {11 12} {12 13} {13 14} {14 15} {15 16} {15 17}}) use:Vertex) (piece "Cow" P1) (piece "Calf" P1 (move Step (to if:(or (= (what at:(to)) (id "Cow" P1)) (is Empty (to))) (apply (remove (to)))))) (piece "Human" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Cow1" 0) (place "Calf1" 3) (place "Human2" (sites {1 2}))}) (play (forEach Piece)) (end {(if (is In (where "Calf" P1) (sites Top)) (result P2 Win)) (if (= 1 (count Sites in:(sites Occupied by:P1))) (result P1 Win))}))) 
7x7 board. The central square, as well as the central square on each edge of the board, is marked with an X. Two to four players. Four pieces per player. Four cowries used as dice, the values are equal to the number of mouths which land face up; when all mouths are down the value = 8 and a "grace," all mouths up = a grace. Throws giving a grace also allow the player to throw again. Players are not obliged to play their throws if they do not wish to. Pieces enter the board with a grace on the marked square on the edge closest to the player. Pieces move along the outer squares of the board in an anti-clockwise direction. Upon reaching the square before the marked square where the player enters their pieces, the track proceeds in the left corner (respective to the player) of the next concentric track of squares, and proceeds in a clockwise spiraling track toward the central marked square. When a player's piece lands on a square occupied by an opponent's piece, the opponent's piece is removed from the board, and the player gains another throw. Pieces cannot be removed from the board if they are resting on a marked square. Players may enter their pieces onto the board when an opponent's piece is resting on their starting place. This first player to move all of their pieces to the central square by exact throws wins. The game involves 2 players.
(game "Ashta-kashte" (players 2) (equipment {(board (square 7) {(track "Track1" "27,N,W,S,E,N2,SW1,W4,N4,E4,S3,W3,N2,E2,S1,W1" P1 directed:True) (track "Track2" "21,S,E,N,W,S2,NE1,E4,S4,W4,N3,E3,S2,W2,N1,E1" P2 directed:True)}) (piece "Paddle" Each (if (and (is In (from) (sites Board)) (!= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -1)) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply if:(and (not (is In (to) (sites "ProtectedSites"))) (is Enemy (who at:(to)))) (and (fromTo (from (to)) (to (handSite (who at:(to))))) (moveAgain))))) (then (if (= 24 (last To)) (remove (last To)))))) (hand Each) (dice d:2 from:0 num:4) (map {(pair 1 "G4") (pair 2 "A4") (pair 3 "D1") (pair 4 "D7")}) (map "Throw" {(pair 0 8)}) (regions "ProtectedSites" (sites {0 3 6 21 27 3 45 42 48 24}))}) (rules (start {(place Stack "Paddle1" (handSite P1) count:4) (place Stack "Paddle2" (handSite P2) count:4)}) (play (do (roll) next:(or {(forEach Piece) (move Pass) (if (and (is In (count Pips) (array {0 4})) (!= 0 (who at:(handSite Mover)))) (move (from (handSite Mover)) (to (mapEntry Mover))))}) (then (if (is In (count Pips) (array {0 4})) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
7x7 board. The central square, as well as the central square on each edge of the board, is marked with an X. Two to four players. Four pieces per player. Four cowries used as dice, the values are equal to the number of mouths which land face up; when all mouths are down the value = 8 and a "grace," all mouths up = a grace. Throws giving a grace also allow the player to throw again. Players are not obliged to play their throws if they do not wish to. Pieces enter the board with a grace on the marked square on the edge closest to the player. Pieces move along the outer squares of the board in an anti-clockwise direction. Upon reaching the square before the marked square where the player enters their pieces, the track proceeds in the left corner (respective to the player) of the next concentric track of squares, and proceeds in a clockwise spiraling track toward the central marked square. When a player's piece lands on a square occupied by an opponent's piece, the opponent's piece is removed from the board, and the player gains another throw. Pieces cannot be removed from the board if they are resting on a marked square. Players may enter their pieces onto the board when an opponent's piece is resting on their starting place. This first player to move all of their pieces to the central square by exact throws wins. The game involves 3 players.
(game "Ashta-kashte" (players 3) (equipment {(board (square 7) {(track "Track1" "27,N,W,S,E,N2,SW1,W4,N4,E4,S3,W3,N2,E2,S1,W1" P1 directed:True) (track "Track2" "21,S,E,N,W,S2,NE1,E4,S4,W4,N3,E3,S2,W2,N1,E1" P2 directed:True) (track "Track3" "3,E,N,W,S,E2,NW1,N4,E4,S4,W3,N3,E2,S2,W1,N1" P3 directed:True)}) (piece "Paddle" Each (if (and (is In (from) (sites Board)) (!= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -1)) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply if:(and (not (is In (to) (sites "ProtectedSites"))) (is Enemy (who at:(to)))) (and (fromTo (from (to)) (to (handSite (who at:(to))))) (moveAgain))))) (then (if (= 24 (last To)) (remove (last To)))))) (hand Each) (dice d:2 from:0 num:4) (map {(pair 1 "G4") (pair 2 "A4") (pair 3 "D1") (pair 4 "D7")}) (map "Throw" {(pair 0 8)}) (regions "ProtectedSites" (sites {0 3 6 21 27 3 45 42 48 24}))}) (rules (start {(place Stack "Paddle1" (handSite P1) count:4) (place Stack "Paddle2" (handSite P2) count:4) (place Stack "Paddle3" (handSite P3) count:4)}) (play (do (roll) next:(or {(forEach Piece) (move Pass) (if (and (is In (count Pips) (array {0 4})) (!= 0 (who at:(handSite Mover)))) (move (from (handSite Mover)) (to (mapEntry Mover))))}) (then (if (is In (count Pips) (array {0 4})) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
7x7 board. The central square, as well as the central square on each edge of the board, is marked with an X. Two to four players. Four pieces per player. Four cowries used as dice, the values are equal to the number of mouths which land face up; when all mouths are down the value = 8 and a "grace," all mouths up = a grace. Throws giving a grace also allow the player to throw again. Players are not obliged to play their throws if they do not wish to. Pieces enter the board with a grace on the marked square on the edge closest to the player. Pieces move along the outer squares of the board in an anti-clockwise direction. Upon reaching the square before the marked square where the player enters their pieces, the track proceeds in the left corner (respective to the player) of the next concentric track of squares, and proceeds in a clockwise spiraling track toward the central marked square. When a player's piece lands on a square occupied by an opponent's piece, the opponent's piece is removed from the board, and the player gains another throw. Pieces cannot be removed from the board if they are resting on a marked square. Players may enter their pieces onto the board when an opponent's piece is resting on their starting place. This first player to move all of their pieces to the central square by exact throws wins. The game involves 4 players.
(game "Ashta-kashte" (players 4) (equipment {(board (square 7) {(track "Track1" "27,N,W,S,E,N2,SW1,W4,N4,E4,S3,W3,N2,E2,S1,W1" P1 directed:True) (track "Track2" "21,S,E,N,W,S2,NE1,E4,S4,W4,N3,E3,S2,W2,N1,E1" P2 directed:True) (track "Track3" "3,E,N,W,S,E2,NW1,N4,E4,S4,W3,N3,E2,S2,W1,N1" P3 directed:True) (track "Track4" "45,W,S,E,N,W2,SE1,S4,W4,N4,E3,S3,W2,N2,E1,S1" P4 directed:True)}) (piece "Paddle" Each (if (and (is In (from) (sites Board)) (!= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -1)) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply if:(and (not (is In (to) (sites "ProtectedSites"))) (is Enemy (who at:(to)))) (and (fromTo (from (to)) (to (handSite (who at:(to))))) (moveAgain))))) (then (if (= 24 (last To)) (remove (last To)))))) (hand Each) (dice d:2 from:0 num:4) (map {(pair 1 "G4") (pair 2 "A4") (pair 3 "D1") (pair 4 "D7")}) (map "Throw" {(pair 0 8)}) (regions "ProtectedSites" (sites {0 3 6 21 27 3 45 42 48 24}))}) (rules (start {(place Stack "Paddle1" (handSite P1) count:4) (place Stack "Paddle2" (handSite P2) count:4) (place Stack "Paddle3" (handSite P3) count:4) (place Stack "Paddle4" (handSite P4) count:4)}) (play (do (roll) next:(or {(forEach Piece) (move Pass) (if (and (is In (count Pips) (array {0 4})) (!= 0 (who at:(handSite Mover)))) (move (from (handSite Mover)) (to (mapEntry Mover))))}) (then (if (is In (count Pips) (array {0 4})) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces Play begins by each player rolling one die; the player with the highest roll plays first and plays the numbers on this first roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Backgammon" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (not (= (trackSite Move from:(from) steps:(pips)) -2))}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain))))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces Play begins by each player rolling one die; the player with the highest roll plays first and plays the numbers on this first roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Backgammon" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (not (= (trackSite Move from:(from) steps:(pips)) -2))}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain))))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces Play begins by each player rolling one die; the player with the highest roll plays first and plays the numbers on this first roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Backgammon" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (not (= (trackSite Move from:(from) steps:(pips)) -2))}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain))))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player with fifteen pieces on the rightmost point, the other player with fourteen pieces on the point behind it, and one on the point behind that. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
(game "Baralie" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice num:2) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 11 count:14) (place Stack "Disc2" 10)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceUsed) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:6) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:6) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player with fifteen pieces on the rightmost point, the other player with fourteen pieces on the point behind it, and one on the point behind that. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
(game "Baralie" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice num:2) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 11 count:14) (place Stack "Disc2" 10)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceUsed) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:6) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:6) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player with fifteen pieces on the rightmost point, the other player with fourteen pieces on the point behind it, and one on the point behind that. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
(game "Baralie" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice num:2) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 11 count:14) (place Stack "Disc2" 10)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceUsed) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:6) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:6) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a Tables board with sockets for the pieces instead of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die, another piece the value on another die, and another piece the value on the final die, by moving one piece the value of two of the die subsequently, and a second piece the value of the remaining die, or one piece the value of each die subsequently. Pieces begin off the board. Players must enter all of their pieces onto one half of the board (one player entering in the quadrant to their right and the other player's entering into the quadrant on their left), according to the throws of the dice. Once a player has entered all of their pieces, they move through all of the quadrants of the board toward the quadrant where the opponent entered their pieces. A piece landing on a space with a single opponent's piece sends the opponent's piece back to start, and it must be reentered. Once players enter all of their pieces into the final quadrant, they may bear off their pieces. They can do so by rolling a 6 to move from the sixth point, and so on down to 1. Throughout the game, a player must use the maximum number of moves presented by the dice. The first player to remove all of their pieces wins.
(game "Buffa de Baldrac" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (or (forEach Die combined:True if:(and (!= (pips) 0) (<= 0 (trackSite Move from:(from) steps:(pips)))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "LastQuadrant"))) (forEach Die combined:True if:(and (!= (pips) 0) (= (trackSite Move from:(from) steps:(pips)) -2)) (move Remove (from)) (then (if (not (all DiceUsed)) (moveAgain))))))) (regions "FirstQuadrant" P1 (sites {0 1 2 3 4 5})) (regions "FirstQuadrant" P2 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P1 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P2 (sites {0 1 2 3 4 5})) (map "StartTrack" {(pair P1 0) (pair P2 12)}) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (max Moves (do (if (not (is Prev Mover)) (roll)) next:(if (is Occupied (handSite Mover)) (forEach Die combined:True if:(and (!= (pips) 0) (is In (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) (sites Mover "FirstQuadrant"))) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (forEach Piece top:True))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a Tables board with sockets for the pieces instead of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die, another piece the value on another die, and another piece the value on the final die, by moving one piece the value of two of the die subsequently, and a second piece the value of the remaining die, or one piece the value of each die subsequently. Pieces begin off the board. Players must enter all of their pieces onto one half of the board (one player entering in the quadrant to their right and the other player's entering into the quadrant on their left), according to the throws of the dice. Once a player has entered all of their pieces, they move through all of the quadrants of the board toward the quadrant where the opponent entered their pieces. A piece landing on a space with a single opponent's piece sends the opponent's piece back to start, and it must be reentered. Once players enter all of their pieces into the final quadrant, they may bear off their pieces. They can do so by rolling a 6 to move from the sixth point, and so on down to 1. Throughout the game, a player must use the maximum number of moves presented by the dice. The first player to remove all of their pieces wins.
(game "Buffa de Baldrac" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (or (forEach Die combined:True if:(and (!= (pips) 0) (<= 0 (trackSite Move from:(from) steps:(pips)))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "LastQuadrant"))) (forEach Die combined:True if:(and (!= (pips) 0) (= (trackSite Move from:(from) steps:(pips)) -2)) (move Remove (from)) (then (if (not (all DiceUsed)) (moveAgain))))))) (regions "FirstQuadrant" P1 (sites {0 1 2 3 4 5})) (regions "FirstQuadrant" P2 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P1 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P2 (sites {0 1 2 3 4 5})) (map "StartTrack" {(pair P1 0) (pair P2 12)}) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (max Moves (do (if (not (is Prev Mover)) (roll)) next:(if (is Occupied (handSite Mover)) (forEach Die combined:True if:(and (!= (pips) 0) (is In (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) (sites Mover "FirstQuadrant"))) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (forEach Piece top:True))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a Tables board with sockets for the pieces instead of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die, another piece the value on another die, and another piece the value on the final die, by moving one piece the value of two of the die subsequently, and a second piece the value of the remaining die, or one piece the value of each die subsequently. Pieces begin off the board. Players must enter all of their pieces onto one half of the board (one player entering in the quadrant to their right and the other player's entering into the quadrant on their left), according to the throws of the dice. Once a player has entered all of their pieces, they move through all of the quadrants of the board toward the quadrant where the opponent entered their pieces. A piece landing on a space with a single opponent's piece sends the opponent's piece back to start, and it must be reentered. Once players enter all of their pieces into the final quadrant, they may bear off their pieces. They can do so by rolling a 6 to move from the sixth point, and so on down to 1. Throughout the game, a player must use the maximum number of moves presented by the dice. The first player to remove all of their pieces wins.
(game "Buffa de Baldrac" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (or (forEach Die combined:True if:(and (!= (pips) 0) (<= 0 (trackSite Move from:(from) steps:(pips)))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "LastQuadrant"))) (forEach Die combined:True if:(and (!= (pips) 0) (= (trackSite Move from:(from) steps:(pips)) -2)) (move Remove (from)) (then (if (not (all DiceUsed)) (moveAgain))))))) (regions "FirstQuadrant" P1 (sites {0 1 2 3 4 5})) (regions "FirstQuadrant" P2 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P1 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P2 (sites {0 1 2 3 4 5})) (map "StartTrack" {(pair P1 0) (pair P2 12)}) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (max Moves (do (if (not (is Prev Mover)) (roll)) next:(if (is Occupied (handSite Mover)) (forEach Die combined:True if:(and (!= (pips) 0) (is In (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) (sites Mover "FirstQuadrant"))) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (forEach Piece top:True))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw. When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins.
(game "Dubblets" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5} P1 directed:True) (track "Track2" {12 13 14 15 16 17} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (hand Each) (map "StartTrack" {(pair P1 0) (pair P2 12)})}) (rules (start {(place Stack "Disc1" (sites {0 1 2}) count:2) (place Stack "Disc1" (sites {3 4 5}) count:3) (place Stack "Disc2" (sites {12 13 14}) count:2) (place Stack "Disc2" (sites {15 16 17}) count:3)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (if (= (state at:(site)) 0) (move Select (from (site)) (then (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))))) (if (= (state at:(site)) 1) (move Select (from (site)) (then (forEach Level (last To) (set State at:(last To) level:(level) 2)))))) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain))))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (move Remove (site)) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Piece top:True)) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw. When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins.
(game "Dubblets" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5} P1 directed:True) (track "Track2" {12 13 14 15 16 17} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (hand Each) (map "StartTrack" {(pair P1 0) (pair P2 12)})}) (rules (start {(place Stack "Disc1" (sites {0 1 2}) count:2) (place Stack "Disc1" (sites {3 4 5}) count:3) (place Stack "Disc2" (sites {12 13 14}) count:2) (place Stack "Disc2" (sites {15 16 17}) count:3)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (if (= (state at:(site)) 0) (move Select (from (site)) (then (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))))) (if (= (state at:(site)) 1) (move Select (from (site)) (then (forEach Level (last To) (set State at:(last To) level:(level) 2)))))) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain))))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (move Remove (site)) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Piece top:True)) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw. When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins.
(game "Dubblets" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5} P1 directed:True) (track "Track2" {12 13 14 15 16 17} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (hand Each) (map "StartTrack" {(pair P1 0) (pair P2 12)})}) (rules (start {(place Stack "Disc1" (sites {0 1 2}) count:2) (place Stack "Disc1" (sites {3 4 5}) count:3) (place Stack "Disc2" (sites {12 13 14}) count:2) (place Stack "Disc2" (sites {15 16 17}) count:3)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (if (= (state at:(site)) 0) (move Select (from (site)) (then (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))))) (if (= (state at:(site)) 1) (move Select (from (site)) (then (forEach Level (last To) (set State at:(last To) level:(level) 2)))))) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain))))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (move Remove (site)) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Piece top:True)) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final six points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Frangieh" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final six points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Frangieh" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final six points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Frangieh" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
3x14 board. Fourteen pieces per player, placed in the outer rows of the board. Two knucklebones used as dice. Players move their pieces according to the throws of the knucklebones. Pieces move in a boustrophedon path along the board. The first player to remove their pieces from the board wins.
(game "Had" (players 2) (equipment {(board (rectangle 3 14) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "41,W,S1,E,S1,W" P2 directed:True)}) (dice d:4 num:2) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(count Pips)) if:(is Empty (to))))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (do (roll) next:(forEach Piece))) (end (if (no Pieces Mover) (result Mover Win))))) 
3x14 board. Fourteen pieces per player, placed in the outer rows of the board. Two knucklebones used as dice. Players move their pieces according to the throws of the knucklebones. Pieces move in a boustrophedon path along the board. The first player to remove their pieces from the board wins.
(game "Had" (players 2) (equipment {(board (rectangle 3 14) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "41,W,S1,E,S1,W" P2 directed:True)}) (dice d:4 num:2) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(count Pips)) if:(is Empty (to))))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (do (roll) next:(forEach Piece))) (end (if (no Pieces Mover) (result Mover Win))))) 
3x14 board. Fourteen pieces per player, placed in the outer rows of the board. Two knucklebones used as dice. Players move their pieces according to the throws of the knucklebones. Pieces move in a boustrophedon path along the board. The first player to remove their pieces from the board wins.
(game "Had" (players 2) (equipment {(board (rectangle 3 14) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "41,W,S1,E,S1,W" P2 directed:True)}) (dice d:4 num:2) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(count Pips)) if:(is Empty (to))))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (do (roll) next:(forEach Piece))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The players enter their pieces on the board on the points corresponding to the throws of the dice. A player who rolls a number corresponding to a point on the opponent's side of the board that contains a piece should remove the piece from the opponent's point, which must be reentered. If the player fails to do so, they lose instantly. Otherwise, players continue to place their pieces until all are on the board, and they then bear the pieces off from the same quadrant of the board. The first player to bear off all their pieces wins.
(game "Ketch-Dolt" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 12 11 10 9 8 7} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (or (if (is Empty (handSite Mover)) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track" steps:(pips)) -1) (do (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)) next:(move Remove (from)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Die if:(!= (pips) 0) (or (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (move (from (if (is Mover P1) (trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)) (trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1)))) (to (handSite Next)))) (move (from (from)) (to (trackSite Move from:(from) "Track" steps:(pips)) (apply (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (hand Each) (map "Start" {(pair P1 12) (pair P2 25)})}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end {(if (is Triggered "ShouldCapture" P1) (result P1 Loss)) (if (is Triggered "ShouldCapture" P2) (result P2 Loss)) (if (no Pieces Mover) (result Mover Win))}))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The players enter their pieces on the board on the points corresponding to the throws of the dice. A player who rolls a number corresponding to a point on the opponent's side of the board that contains a piece should remove the piece from the opponent's point, which must be reentered. If the player fails to do so, they lose instantly. Otherwise, players continue to place their pieces until all are on the board, and they then bear the pieces off from the same quadrant of the board. The first player to bear off all their pieces wins.
(game "Ketch-Dolt" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 12 11 10 9 8 7} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (or (if (is Empty (handSite Mover)) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track" steps:(pips)) -1) (do (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)) next:(move Remove (from)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Die if:(!= (pips) 0) (or (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (move (from (if (is Mover P1) (trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)) (trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1)))) (to (handSite Next)))) (move (from (from)) (to (trackSite Move from:(from) "Track" steps:(pips)) (apply (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (hand Each) (map "Start" {(pair P1 12) (pair P2 25)})}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end {(if (is Triggered "ShouldCapture" P1) (result P1 Loss)) (if (is Triggered "ShouldCapture" P2) (result P2 Loss)) (if (no Pieces Mover) (result Mover Win))}))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The players enter their pieces on the board on the points corresponding to the throws of the dice. A player who rolls a number corresponding to a point on the opponent's side of the board that contains a piece should remove the piece from the opponent's point, which must be reentered. If the player fails to do so, they lose instantly. Otherwise, players continue to place their pieces until all are on the board, and they then bear the pieces off from the same quadrant of the board. The first player to bear off all their pieces wins.
(game "Ketch-Dolt" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 12 11 10 9 8 7} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (or (if (is Empty (handSite Mover)) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track" steps:(pips)) -1) (do (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)) next:(move Remove (from)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Die if:(!= (pips) 0) (or (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (move (from (if (is Mover P1) (trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)) (trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1)))) (to (handSite Next)))) (move (from (from)) (to (trackSite Move from:(from) "Track" steps:(pips)) (apply (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (hand Each) (map "Start" {(pair P1 12) (pair P2 25)})}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end {(if (is Triggered "ShouldCapture" P1) (result P1 Loss)) (if (is Triggered "ShouldCapture" P2) (result P2 Loss)) (if (no Pieces Mover) (result Mover Win))}))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow the player to unstack all pieces on that point. The player then bears off the pieces from this quadrant of the board. Players bear off the pieces in the same manner as they were unstacked. The first player to bear off all their pieces wins.
(game "Kiz Tavlasi" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {7 8 9 10 11 12} P1 directed:True) (track "Track2" {18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (map "StartTrack" {(pair P1 7) (pair P2 18)})}) (rules (start {(place Stack "Disc1" (sites {7 8 9}) count:2) (place Stack "Disc1" (sites {10 11 12}) count:3) (place Stack "Disc2" (sites {13 14 15}) count:3) (place Stack "Disc2" (sites {16 17 18}) count:2)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain)))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (or (all DiceEqual) (not (is Prev Mover))) (roll)) next:(forEach Piece top:True) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow the player to unstack all pieces on that point. The player then bears off the pieces from this quadrant of the board. Players bear off the pieces in the same manner as they were unstacked. The first player to bear off all their pieces wins.
(game "Kiz Tavlasi" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {7 8 9 10 11 12} P1 directed:True) (track "Track2" {18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (map "StartTrack" {(pair P1 7) (pair P2 18)})}) (rules (start {(place Stack "Disc1" (sites {7 8 9}) count:2) (place Stack "Disc1" (sites {10 11 12}) count:3) (place Stack "Disc2" (sites {13 14 15}) count:3) (place Stack "Disc2" (sites {16 17 18}) count:2)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain)))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (or (all DiceEqual) (not (is Prev Mover))) (roll)) next:(forEach Piece top:True) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow the player to unstack all pieces on that point. The player then bears off the pieces from this quadrant of the board. Players bear off the pieces in the same manner as they were unstacked. The first player to bear off all their pieces wins.
(game "Kiz Tavlasi" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {7 8 9 10 11 12} P1 directed:True) (track "Track2" {18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (map "StartTrack" {(pair P1 7) (pair P2 18)})}) (rules (start {(place Stack "Disc1" (sites {7 8 9}) count:2) (place Stack "Disc1" (sites {10 11 12}) count:3) (place Stack "Disc2" (sites {13 14 15}) count:3) (place Stack "Disc2" (sites {16 17 18}) count:2)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain)))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (or (all DiceEqual) (not (is Prev Mover))) (roll)) next:(forEach Piece top:True) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
Each player begins at the end of one of the "wings" on the board. Two pieces per player. Moves are determined by the throw of two sticks with a rounded side and a flat side. Rolls are as follows: two round sides up= 1, one flat and one round =2, two flat sides =3, plus another throw. Players move their pieces the appropriate number of spaces onto the board. When a piece is in the central four spaces of the main part of the board, pieces may be taken. A piece is taken when the opponent lands on the same space as a piece, sending it back to the beginning. In these central four squares, the player may choose to proceed upward again either on the first or second space, but may not change direction again. A player may cross the "bridge" to the other four spaces by throwing a 3, always stopping on the first space after the bridge, regardless of whether thre . The player then may move to the space closest to them, if a roll allows, where they are safe, and then to the apex point of the board, where they may also be sent to start if the opponent lands there. From there, they must give an exact throw to exit the board. The first player to remove both of their pieces wins. The game is played again, and the first player to win three games is the winner. Rules from Seleucid.
(game "Knossos Game" (players 2) (equipment {(board (merge {(rectangle 1 4) (shift 1 1 (rectangle 1 2)) (shift 0 -2 (rectangle 3 1)) (shift 3 -2 (rectangle 3 1)) (shift 1.5 4 (scale 2 (rectangle 2 1))) (shift 0 5 (scale 3 (rectangle 1 2)))}) {(track "TrackBottom1" "14,6,7,0,1,4") (track "TrackBottom2" "15,8,9,3,2,5") (track "TrackOpposite1" "7,0,1,2,5") (track "TrackOpposite2" "9,3,2,1,4") (track "TrackCross1" "0,1,4,10,12,11") (track "TrackCross2" "3,2,5,10,13,11") (track "TrackTop1" "10,12,11,End") (track "TrackTop2" "10,13,11,End")} use:Vertex) (dice d:2 from:0 num:2) (piece "RoundPawn" Each (or {(if (= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (is Mover P1) (if (= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (if (and {(not (is Friend (who at:10))) (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (not (is In (from) (sites "TopSites")))}) (if (or (can Move (if (= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (can Move (if (= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))) (move (from) (to 10 (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))})) (hand Each) (regions "TopSites" (sites {10 11 12 13}))}) (rules (start (place "RoundPawn" "Hand" count:2)) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))) (then (if (no Pieces Mover) (and (addScore Mover 1) (if (!= (score Mover) 2) (and {(forEach Site (sites Occupied by:All container:"Board") (remove (site))) (if (!= 0 (who at:(handSite P1))) (remove (handSite P1))) (if (!= 0 (who at:(handSite P2))) (remove (handSite P2))) (add (piece (id "RoundPawn" P1)) (to (handSite P1)) count:2) (add (piece (id "RoundPawn" P2)) (to (handSite P2)) count:2)}))) (if (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (moveAgain)))))) (end (if (= (score Mover) 3) (result Mover Win))))) 
Each player begins at the end of one of the "wings" on the board. Two pieces per player. Moves are determined by the throw of two sticks with a rounded side and a flat side. Rolls are as follows: two round sides up= 1, one flat and one round =2, two flat sides =3, plus another throw. Players move their pieces the appropriate number of spaces onto the board. When a piece is in the central four spaces of the main part of the board, pieces may be taken. A piece is taken when the opponent lands on the same space as a piece, sending it back to the beginning. In these central four squares, the player may choose to proceed upward again either on the first or second space, but may not change direction again. A player may cross the "bridge" to the other four spaces by throwing a 3, always stopping on the first space after the bridge, regardless of whether thre . The player then may move to the space closest to them, if a roll allows, where they are safe, and then to the apex point of the board, where they may also be sent to start if the opponent lands there. From there, they must give an exact throw to exit the board. The first player to remove both of their pieces wins. The game is played again, and the first player to win three games is the winner. Rules from Seleucid.
(game "Knossos Game" (players 2) (equipment {(board (merge {(rectangle 1 4) (shift 1 1 (rectangle 1 2)) (shift 0 -2 (rectangle 3 1)) (shift 3 -2 (rectangle 3 1)) (shift 1.5 4 (scale 2 (rectangle 2 1))) (shift 0 5 (scale 3 (rectangle 1 2)))}) {(track "TrackBottom1" "14,6,7,0,1,4") (track "TrackBottom2" "15,8,9,3,2,5") (track "TrackOpposite1" "7,0,1,2,5") (track "TrackOpposite2" "9,3,2,1,4") (track "TrackCross1" "0,1,4,10,12,11") (track "TrackCross2" "3,2,5,10,13,11") (track "TrackTop1" "10,12,11,End") (track "TrackTop2" "10,13,11,End")} use:Vertex) (dice d:2 from:0 num:2) (piece "RoundPawn" Each (or {(if (= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (is Mover P1) (if (= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (if (and {(not (is Friend (who at:10))) (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (not (is In (from) (sites "TopSites")))}) (if (or (can Move (if (= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (can Move (if (= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))) (move (from) (to 10 (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))})) (hand Each) (regions "TopSites" (sites {10 11 12 13}))}) (rules (start (place "RoundPawn" "Hand" count:2)) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))) (then (if (no Pieces Mover) (and (addScore Mover 1) (if (!= (score Mover) 2) (and {(forEach Site (sites Occupied by:All container:"Board") (remove (site))) (if (!= 0 (who at:(handSite P1))) (remove (handSite P1))) (if (!= 0 (who at:(handSite P2))) (remove (handSite P2))) (add (piece (id "RoundPawn" P1)) (to (handSite P1)) count:2) (add (piece (id "RoundPawn" P2)) (to (handSite P2)) count:2)}))) (if (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (moveAgain)))))) (end (if (= (score Mover) 3) (result Mover Win))))) 
Each player begins at the end of one of the "wings" on the board. Two pieces per player. Moves are determined by the throw of two sticks with a rounded side and a flat side. Rolls are as follows: two round sides up= 1, one flat and one round =2, two flat sides =3, plus another throw. Players move their pieces the appropriate number of spaces onto the board. When a piece is in the central four spaces of the main part of the board, pieces may be taken. A piece is taken when the opponent lands on the same space as a piece, sending it back to the beginning. In these central four squares, the player may choose to proceed upward again either on the first or second space, but may not change direction again. A player may cross the "bridge" to the other four spaces by throwing a 3, always stopping on the first space after the bridge, regardless of whether thre . The player then may move to the space closest to them, if a roll allows, where they are safe, and then to the apex point of the board, where they may also be sent to start if the opponent lands there. From there, they must give an exact throw to exit the board. The first player to remove both of their pieces wins. The game is played again, and the first player to win three games is the winner. Rules from Seleucid.
(game "Knossos Game" (players 2) (equipment {(board (merge {(rectangle 1 4) (shift 1 1 (rectangle 1 2)) (shift 0 -2 (rectangle 3 1)) (shift 3 -2 (rectangle 3 1)) (shift 1.5 4 (scale 2 (rectangle 2 1))) (shift 0 5 (scale 3 (rectangle 1 2)))}) {(track "TrackBottom1" "14,6,7,0,1,4") (track "TrackBottom2" "15,8,9,3,2,5") (track "TrackOpposite1" "7,0,1,2,5") (track "TrackOpposite2" "9,3,2,1,4") (track "TrackCross1" "0,1,4,10,12,11") (track "TrackCross2" "3,2,5,10,13,11") (track "TrackTop1" "10,12,11,End") (track "TrackTop2" "10,13,11,End")} use:Vertex) (dice d:2 from:0 num:2) (piece "RoundPawn" Each (or {(if (= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (is Mover P1) (if (= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (if (and {(not (is Friend (who at:10))) (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (not (is In (from) (sites "TopSites")))}) (if (or (can Move (if (= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (can Move (if (= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))) (move (from) (to 10 (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))})) (hand Each) (regions "TopSites" (sites {10 11 12 13}))}) (rules (start (place "RoundPawn" "Hand" count:2)) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))) (then (if (no Pieces Mover) (and (addScore Mover 1) (if (!= (score Mover) 2) (and {(forEach Site (sites Occupied by:All container:"Board") (remove (site))) (if (!= 0 (who at:(handSite P1))) (remove (handSite P1))) (if (!= 0 (who at:(handSite P2))) (remove (handSite P2))) (add (piece (id "RoundPawn" P1)) (to (handSite P1)) count:2) (add (piece (id "RoundPawn" P2)) (to (handSite P2)) count:2)}))) (if (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (moveAgain)))))) (end (if (= (score Mover) 3) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto the same section of the board, and proceed around the board to the point opposite the starting point, and then off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins.
(game "Lange Puff" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:(= 1 (value Player Mover)) if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain) (if (= 1 (value Player Mover)) (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) (and (moveAgain) (set Var "PlayOpposite" 1))) (set Value Mover 1)))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(if (= 1 (var "PlayOpposite")) (or {(forEach Piece (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (forEach Piece container:(mover) (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (move Pass (then (and {(forget Value "Opposite" All) (set Var "PlayOpposite" 0) (set Pending) (moveAgain)})))}) (do (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (= 1 (value Player Mover))}) (and (remember Value "Opposite" (- 7 (face 28))) (remember Value "Opposite" (- 7 (face 28))))) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto the same section of the board, and proceed around the board to the point opposite the starting point, and then off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins.
(game "Lange Puff" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:(= 1 (value Player Mover)) if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain) (if (= 1 (value Player Mover)) (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) (and (moveAgain) (set Var "PlayOpposite" 1))) (set Value Mover 1)))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(if (= 1 (var "PlayOpposite")) (or {(forEach Piece (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (forEach Piece container:(mover) (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (move Pass (then (and {(forget Value "Opposite" All) (set Var "PlayOpposite" 0) (set Pending) (moveAgain)})))}) (do (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (= 1 (value Player Mover))}) (and (remember Value "Opposite" (- 7 (face 28))) (remember Value "Opposite" (- 7 (face 28))))) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto the same section of the board, and proceed around the board to the point opposite the starting point, and then off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins.
(game "Lange Puff" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:(= 1 (value Player Mover)) if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain) (if (= 1 (value Player Mover)) (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) (and (moveAgain) (set Var "PlayOpposite" 1))) (set Value Mover 1)))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(if (= 1 (var "PlayOpposite")) (or {(forEach Piece (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (forEach Piece container:(mover) (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (move Pass (then (and {(forget Value "Opposite" All) (set Var "PlayOpposite" 0) (set Pending) (moveAgain)})))}) (do (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (= 1 (value Player Mover))}) (and (remember Value "Opposite" (- 7 (face 28))) (remember Value "Opposite" (- 7 (face 28))))) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw. The game involves 2 dice
(game "Medio Emperador" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:2) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces Mover) (result Mover Win)) (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))}))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw. The game involves 3 dice
(game "Medio Emperador" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces Mover) (result Mover Win)) (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))}))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw. The game involves 2 dice
(game "Medio Emperador" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:2) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces Mover) (result Mover Win)) (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))}))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according to the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant.
(game "Nard" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (map "Bar" {(pair P1 6) (pair P2 19)}) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))}) (rules (start {(place Stack "Disc1" 7 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 13 count:5) (place Stack "Disc1" 25 count:2) (place Stack "Disc2" 20 count:5) (place Stack "Disc2" 17 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 12 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (mapEntry "Bar" Mover)) (forEach Die if:(!= (pips) 0) (move (from (mapEntry "Bar" Mover)) (to (trackSite Move from:(mapEntry "Bar" Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry "Bar" Mover)) (max Distance (forEach Piece top:True)))}) (then (if (no Pieces Mover) (if (no Pieces Enemy in:(sites Mover "FinalQuadrant")) (addScore Mover 1) (addScore Mover 2)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according to the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant.
(game "Nard" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (map "Bar" {(pair P1 6) (pair P2 19)}) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))}) (rules (start {(place Stack "Disc1" 7 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 13 count:5) (place Stack "Disc1" 25 count:2) (place Stack "Disc2" 20 count:5) (place Stack "Disc2" 17 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 12 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (mapEntry "Bar" Mover)) (forEach Die if:(!= (pips) 0) (move (from (mapEntry "Bar" Mover)) (to (trackSite Move from:(mapEntry "Bar" Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry "Bar" Mover)) (max Distance (forEach Piece top:True)))}) (then (if (no Pieces Mover) (if (no Pieces Enemy in:(sites Mover "FinalQuadrant")) (addScore Mover 1) (addScore Mover 2)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according to the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant.
(game "Nard" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (map "Bar" {(pair P1 6) (pair P2 19)}) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))}) (rules (start {(place Stack "Disc1" 7 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 13 count:5) (place Stack "Disc1" 25 count:2) (place Stack "Disc2" 20 count:5) (place Stack "Disc2" 17 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 12 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (mapEntry "Bar" Mover)) (forEach Die if:(!= (pips) 0) (move (from (mapEntry "Bar" Mover)) (to (trackSite Move from:(mapEntry "Bar" Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry "Bar" Mover)) (max Distance (forEach Piece top:True)))}) (then (if (no Pieces Mover) (if (no Pieces Enemy in:(sites Mover "FinalQuadrant")) (addScore Mover 1) (addScore Mover 2)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players enter their pieces into the same quadrant of the board, and move pieces along a horseshoe-shaped track around the board toward the quadrant on the opposite side of the board. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board and must enter again as before. When all of the dice present the same number, the player receives another turn. The player to bear off all of their pieces first wins. The game involves 3 dice
(game "Pareia de Entrada" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (all DiceUsed) (all DiceEqual)) (and (set Pending) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players enter their pieces into the same quadrant of the board, and move pieces along a horseshoe-shaped track around the board toward the quadrant on the opposite side of the board. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board and must enter again as before. When all of the dice present the same number, the player receives another turn. The player to bear off all of their pieces first wins. The game involves 2 dice
(game "Pareia de Entrada" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P2 directed:True)} use:Vertex) (dice d:6 num:2) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (all DiceUsed) (all DiceEqual)) (and (set Pending) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players enter their pieces into the same quadrant of the board, and move pieces along a horseshoe-shaped track around the board toward the quadrant on the opposite side of the board. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board and must enter again as before. When all of the dice present the same number, the player receives another turn. The player to bear off all of their pieces first wins. The game involves 3 dice
(game "Pareia de Entrada" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (all DiceUsed) (all DiceEqual)) (and (set Pending) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Cross-shaped board, with two opposite arms bent at a right angle. Line cross each arm, creating 55 intersections where the pieces are placed. Two teams of one, two, or three people play, with each player controlling one piece. Four longitudinally split reed are used as dice, two are unmarked on the concave side which count as 1, and the other two are marked, and count as 15 and 20. The throws are as follows: All convex faces up = 10; all concave sides up = 5; one concave side up = the value of that side; two concave sides up = 2, three concave sides up =3, A player must throw 10 or more to enter the board. Once a piece is entered, the player throws three times consecutively. Each player owns one of the bent arms of the board, and the piece move anti-clockwise from the right hand end of the arm, to the exit at the left hand end of the arm, but not entering the opponent's arm. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the central spot (spot 25) are safe from being sent back. When a piece enters the player's arm again as they approach the goal, throws of 10, 15, and 20 count as 1. On the penultimate space, a throw of 2, 3, or 5 allows a piece to exit, but on the final space a throw of 1, 10, 15, or 20 is required. If playing on teams, a player who has reached the goal continues to throw and use those throws to move their teammates' pieces. The first team to remove all their pieces from the board wins. The game is played with 6 players.
(game "Petol" (players 6) (equipment {(board (remove (merge {(shift 0 7 (scale 2 1 (rectangle 3 2))) (scale 2 1 (rectangle 8 2)) (shift 0 9 (scale 2 1 (rectangle 8 2))) (shift 4.5 1 (scale 2 1 (rectangle 6 2))) (shift -4.5 10 (scale 2 1 (rectangle 6 2))) (shift 4.5 6 (graph vertices:{{0 0} {0 1} {2 3} {2 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 2 7 (graph vertices:{{0 0} {0 2} {4.5 2} {2.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 0 7 (graph vertices:{{0 0} {0 2} {-2.5 2} {-4.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift -2.5 10 (graph vertices:{{0 0} {0 -1} {-2 -3} {-2 0}} edges:{{0 1} {1 2} {2 3} {3 0}}))}) edges:{{2 3}}) {(track "Track1" "56,S,E1,S,E,N,W,S7,W1,N,End" P1 directed:True) (track "Track2" "35,N,W1,N,W,S,E,N7,E1,S,End" P2 directed:True) (track "Track3" "56,S,E1,S,E,N,W,S7,W1,N,End" P3 directed:True) (track "Track4" "35,N,W1,N,W,S,E,N7,E1,S,End" P4 directed:True) (track "Track5" "56,S,E1,S,E,N,W,S7,W1,N,End" P5 directed:True) (track "Track6" "35,N,W1,N,W,S,E,N7,E1,S,End" P6 directed:True)} use:Vertex) (dice d:2 facesByDie:{{0 1} {0 1} {0 15} {0 20}} num:4) (piece "Marker" Each (if (= (trackSite Move from:(from) steps:1) -2) (if (or {(= 1 (mapEntry "Throw" (count Pips))) (= 10 (mapEntry "Throw" (count Pips))) (= 15 (mapEntry "Throw" (count Pips))) (= 20 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (= (trackSite Move from:(from) steps:2) -2) (or (if (or {(= 2 (mapEntry "Throw" (count Pips))) (= 3 (mapEntry "Throw" (count Pips))) (= 5 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1))))) (if (is In (from) (sites Mover "EndTrack")) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) 1 (mapEntry "Throw" (count Pips)))) if:True)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 37 5) (pair 1 1) (pair 15 15) (pair 20 20) (pair 2 2) (pair 16 2) (pair 21 2) (pair 35 2) (pair 17 3) (pair 22 3) (pair 36 3)}) (map "Entry" {(pair P1 56) (pair P2 35) (pair P3 56) (pair P4 35) (pair P5 56) (pair P6 35)}) (regions "SafeSites" (sites {2 3})) (regions "EndTrack" P1 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P2 (sites {58 44 42 40 38 36 34})) (regions "EndTrack" P3 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P4 (sites {58 44 42 40 38 36 34})) (regions "EndTrack" P5 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P6 (sites {58 44 42 40 38 36 34}))}) (rules (start {(set Team 1 {P1 P3 P5}) (set Team 2 {P2 P4 P6}) (place "Marker1" (handSite P1)) (place "Marker2" (handSite P2)) (place "Marker3" (handSite P3)) (place "Marker4" (handSite P4)) (place "Marker5" (handSite P5)) (place "Marker6" (handSite P6))}) (play (do (roll) next:(or {(if (and (is Occupied (handSite Mover)) (<= 10 (mapEntry "Throw" (count Pips)))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)) (then (and (moveAgain) (set Value Mover 0))))) (forEach Piece (then (if (and (< -1 (value Player Mover)) (> 3 (value Player Mover))) (if (> 2 (value Player Mover)) (and (moveAgain) (set Value Mover (+ 1 (value Player Mover)))) (set Value Mover (+ 1 (value Player Mover))))))) (if (no Pieces Mover) (if (or {(is Mover P1) (is Mover P3) (is Mover P5)}) (or {(forEach Piece P1) (forEach Piece P3) (forEach Piece P5)}) (or {(forEach Piece P2) (forEach Piece P4) (forEach Piece P6)})))}))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
Cross-shaped board, with two opposite arms bent at a right angle. Line cross each arm, creating 55 intersections where the pieces are placed. Two teams of one, two, or three people play, with each player controlling one piece. Four longitudinally split reed are used as dice, two are unmarked on the concave side which count as 1, and the other two are marked, and count as 15 and 20. The throws are as follows: All convex faces up = 10; all concave sides up = 5; one concave side up = the value of that side; two concave sides up = 2, three concave sides up =3, A player must throw 10 or more to enter the board. Once a piece is entered, the player throws three times consecutively. Each player owns one of the bent arms of the board, and the piece move anti-clockwise from the right hand end of the arm, to the exit at the left hand end of the arm, but not entering the opponent's arm. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the central spot (spot 25) are safe from being sent back. When a piece enters the player's arm again as they approach the goal, throws of 10, 15, and 20 count as 1. On the penultimate space, a throw of 2, 3, or 5 allows a piece to exit, but on the final space a throw of 1, 10, 15, or 20 is required. If playing on teams, a player who has reached the goal continues to throw and use those throws to move their teammates' pieces. The first team to remove all their pieces from the board wins. The game is played with 2 players.
(game "Petol" (players 2) (equipment {(board (remove (merge {(shift 0 7 (scale 2 1 (rectangle 3 2))) (scale 2 1 (rectangle 8 2)) (shift 0 9 (scale 2 1 (rectangle 8 2))) (shift 4.5 1 (scale 2 1 (rectangle 6 2))) (shift -4.5 10 (scale 2 1 (rectangle 6 2))) (shift 4.5 6 (graph vertices:{{0 0} {0 1} {2 3} {2 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 2 7 (graph vertices:{{0 0} {0 2} {4.5 2} {2.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 0 7 (graph vertices:{{0 0} {0 2} {-2.5 2} {-4.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift -2.5 10 (graph vertices:{{0 0} {0 -1} {-2 -3} {-2 0}} edges:{{0 1} {1 2} {2 3} {3 0}}))}) edges:{{2 3}}) {(track "Track1" "56,S,E1,S,E,N,W,S7,W1,N,End" P1 directed:True) (track "Track2" "35,N,W1,N,W,S,E,N7,E1,S,End" P2 directed:True)} use:Vertex) (dice d:2 facesByDie:{{0 1} {0 1} {0 15} {0 20}} num:4) (piece "Marker" Each (if (= (trackSite Move from:(from) steps:1) -2) (if (or {(= 1 (mapEntry "Throw" (count Pips))) (= 10 (mapEntry "Throw" (count Pips))) (= 15 (mapEntry "Throw" (count Pips))) (= 20 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (= (trackSite Move from:(from) steps:2) -2) (or (if (or {(= 2 (mapEntry "Throw" (count Pips))) (= 3 (mapEntry "Throw" (count Pips))) (= 5 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1))))) (if (is In (from) (sites Mover "EndTrack")) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) 1 (mapEntry "Throw" (count Pips)))) if:True)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 37 5) (pair 1 1) (pair 15 15) (pair 20 20) (pair 2 2) (pair 16 2) (pair 21 2) (pair 35 2) (pair 17 3) (pair 22 3) (pair 36 3)}) (map "Entry" {(pair P1 56) (pair P2 35)}) (regions "SafeSites" (sites {2 3})) (regions "EndTrack" P1 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P2 (sites {58 44 42 40 38 36 34}))}) (rules (start {(set Team 1 {P1}) (set Team 2 {P2}) (place "Marker1" (handSite P1)) (place "Marker2" (handSite P2))}) (play (do (roll) next:(or {(if (and (is Occupied (handSite Mover)) (<= 10 (mapEntry "Throw" (count Pips)))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)) (then (and (moveAgain) (set Value Mover 0))))) (forEach Piece (then (if (and (< -1 (value Player Mover)) (> 3 (value Player Mover))) (if (> 2 (value Player Mover)) (and (moveAgain) (set Value Mover (+ 1 (value Player Mover)))) (set Value Mover (+ 1 (value Player Mover))))))) (if (no Pieces Mover) (if (is Mover P1) (forEach Piece P1) (forEach Piece P2)))}))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
Cross-shaped board, with two opposite arms bent at a right angle. Line cross each arm, creating 55 intersections where the pieces are placed. Two teams of one, two, or three people play, with each player controlling one piece. Four longitudinally split reed are used as dice, two are unmarked on the concave side which count as 1, and the other two are marked, and count as 15 and 20. The throws are as follows: All convex faces up = 10; all concave sides up = 5; one concave side up = the value of that side; two concave sides up = 2, three concave sides up =3, A player must throw 10 or more to enter the board. Once a piece is entered, the player throws three times consecutively. Each player owns one of the bent arms of the board, and the piece move anti-clockwise from the right hand end of the arm, to the exit at the left hand end of the arm, but not entering the opponent's arm. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the central spot (spot 25) are safe from being sent back. When a piece enters the player's arm again as they approach the goal, throws of 10, 15, and 20 count as 1. On the penultimate space, a throw of 2, 3, or 5 allows a piece to exit, but on the final space a throw of 1, 10, 15, or 20 is required. If playing on teams, a player who has reached the goal continues to throw and use those throws to move their teammates' pieces. The first team to remove all their pieces from the board wins. The game is played with 4 players.
(game "Petol" (players 4) (equipment {(board (remove (merge {(shift 0 7 (scale 2 1 (rectangle 3 2))) (scale 2 1 (rectangle 8 2)) (shift 0 9 (scale 2 1 (rectangle 8 2))) (shift 4.5 1 (scale 2 1 (rectangle 6 2))) (shift -4.5 10 (scale 2 1 (rectangle 6 2))) (shift 4.5 6 (graph vertices:{{0 0} {0 1} {2 3} {2 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 2 7 (graph vertices:{{0 0} {0 2} {4.5 2} {2.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 0 7 (graph vertices:{{0 0} {0 2} {-2.5 2} {-4.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift -2.5 10 (graph vertices:{{0 0} {0 -1} {-2 -3} {-2 0}} edges:{{0 1} {1 2} {2 3} {3 0}}))}) edges:{{2 3}}) {(track "Track1" "56,S,E1,S,E,N,W,S7,W1,N,End" P1 directed:True) (track "Track2" "35,N,W1,N,W,S,E,N7,E1,S,End" P2 directed:True) (track "Track3" "56,S,E1,S,E,N,W,S7,W1,N,End" P3 directed:True) (track "Track4" "35,N,W1,N,W,S,E,N7,E1,S,End" P4 directed:True)} use:Vertex) (dice d:2 facesByDie:{{0 1} {0 1} {0 15} {0 20}} num:4) (piece "Marker" Each (if (= (trackSite Move from:(from) steps:1) -2) (if (or {(= 1 (mapEntry "Throw" (count Pips))) (= 10 (mapEntry "Throw" (count Pips))) (= 15 (mapEntry "Throw" (count Pips))) (= 20 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (= (trackSite Move from:(from) steps:2) -2) (or (if (or {(= 2 (mapEntry "Throw" (count Pips))) (= 3 (mapEntry "Throw" (count Pips))) (= 5 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1))))) (if (is In (from) (sites Mover "EndTrack")) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) 1 (mapEntry "Throw" (count Pips)))) if:True)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 37 5) (pair 1 1) (pair 15 15) (pair 20 20) (pair 2 2) (pair 16 2) (pair 21 2) (pair 35 2) (pair 17 3) (pair 22 3) (pair 36 3)}) (map "Entry" {(pair P1 56) (pair P2 35) (pair P3 56) (pair P4 35)}) (regions "SafeSites" (sites {2 3})) (regions "EndTrack" P1 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P2 (sites {58 44 42 40 38 36 34})) (regions "EndTrack" P3 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P4 (sites {58 44 42 40 38 36 34}))}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place "Marker1" (handSite P1)) (place "Marker2" (handSite P2)) (place "Marker3" (handSite P3)) (place "Marker4" (handSite P4))}) (play (do (roll) next:(or {(if (and (is Occupied (handSite Mover)) (<= 10 (mapEntry "Throw" (count Pips)))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)) (then (and (moveAgain) (set Value Mover 0))))) (forEach Piece (then (if (and (< -1 (value Player Mover)) (> 3 (value Player Mover))) (if (> 2 (value Player Mover)) (and (moveAgain) (set Value Mover (+ 1 (value Player Mover)))) (set Value Mover (+ 1 (value Player Mover))))))) (if (no Pieces Mover) (if (or (is Mover P1) (is Mover P3)) (or (forEach Piece P1) (forEach Piece P3)) (or (forEach Piece P2) (forEach Piece P4))))}))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, then two on the next space and one on the space following that one. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Pieces move in a track the long way around the board toward the portion where the opponent begins. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. The opponent must then reenter this piece on the board onto an open point according to the throw of the dice, from the original starting quadrant on the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. The first player to bear off all their pieces wins.
(game "Quinze Tablas" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(pips)) -1) (if (= (topLevel at:(trackSite Move steps:(pips))) 0) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))))}) (rules (start {(place Stack "Disc1" (sites {0 1 2 3 4 5 6}) count:2) (place Stack "Disc1" 7 count:1) (place Stack "Disc2" (sites {12 13 14 15 16 17 18}) count:2) (place Stack "Disc2" 19 count:1)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Empty (handSite Mover)) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces P1) (result P1 Win)) (if (no Pieces P2) (result P2 Win))}))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, then two on the next space and one on the space following that one. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Pieces move in a track the long way around the board toward the portion where the opponent begins. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. The opponent must then reenter this piece on the board onto an open point according to the throw of the dice, from the original starting quadrant on the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. The first player to bear off all their pieces wins.
(game "Quinze Tablas" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(pips)) -1) (if (= (topLevel at:(trackSite Move steps:(pips))) 0) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))))}) (rules (start {(place Stack "Disc1" (sites {0 1 2 3 4 5 6}) count:2) (place Stack "Disc1" 7 count:1) (place Stack "Disc2" (sites {12 13 14 15 16 17 18}) count:2) (place Stack "Disc2" 19 count:1)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Empty (handSite Mover)) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces P1) (result P1 Win)) (if (no Pieces P2) (result P2 Win))}))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, then two on the next space and one on the space following that one. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Pieces move in a track the long way around the board toward the portion where the opponent begins. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. The opponent must then reenter this piece on the board onto an open point according to the throw of the dice, from the original starting quadrant on the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. The first player to bear off all their pieces wins.
(game "Quinze Tablas" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(pips)) -1) (if (= (topLevel at:(trackSite Move steps:(pips))) 0) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))))}) (rules (start {(place Stack "Disc1" (sites {0 1 2 3 4 5 6}) count:2) (place Stack "Disc1" 7 count:1) (place Stack "Disc2" (sites {12 13 14 15 16 17 18}) count:2) (place Stack "Disc2" 19 count:1)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Empty (handSite Mover)) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces P1) (result P1 Win)) (if (no Pieces P2) (result P2 Win))}))) 
Each player starts play on one of the top corners of the 3x4 grid, proceeding down that row to the opposite corner, and then up the central track, which both players use, and then turning back toward the original side of the track when reaching the top of the central track in the 2x3 grid. If a player lands on an opponent's spot, they are removed from the board and may reenter on a subsequent turn. A rosette in the center of the central track marks the spot where a player is safe from capture. Rosettes in the four corners allow a player to roll again. A player wins when they remove all seven of their pieces from the board by rolling the exact number of spaces left in the track, plus one. The pieces follow the track described by Finkel. The rosettes are protecting the pieces and allow them to replay.
(game "Royal Game of Ur" (players 2) (equipment {(board (hole (hole (rectangle 3 8) (poly {{4 0} {4 1} {6 1} {6 0}})) (poly {{4 2} {4 3} {6 3} {6 2}})) {(track "Track1" "20,3,W,N1,E,S1,W,End" P1 directed:True) (track "Track2" "21,17,W,S1,E,N1,W,End" P2 directed:True)}) (dice d:2 from:0 num:4) (hand Each) (regions "Replay" (sites {"A1" "A3" "D2" "G1" "G3"})) (piece "UrPiece" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or (is Empty (trackSite Move steps:(count Pips))) (and (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (not (is In (trackSite Move steps:(count Pips)) (sites "Replay"))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))) (then (if (is In (last To) (sites "Replay")) (moveAgain))))))))}) (rules (start {(place "UrPiece1" (handSite P1) count:7) (place "UrPiece2" (handSite P2) count:7)}) (play (do (roll) next:(if (!= (count Pips) 0) (or (forEach Piece) (forEach Piece container:(mover)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Each player starts play on one of the top corners of the 3x4 grid, proceeding down that row to the opposite corner, and then up the central track, which both players use, and then turning back toward the original side of the track when reaching the top of the central track in the 2x3 grid. If a player lands on an opponent's spot, they are removed from the board and may reenter on a subsequent turn. A rosette in the center of the central track marks the spot where a player is safe from capture. Rosettes in the four corners allow a player to roll again. A player wins when they remove all seven of their pieces from the board by rolling the exact number of spaces left in the track, plus one. The pieces follow a track describing by Murray. Nothing special happens on the rosettes.
(game "Royal Game of Ur" (players 2) (equipment {(board (hole (hole (rectangle 3 8) (poly {{4 0} {4 1} {6 1} {6 0}})) (poly {{4 2} {4 3} {6 3} {6 2}})) {(track "Track1" "20,3,W,N1,E6,S,E,N,W,S1,W,S1,E,End" P1 directed:True) (track "Track2" "21,17,W,S1,E6,N,E,S,W,N1,W,N1,E,End" P2 directed:True)}) (dice d:2 from:0 num:4) (hand Each) (regions "Replay" (sites {"A1" "A3" "D2" "G1" "G3"})) (piece "UrPiece" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place "UrPiece1" (handSite P1) count:7) (place "UrPiece2" (handSite P2) count:7)}) (play (do (roll) next:(if (!= (count Pips) 0) (or (forEach Piece) (forEach Piece container:(mover)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Each player starts play on one of the top corners of the 3x4 grid, proceeding down that row to the opposite corner, and then up the central track, which both players use, and then turning back toward the original side of the track when reaching the top of the central track in the 2x3 grid. If a player lands on an opponent's spot, they are removed from the board and may reenter on a subsequent turn. A rosette in the center of the central track marks the spot where a player is safe from capture. Rosettes in the four corners allow a player to roll again. A player wins when they remove all seven of their pieces from the board by rolling the exact number of spaces left in the track, plus one. The pieces follow a longer track than the description of Finkel. The rosettes are protecting the pieces and allow them to replay.
(game "Royal Game of Ur" (players 2) (equipment {(board (hole (hole (rectangle 3 8) (poly {{4 0} {4 1} {6 1} {6 0}})) (poly {{4 2} {4 3} {6 3} {6 2}})) {(track "Track1" "20,3,W,N1,E6,N,E,S,W,End" P1 directed:True) (track "Track2" "21,17,W,S1,E6,S,E,N,W,End" P2 directed:True)}) (dice d:2 from:0 num:4) (hand Each) (regions "Replay" (sites {"A1" "A3" "D2" "G1" "G3"})) (piece "UrPiece" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or (is Empty (trackSite Move steps:(count Pips))) (and (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (not (is In (trackSite Move steps:(count Pips)) (sites "Replay"))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))) (then (if (is In (last To) (sites "Replay")) (moveAgain))))))))}) (rules (start {(place "UrPiece1" (handSite P1) count:7) (place "UrPiece2" (handSite P2) count:7)}) (play (do (roll) next:(if (!= (count Pips) 0) (or (forEach Piece) (forEach Piece container:(mover)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's pieces begin in three stacks of five on the first point of their track. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If a player places all of their pieces on all of the points on the final six points of their side of the board, with three on each of the final three points, they win two points. Otherwise, they move into the opposite side of the board. When an opponent's piece lands on a point occupied by one of the player's pieces on the opponent's side of the board, the piece is removed from the board and must enter again. A player's pieces cannot be hit on their own side of the board. Once a player has brought all of their pieces into the final six points of the board, they may begin to bear off. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Schuster" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (and {(is Enemy (who at:(to))) (not (is In (to) (sites Mover "OppositeSide"))) (= (topLevel at:(to)) 0)}) (not (is Enemy (who at:(to))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (addScore Mover 2)))))) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (regions "OppositeSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14 13})) (regions "OppositeSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11 12})) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (no Pieces Mover) (result Mover Win))}))) 
Played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's pieces begin in three stacks of five on the first point of their track. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If a player places all of their pieces on all of the points on the final six points of their side of the board, with three on each of the final three points, they win two points. Otherwise, they move into the opposite side of the board. When an opponent's piece lands on a point occupied by one of the player's pieces on the opponent's side of the board, the piece is removed from the board and must enter again. A player's pieces cannot be hit on their own side of the board. Once a player has brought all of their pieces into the final six points of the board, they may begin to bear off. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Schuster" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (and {(is Enemy (who at:(to))) (not (is In (to) (sites Mover "OppositeSide"))) (= (topLevel at:(to)) 0)}) (not (is Enemy (who at:(to))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (addScore Mover 2)))))) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (regions "OppositeSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14 13})) (regions "OppositeSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11 12})) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (no Pieces Mover) (result Mover Win))}))) 
Played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's pieces begin in three stacks of five on the first point of their track. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If a player places all of their pieces on all of the points on the final six points of their side of the board, with three on each of the final three points, they win two points. Otherwise, they move into the opposite side of the board. When an opponent's piece lands on a point occupied by one of the player's pieces on the opponent's side of the board, the piece is removed from the board and must enter again. A player's pieces cannot be hit on their own side of the board. Once a player has brought all of their pieces into the final six points of the board, they may begin to bear off. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Schuster" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (and {(is Enemy (who at:(to))) (not (is In (to) (sites Mover "OppositeSide"))) (= (topLevel at:(to)) 0)}) (not (is Enemy (who at:(to))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (addScore Mover 2)))))) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (regions "OppositeSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14 13})) (regions "OppositeSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11 12})) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (no Pieces Mover) (result Mover Win))}))) 
Four 3x8 rectangles, arranged in a cross shape around a large central square space. Squares marked with "X" (counting from top of each row): fifth in each outer row, fourth in central row. Four players playing on two teams. Three pieces per player. Play begins in the central row of each player's arm of the board. Six cowrie shells used as dice. Values of the cowries are: 0=6, 1=10, 2=2, 3=3, 4=4, 5=25, 6=12. A roll of 10 or 25 adds an extra move of 1. This extra move must be used to enter a new piece on the board if possible, if not possible then it can be assigned to any piece. Pieces on a space marked "x" are safe from being captured. Players play until they throw a 2, 3, or 4. The value of an individual roll can only move one piece, but multiple pieces can be moved in turns with multiple rolls. Pieces enter the board with a throw of 10 or 25. Pieces enter the board from the central square onto the central row of their arm of the cross, and then anti-clockwise around the board, then back up the central row of their arm, entering the central square only with an exact throw. The first team to move all of their pieces into the central square wins.
(game "Sokkattan" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))) (regions "SafeSites" (sites {67 63 65 23 38 3 82 84 86 30 47 15})) (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)}) (map "Entry" {(pair P1 67) (pair P2 23) (pair P3 82) (pair P4 30)})}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" (handSite P1) count:3) (place Stack "Pawn2" (handSite P2) count:3) (place Stack "Pawn3" (handSite P3) count:3) (place Stack "Pawn4" (handSite P4) count:3)}) (play (do (roll) next:(if (= (var "ExtraOne") 1) (priority {(if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece (if (= (trackSite Move from:(from) steps:1) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))} (then (and (moveAgain) (set Var "ExtraOne" 0)))) (or (if (and (is Occupied (handSite Mover)) (is In (mapEntry "Throw" (count Pips)) (sites {10 25}))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece))) (then (if (not (is In (mapEntry "Throw" (count Pips)) (sites {2 3 4}))) (and (if (is In (mapEntry "Throw" (count Pips)) (sites {10 25})) (set Var "ExtraOne" 1)) (moveAgain)))))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around a large central square space. Squares marked with "X" (counting from top of each row): fifth in each outer row, fourth in central row. Four players playing on two teams. Three pieces per player. Play begins in the central row of each player's arm of the board. Six cowrie shells used as dice. Values of the cowries are: 0=6, 1=10, 2=2, 3=3, 4=4, 5=25, 6=12. A roll of 10 or 25 adds an extra move of 1. This extra move must be used to enter a new piece on the board if possible, if not possible then it can be assigned to any piece. Pieces on a space marked "x" are safe from being captured. Players play until they throw a 2, 3, or 4. The value of an individual roll can only move one piece, but multiple pieces can be moved in turns with multiple rolls. Pieces enter the board with a throw of 10 or 25. Pieces enter the board from the central square onto the central row of their arm of the cross, and then anti-clockwise around the board, then back up the central row of their arm, entering the central square only with an exact throw. The first team to move all of their pieces into the central square wins.
(game "Sokkattan" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))) (regions "SafeSites" (sites {67 63 65 23 38 3 82 84 86 30 47 15})) (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)}) (map "Entry" {(pair P1 67) (pair P2 23) (pair P3 82) (pair P4 30)})}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" (handSite P1) count:3) (place Stack "Pawn2" (handSite P2) count:3) (place Stack "Pawn3" (handSite P3) count:3) (place Stack "Pawn4" (handSite P4) count:3)}) (play (do (roll) next:(if (= (var "ExtraOne") 1) (priority {(if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece (if (= (trackSite Move from:(from) steps:1) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))} (then (and (moveAgain) (set Var "ExtraOne" 0)))) (or (if (and (is Occupied (handSite Mover)) (is In (mapEntry "Throw" (count Pips)) (sites {10 25}))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece))) (then (if (not (is In (mapEntry "Throw" (count Pips)) (sites {2 3 4}))) (and (if (is In (mapEntry "Throw" (count Pips)) (sites {10 25})) (set Var "ExtraOne" 1)) (moveAgain)))))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around a large central square space. Squares marked with "X" (counting from top of each row): fifth in each outer row, fourth in central row. Four players playing on two teams. Three pieces per player. Play begins in the central row of each player's arm of the board. Six cowrie shells used as dice. Values of the cowries are: 0=6, 1=10, 2=2, 3=3, 4=4, 5=25, 6=12. A roll of 10 or 25 adds an extra move of 1. This extra move must be used to enter a new piece on the board if possible, if not possible then it can be assigned to any piece. Pieces on a space marked "x" are safe from being captured. Players play until they throw a 2, 3, or 4. The value of an individual roll can only move one piece, but multiple pieces can be moved in turns with multiple rolls. Pieces enter the board with a throw of 10 or 25. Pieces enter the board from the central square onto the central row of their arm of the cross, and then anti-clockwise around the board, then back up the central row of their arm, entering the central square only with an exact throw. The first team to move all of their pieces into the central square wins.
(game "Sokkattan" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))) (regions "SafeSites" (sites {67 63 65 23 38 3 82 84 86 30 47 15})) (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)}) (map "Entry" {(pair P1 67) (pair P2 23) (pair P3 82) (pair P4 30)})}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" (handSite P1) count:3) (place Stack "Pawn2" (handSite P2) count:3) (place Stack "Pawn3" (handSite P3) count:3) (place Stack "Pawn4" (handSite P4) count:3)}) (play (do (roll) next:(if (= (var "ExtraOne") 1) (priority {(if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece (if (= (trackSite Move from:(from) steps:1) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))} (then (and (moveAgain) (set Var "ExtraOne" 0)))) (or (if (and (is Occupied (handSite Mover)) (is In (mapEntry "Throw" (count Pips)) (sites {10 25}))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece))) (then (if (not (is In (mapEntry "Throw" (count Pips)) (sites {2 3 4}))) (and (if (is In (mapEntry "Throw" (count Pips)) (sites {10 25})) (set Var "ExtraOne" 1)) (moveAgain)))))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Ssang-Ryouk" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23 -2} P1 directed:True) (track "Track2" {25 23 22 21 20 19 18 17 16 15 14 13 12 0 1 2 3 4 5 6 7 8 9 10 11 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= -2 (trackSite Move from:(from) steps:(pips))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {18 19 20 21 22 23})) (regions "FinalQuadrant" P2 (sites {6 7 8 9 10 11}))}) (rules (start {(place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2) (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (handSite Mover)) (forEach Die if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))}))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Ssang-Ryouk" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23 -2} P1 directed:True) (track "Track2" {25 23 22 21 20 19 18 17 16 15 14 13 12 0 1 2 3 4 5 6 7 8 9 10 11 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= -2 (trackSite Move from:(from) steps:(pips))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {18 19 20 21 22 23})) (regions "FinalQuadrant" P2 (sites {6 7 8 9 10 11}))}) (rules (start {(place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2) (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (handSite Mover)) (forEach Die if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))}))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Ssang-Ryouk" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23 -2} P1 directed:True) (track "Track2" {25 23 22 21 20 19 18 17 16 15 14 13 12 0 1 2 3 4 5 6 7 8 9 10 11 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= -2 (trackSite Move from:(from) steps:(pips))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {18 19 20 21 22 23})) (regions "FinalQuadrant" P2 (sites {6 7 8 9 10 11}))}) (rules (start {(place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2) (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (handSite Mover)) (forEach Die if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))}))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first eleven points of the board, except for those pieces in the starting position, until one of the player's pieces has first landed on the twelfth point. However, a player may place two pieces on any point after the twelfth point, regardless of whether a piece has ever landed on the twelfth point. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. To win, a player must place their pieces in one of the following winning positions: five pieces on each of the final three points; three pieces on the final five points; seven on the final point, five on the penultimate point, and three on the antepenultimate point; fifteen on the final point. If none of these positions are possible, the player must bear off all of their pieces once all of their pieces have reached the final six points. The first player to reach a winning position or to bear off all of their pieces wins.
(game "Svensk Bradspel" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and (or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (if (= (value Player Mover) 1) True (is Empty (to))))) (apply (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (= (last To) (mapEntry "12thPoint" Mover)) (!= 1 (value Player Mover))) (set Value Mover 1)))))) (regions "FinalQuadrant" P1 (sites {7 8 9 10 11 12})) (regions "FinalQuadrant" P2 (sites {13 14 15 16 17 18})) (regions "StartingSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14})) (regions "StartingSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11})) (map "12thPoint" {(pair P1 13) (pair P2 12)}) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 25 count:15) (place Stack "Disc2" 0 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (no Pieces Mover) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 5 (size Stack at:10)) (= 5 (size Stack at:11)) (= 5 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 5 (size Stack at:13)) (= 5 (size Stack at:14)) (= 5 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:8)) (is Friend (who at:9)) (is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:8)) (= 3 (size Stack at:9)) (= 3 (size Stack at:10)) (= 3 (size Stack at:11)) (= 3 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15)) (= 3 (size Stack at:17)) (= 3 (size Stack at:18))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:10)) (= 5 (size Stack at:11)) (= 7 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 7 (size Stack at:13)) (= 5 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and (is Friend (who at:12)) (= 15 (size Stack at:12))) (and (is Friend (who at:13)) (= 15 (size Stack at:13)))) (result Mover Win))}))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first eleven points of the board, except for those pieces in the starting position, until one of the player's pieces has first landed on the twelfth point. However, a player may place two pieces on any point after the twelfth point, regardless of whether a piece has ever landed on the twelfth point. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. To win, a player must place their pieces in one of the following winning positions: five pieces on each of the final three points; three pieces on the final five points; seven on the final point, five on the penultimate point, and three on the antepenultimate point; fifteen on the final point. If none of these positions are possible, the player must bear off all of their pieces once all of their pieces have reached the final six points. The first player to reach a winning position or to bear off all of their pieces wins.
(game "Svensk Bradspel" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and (or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (if (= (value Player Mover) 1) True (is Empty (to))))) (apply (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (= (last To) (mapEntry "12thPoint" Mover)) (!= 1 (value Player Mover))) (set Value Mover 1)))))) (regions "FinalQuadrant" P1 (sites {7 8 9 10 11 12})) (regions "FinalQuadrant" P2 (sites {13 14 15 16 17 18})) (regions "StartingSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14})) (regions "StartingSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11})) (map "12thPoint" {(pair P1 13) (pair P2 12)}) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 25 count:15) (place Stack "Disc2" 0 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (no Pieces Mover) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 5 (size Stack at:10)) (= 5 (size Stack at:11)) (= 5 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 5 (size Stack at:13)) (= 5 (size Stack at:14)) (= 5 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:8)) (is Friend (who at:9)) (is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:8)) (= 3 (size Stack at:9)) (= 3 (size Stack at:10)) (= 3 (size Stack at:11)) (= 3 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15)) (= 3 (size Stack at:17)) (= 3 (size Stack at:18))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:10)) (= 5 (size Stack at:11)) (= 7 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 7 (size Stack at:13)) (= 5 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and (is Friend (who at:12)) (= 15 (size Stack at:12))) (and (is Friend (who at:13)) (= 15 (size Stack at:13)))) (result Mover Win))}))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first eleven points of the board, except for those pieces in the starting position, until one of the player's pieces has first landed on the twelfth point. However, a player may place two pieces on any point after the twelfth point, regardless of whether a piece has ever landed on the twelfth point. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. To win, a player must place their pieces in one of the following winning positions: five pieces on each of the final three points; three pieces on the final five points; seven on the final point, five on the penultimate point, and three on the antepenultimate point; fifteen on the final point. If none of these positions are possible, the player must bear off all of their pieces once all of their pieces have reached the final six points. The first player to reach a winning position or to bear off all of their pieces wins.
(game "Svensk Bradspel" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and (or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (if (= (value Player Mover) 1) True (is Empty (to))))) (apply (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (= (last To) (mapEntry "12thPoint" Mover)) (!= 1 (value Player Mover))) (set Value Mover 1)))))) (regions "FinalQuadrant" P1 (sites {7 8 9 10 11 12})) (regions "FinalQuadrant" P2 (sites {13 14 15 16 17 18})) (regions "StartingSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14})) (regions "StartingSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11})) (map "12thPoint" {(pair P1 13) (pair P2 12)}) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 25 count:15) (place Stack "Disc2" 0 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (no Pieces Mover) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 5 (size Stack at:10)) (= 5 (size Stack at:11)) (= 5 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 5 (size Stack at:13)) (= 5 (size Stack at:14)) (= 5 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:8)) (is Friend (who at:9)) (is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:8)) (= 3 (size Stack at:9)) (= 3 (size Stack at:10)) (= 3 (size Stack at:11)) (= 3 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15)) (= 3 (size Stack at:17)) (= 3 (size Stack at:18))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:10)) (= 5 (size Stack at:11)) (= 7 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 7 (size Stack at:13)) (= 5 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and (is Friend (who at:12)) (= 15 (size Stack at:12))) (and (is Friend (who at:13)) (= 15 (size Stack at:13)))) (result Mover Win))}))) 
Four 3x8 rectangles, arranged in a cross shape around large central square. Four players. Four pieces per player. Two rectangular four-sided die, each marked as follows: 0, 1, 2, 4. When the throw is 0 and 1, the throw is called Tayam, when it is 0 and 4 it is called Sonal. Pieces enter the board from the central square onto the central row of their arm of the board, proceed down the central row, and then in an anti-clockwise direction around the circumference of the board, and back up the central row of their arm of the board, having to enter the central square with an exact throw. The first counter of each player must be entered with a throw of Tayam. After this, pieces may be entered with a throw of 1, 5, or Sonal, each of which enter the piece on the first square of the central row of their arm. These three throws also grant the player another throw. The throws made after entering a piece are made at once, and then the pieces moved afterward, the undivided value of each throw being used to move a piece. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. If the opponent has two pieces on such a space, they both are sent back to start, but both may reenter the board with a single throw of 1, 5, or Sonal. The first player to place all of their pieces in the central square wins.
(game "Tayam Sonalu" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:4 faces:{0 1 2 4} num:2) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(count Pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(count Pips)) if:True (apply (if (is Enemy (who at:(to))) (if (= 1 (size Stack at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (centrePoint)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))) (map "Start" {(pair P1 9) (pair P2 26) (pair P3 52) (pair P4 27)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4)}) (play (do (roll) next:(if (!= 0 (count Pips)) (or (if (and (is Occupied (handSite Mover)) (or (and (= -1 (value Player Mover)) (or (and (= 0 (face 101)) (= 1 (face 102))) (and (= 1 (face 101)) (= 0 (face 102))))) (and (= 1 (value Player Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))))) (move (from (handSite Mover)) (to (mapEntry "Start" Mover)) (then (if (= -1 (value Player Mover)) (set Value Mover 1))))) (forEach Piece))) (then (if (and (not (no Pieces Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around large central square. Four players. Four pieces per player. Two rectangular four-sided die, each marked as follows: 0, 1, 2, 4. When the throw is 0 and 1, the throw is called Tayam, when it is 0 and 4 it is called Sonal. Pieces enter the board from the central square onto the central row of their arm of the board, proceed down the central row, and then in an anti-clockwise direction around the circumference of the board, and back up the central row of their arm of the board, having to enter the central square with an exact throw. The first counter of each player must be entered with a throw of Tayam. After this, pieces may be entered with a throw of 1, 5, or Sonal, each of which enter the piece on the first square of the central row of their arm. These three throws also grant the player another throw. The throws made after entering a piece are made at once, and then the pieces moved afterward, the undivided value of each throw being used to move a piece. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. If the opponent has two pieces on such a space, they both are sent back to start, but both may reenter the board with a single throw of 1, 5, or Sonal. The first player to place all of their pieces in the central square wins.
(game "Tayam Sonalu" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:4 faces:{0 1 2 4} num:2) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(count Pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(count Pips)) if:True (apply (if (is Enemy (who at:(to))) (if (= 1 (size Stack at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (centrePoint)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))) (map "Start" {(pair P1 9) (pair P2 26) (pair P3 52) (pair P4 27)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4)}) (play (do (roll) next:(if (!= 0 (count Pips)) (or (if (and (is Occupied (handSite Mover)) (or (and (= -1 (value Player Mover)) (or (and (= 0 (face 101)) (= 1 (face 102))) (and (= 1 (face 101)) (= 0 (face 102))))) (and (= 1 (value Player Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))))) (move (from (handSite Mover)) (to (mapEntry "Start" Mover)) (then (if (= -1 (value Player Mover)) (set Value Mover 1))))) (forEach Piece))) (then (if (and (not (no Pieces Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around large central square. Four players. Four pieces per player. Two rectangular four-sided die, each marked as follows: 0, 1, 2, 4. When the throw is 0 and 1, the throw is called Tayam, when it is 0 and 4 it is called Sonal. Pieces enter the board from the central square onto the central row of their arm of the board, proceed down the central row, and then in an anti-clockwise direction around the circumference of the board, and back up the central row of their arm of the board, having to enter the central square with an exact throw. The first counter of each player must be entered with a throw of Tayam. After this, pieces may be entered with a throw of 1, 5, or Sonal, each of which enter the piece on the first square of the central row of their arm. These three throws also grant the player another throw. The throws made after entering a piece are made at once, and then the pieces moved afterward, the undivided value of each throw being used to move a piece. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. If the opponent has two pieces on such a space, they both are sent back to start, but both may reenter the board with a single throw of 1, 5, or Sonal. The first player to place all of their pieces in the central square wins.
(game "Tayam Sonalu" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:4 faces:{0 1 2 4} num:2) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(count Pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(count Pips)) if:True (apply (if (is Enemy (who at:(to))) (if (= 1 (size Stack at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (centrePoint)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))) (map "Start" {(pair P1 9) (pair P2 26) (pair P3 52) (pair P4 27)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4)}) (play (do (roll) next:(if (!= 0 (count Pips)) (or (if (and (is Occupied (handSite Mover)) (or (and (= -1 (value Player Mover)) (or (and (= 0 (face 101)) (= 1 (face 102))) (and (= 1 (face 101)) (= 0 (face 102))))) (and (= 1 (value Player Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))))) (move (from (handSite Mover)) (to (mapEntry "Start" Mover)) (then (if (= -1 (value Player Mover)) (set Value Mover 1))))) (forEach Piece))) (then (if (and (not (no Pieces Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The object of the game is to be the first player to occupy the opponent's castle with two of your own pieces, or, to capture all of your opponent's pieces while retaining two or more of your own pieces. Both knights and pawns can move either horizontally, vertically, or diagonally in three ways, as follows: One space in any direction (like a king in chess). This is called a plain move. A leaping move (called cantering) over an adjacent friendly piece to a vacant space immediately beyond. Multiple leaps over a player's own pieces are permitted. Cantering is always optional (never obligatory). A jumping move over an adjacent enemy piece to a vacant space immediately beyond. The enemy piece is captured and removed from the board. As in checkers, multiple jumps are allowed, and capturing is obligatory whenever it is possible. Pawns may make any of the three moves, but only one type of move per turn. Knights have a fourth option: a combination move consisting of a canter immediately followed by a jump (capture). This is called the knight's charge. The knight may, in this single move, perform multiple canters (or just one), followed by multiple jumps (or just one); but the canter(s) must precede the jump(s). A knight may not combine a plain move with a canter or a jump.
(game "Camelot" (players 2) (equipment {(board (keep (rectangle 12 16) (poly {{0 7} {1 10} {4 13} {12 13} {15 10} {16 7} {16 5} {15 2} {13 0} {3 0} {1 2} {0 5}}))) (piece "Pawn" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (piece "Knight" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (regions P1 (sites {"A6" "A7"})) (regions P2 (sites {"P6" "P7"}))}) (rules (start {(place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"}) (place "Knight1" {"F3" "G4" "G9" "F10"}) (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"}) (place "Knight2" {"K3" "J4" "J9" "K10"})}) (play (if (is Prev Mover) (if (is Pending) (if (= (what at:(last To)) (id "Knight" Mover)) (priority {(move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))}) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain))))) (priority {(forEach Site (sites Mover) (if (= (who at:(site)) (mover)) (priority {(move Hop (from (site)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (site)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))}))) (forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (moveAgain))))) (forEach Piece)}))) (end {(if (= (sites P2) (sites Occupied by:P1)) (result P1 Win)) (if (= (sites P1) (sites Occupied by:P2)) (result P2 Win)) (if (and (>= (count Pieces Mover) 2) (= (count Pieces Next) 0)) (result Mover Win)) (if (and (< (count Pieces Mover) 2) (< (count Pieces Next) 2)) (result Mover Draw))}))) 
The object of the game is to be the first player to occupy the opponent's castle with two of your own pieces, or, to capture all of your opponent's pieces while retaining two or more of your own pieces. Both knights and pawns can move either horizontally, vertically, or diagonally in three ways, as follows: One space in any direction (like a king in chess). This is called a plain move. A leaping move (called cantering) over an adjacent friendly piece to a vacant space immediately beyond. Multiple leaps over a player's own pieces are permitted. Cantering is always optional (never obligatory). A jumping move over an adjacent enemy piece to a vacant space immediately beyond. The enemy piece is captured and removed from the board. As in checkers, multiple jumps are allowed, and capturing is obligatory whenever it is possible. Pawns may make any of the three moves, but only one type of move per turn. Knights have a fourth option: a combination move consisting of a canter immediately followed by a jump (capture). This is called the knight's charge. The knight may, in this single move, perform multiple canters (or just one), followed by multiple jumps (or just one); but the canter(s) must precede the jump(s). A knight may not combine a plain move with a canter or a jump.
(game "Camelot" (players 2) (equipment {(board (keep (rectangle 12 16) (poly {{0 7} {1 10} {4 13} {12 13} {15 10} {16 7} {16 5} {15 2} {13 0} {3 0} {1 2} {0 5}}))) (piece "Pawn" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (piece "Knight" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (regions P1 (sites {"A6" "A7"})) (regions P2 (sites {"P6" "P7"}))}) (rules (start {(place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"}) (place "Knight1" {"F3" "G4" "G9" "F10"}) (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"}) (place "Knight2" {"K3" "J4" "J9" "K10"})}) (play (if (is Prev Mover) (if (is Pending) (if (= (what at:(last To)) (id "Knight" Mover)) (priority {(move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))}) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain))))) (priority {(forEach Site (sites Mover) (if (= (who at:(site)) (mover)) (priority {(move Hop (from (site)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (site)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))}))) (forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (moveAgain))))) (forEach Piece)}))) (end {(if (= (sites P2) (sites Occupied by:P1)) (result P1 Win)) (if (= (sites P1) (sites Occupied by:P2)) (result P2 Win)) (if (and (>= (count Pieces Mover) 2) (= (count Pieces Next) 0)) (result Mover Win)) (if (and (< (count Pieces Mover) 2) (< (count Pieces Next) 2)) (result Mover Draw))}))) 
The object of the game is to be the first player to occupy the opponent's castle with two of your own pieces, or, to capture all of your opponent's pieces while retaining two or more of your own pieces. Both knights and pawns can move either horizontally, vertically, or diagonally in three ways, as follows: One space in any direction (like a king in chess). This is called a plain move. A leaping move (called cantering) over an adjacent friendly piece to a vacant space immediately beyond. Multiple leaps over a player's own pieces are permitted. Cantering is always optional (never obligatory). A jumping move over an adjacent enemy piece to a vacant space immediately beyond. The enemy piece is captured and removed from the board. As in checkers, multiple jumps are allowed, and capturing is obligatory whenever it is possible. Pawns may make any of the three moves, but only one type of move per turn. Knights have a fourth option: a combination move consisting of a canter immediately followed by a jump (capture). This is called the knight's charge. The knight may, in this single move, perform multiple canters (or just one), followed by multiple jumps (or just one); but the canter(s) must precede the jump(s). A knight may not combine a plain move with a canter or a jump.
(game "Camelot" (players 2) (equipment {(board (keep (rectangle 12 16) (poly {{0 7} {1 10} {4 13} {12 13} {15 10} {16 7} {16 5} {15 2} {13 0} {3 0} {1 2} {0 5}}))) (piece "Pawn" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (piece "Knight" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (regions P1 (sites {"A6" "A7"})) (regions P2 (sites {"P6" "P7"}))}) (rules (start {(place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"}) (place "Knight1" {"F3" "G4" "G9" "F10"}) (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"}) (place "Knight2" {"K3" "J4" "J9" "K10"})}) (play (if (is Prev Mover) (if (is Pending) (if (= (what at:(last To)) (id "Knight" Mover)) (priority {(move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))}) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain))))) (priority {(forEach Site (sites Mover) (if (= (who at:(site)) (mover)) (priority {(move Hop (from (site)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (site)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))}))) (forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (moveAgain))))) (forEach Piece)}))) (end {(if (= (sites P2) (sites Occupied by:P1)) (result P1 Win)) (if (= (sites P1) (sites Occupied by:P2)) (result P2 Win)) (if (and (>= (count Pieces Mover) 2) (= (count Pieces Next) 0)) (result Mover Win)) (if (and (< (count Pieces Mover) 2) (< (count Pieces Next) 2)) (result Mover Draw))}))) 
The game can be played by two, three, four, or six people. It is played on a board that is shaped like a six-pointed star with 121 holes for the pieces. Each point of the star has ten colored spheres and the goal of the game is to move all of one's pieces into the opposite point of the star. Players can move a piece to one adjacent hole, or can jump either their own or opponent's pieces. This does not result in capturing, and jumping is not mandatory. When fewer than six people play, players can play with only one color of pieces, but if two or three people play they can use more than one color, but each player must use an equal number of pieces. Six players occupy home regions (standard game). The game is played on a board of size 4.
(game "Chinese Checkers" (players 6) (equipment {(board (hex Star 4)) (piece "Marker" Each) (regions "Home" P1 (expand origin:(coord row:0 column:4) steps:(- 4 1))) (regions "Home" P2 (expand origin:(coord row:4 column:(* 4 3)) steps:(- 4 1))) (regions "Home" P3 (expand origin:(coord row:(* 4 3) column:(* 4 4)) steps:(- 4 1))) (regions "Home" P4 (expand origin:(coord row:(* 4 4) column:(* 4 3)) steps:(- 4 1))) (regions "Home" P5 (expand origin:(coord row:(* 4 3) column:4) steps:(- 4 1))) (regions "Home" P6 (expand origin:(coord row:4 column:0) steps:(- 4 1))) (map {(pair 1 4) (pair 2 5) (pair 3 6) (pair 4 1) (pair 5 2) (pair 6 3)})}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2)) (place "Marker3" (sites P3)) (place "Marker4" (sites P4)) (place "Marker5" (sites P5)) (place "Marker6" (sites P6))}) phases:{(phase "Movement" (play (forEach Piece (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Step (to if:(and (is Empty (to)) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))))) (nextPhase (is Mover (next)) "MultiJump")) (phase "MultiJump" (play (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Pass))) (nextPhase (not (is Mover (next))) "Movement"))} (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
The game can be played by two, three, four, or six people. It is played on a board that is shaped like a six-pointed star with 121 holes for the pieces. Each point of the star has ten colored spheres and the goal of the game is to move all of one's pieces into the opposite point of the star. Players can move a piece to one adjacent hole, or can jump either their own or opponent's pieces. This does not result in capturing, and jumping is not mandatory. When fewer than six people play, players can play with only one color of pieces, but if two or three people play they can use more than one color, but each player must use an equal number of pieces. Two players occupy home regions on opposite sides, four home regions are empty. The game is played on a board of size 1.
(game "Chinese Checkers" (players 2) (equipment {(board (hex Star 1)) (piece "Marker" Each) (regions "Home" P1 (expand origin:(coord row:0 column:1) steps:(- 1 1))) (regions "Home" P2 (expand origin:(coord row:(* 1 4) column:(* 1 3)) steps:(- 1 1))) (map {(pair 1 2) (pair 2 1)})}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) phases:{(phase "Movement" (play (forEach Piece (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Step (to if:(and (is Empty (to)) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))))) (nextPhase (is Mover (next)) "MultiJump")) (phase "MultiJump" (play (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Pass))) (nextPhase (not (is Mover (next))) "Movement"))} (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
The game can be played by two, three, four, or six people. It is played on a board that is shaped like a six-pointed star with 121 holes for the pieces. Each point of the star has ten colored spheres and the goal of the game is to move all of one's pieces into the opposite point of the star. Players can move a piece to one adjacent hole, or can jump either their own or opponent's pieces. This does not result in capturing, and jumping is not mandatory. When fewer than six people play, players can play with only one color of pieces, but if two or three people play they can use more than one color, but each player must use an equal number of pieces. Two players occupy three regions each, alternating around board, i.e. all six home regions start full. The game is played on a board of size 2.
(game "Chinese Checkers" (players 2) (equipment {(board (hex Star 2)) (piece "Marker" Each) (regions "Home" P1 (union {(expand origin:(coord row:0 column:2) steps:(- 2 1)) (expand origin:(coord row:(* 2 3) column:(* 2 4)) steps:(- 2 1)) (expand origin:(coord row:(* 2 3) column:2) steps:(- 2 1))})) (regions "Home" P2 (union {(expand origin:(coord row:2 column:(* 2 3)) steps:(- 2 1)) (expand origin:(coord row:(* 2 4) column:(* 2 3)) steps:(- 2 1)) (expand origin:(coord row:2 column:0) steps:(- 2 1))})) (map {(pair 1 2) (pair 2 1)})}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) phases:{(phase "Movement" (play (forEach Piece (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Step (to if:(and (is Empty (to)) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))))) (nextPhase (is Mover (next)) "MultiJump")) (phase "MultiJump" (play (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Pass))) (nextPhase (not (is Mover (next))) "Movement"))} (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
3x12-28 board. Players begin with soldiers, equal in number to the number of spaces in one row for each player, which begin in the spaces in the row closes to the player. Each player has one king piece, which begins in the rightmost space in the central row with respect to the player. Four six-sided dice with values from 1-6. A throw of 1 is called Chong. Pieces move in a boustrophedon path along the board, from left to right in their home row, right to left in the center row, and then left to right in their opponent's row. A player must first throw a Chong to play. On this turn, when a player throws one Chong, the King exchanges places with the soldier behind it. If more than one Chong is thrown, the King exchanges places with the soldier that many spaces behind it. Any remaining values in the throw are moved by the soldier which took the king's space. Once this move has taken place, pieces move according to the throws of the dice, which can be subdivided between the pieces as the player sees fit. The King only moves with a Chong, and it exchanges the place of a piece that number of occupied squares away, i.e., only spaces occupied by the player's pieces are counted when moving the King. When the player has only one soldier and the King, the King may move normally (like a soldier does), but on throws of Chong. When only the King is left, the first Chong in a throw is ignored and only the second, third, or fourth Chongs are moved. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. An opponent's King cannot be taken by a soldier until it has first moved backwards, and then it can only be taken by a Chong. The game continues after the players' Kings have been taken. When a player reaches the end of the opponent's home line, the player wins. The game is played on a 3x12 board.
(game "Chong (Sakhalin)" (players 2) (equipment {(board (rectangle 3 12) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "35,W,S1,E,S1,W" P2 directed:True)}) (dice d:6 num:4) (piece "Marker" Each (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "King" Each (if (= 1 (pips)) (if (<= 2 (count Pieces Mover)) (if (and (!= 1 (value Player Mover)) (= 1 (count Pieces Mover))) (move (from (from)) (to (from)) (then (set Value Mover 1))) (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (firstMoveOnTrack "Track" Mover (if (and (> (site) (from)) (is Mover (who at:(site)))) (move Swap Pieces (from) (site)))))))}) (rules (start {(place "Marker1" (difference (sites Bottom) (sites Right))) (place "King1" (intersection (sites Bottom) (sites Right))) (place "Marker2" (difference (sites Top) (sites Left))) (place "King2" (intersection (sites Top) (sites Left)))}) phases:{(phase "Opening" (play (do (roll) next:(if (!= 0 (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})) (if (is Mover P1) (if (is Mover (who at:(- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (if (is Mover (who at:(+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (then (fromTo (from (last From)) (to (trackSite Move from:(last From) steps:(- (count Pips) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)}))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (nextPhase Mover (not (was Pass)) "Playing")) (phase "Playing" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Piece) (then (if (not (all DiceUsed)) (moveAgain)))))))} (end {(if (= (who at:0) P2) (result P2 Win)) (if (= (who at:(- (count Sites in:(sites Board)) 1)) P1) (result P1 Win))}))) 
3x12-28 board. Players begin with soldiers, equal in number to the number of spaces in one row for each player, which begin in the spaces in the row closes to the player. Each player has one king piece, which begins in the rightmost space in the central row with respect to the player. Four six-sided dice with values from 1-6. A throw of 1 is called Chong. Pieces move in a boustrophedon path along the board, from left to right in their home row, right to left in the center row, and then left to right in their opponent's row. A player must first throw a Chong to play. On this turn, when a player throws one Chong, the King exchanges places with the soldier behind it. If more than one Chong is thrown, the King exchanges places with the soldier that many spaces behind it. Any remaining values in the throw are moved by the soldier which took the king's space. Once this move has taken place, pieces move according to the throws of the dice, which can be subdivided between the pieces as the player sees fit. The King only moves with a Chong, and it exchanges the place of a piece that number of occupied squares away, i.e., only spaces occupied by the player's pieces are counted when moving the King. When the player has only one soldier and the King, the King may move normally (like a soldier does), but on throws of Chong. When only the King is left, the first Chong in a throw is ignored and only the second, third, or fourth Chongs are moved. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. An opponent's King cannot be taken by a soldier until it has first moved backwards, and then it can only be taken by a Chong. The game continues after the players' Kings have been taken. When a player reaches the end of the opponent's home line, the player wins. The game is played on a 3x13 board.
(game "Chong (Sakhalin)" (players 2) (equipment {(board (rectangle 3 13) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "38,W,S1,E,S1,W" P2 directed:True)}) (dice d:6 num:4) (piece "Marker" Each (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "King" Each (if (= 1 (pips)) (if (<= 2 (count Pieces Mover)) (if (and (!= 1 (value Player Mover)) (= 1 (count Pieces Mover))) (move (from (from)) (to (from)) (then (set Value Mover 1))) (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (firstMoveOnTrack "Track" Mover (if (and (> (site) (from)) (is Mover (who at:(site)))) (move Swap Pieces (from) (site)))))))}) (rules (start {(place "Marker1" (difference (sites Bottom) (sites Right))) (place "King1" (intersection (sites Bottom) (sites Right))) (place "Marker2" (difference (sites Top) (sites Left))) (place "King2" (intersection (sites Top) (sites Left)))}) phases:{(phase "Opening" (play (do (roll) next:(if (!= 0 (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})) (if (is Mover P1) (if (is Mover (who at:(- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (if (is Mover (who at:(+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (then (fromTo (from (last From)) (to (trackSite Move from:(last From) steps:(- (count Pips) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)}))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (nextPhase Mover (not (was Pass)) "Playing")) (phase "Playing" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Piece) (then (if (not (all DiceUsed)) (moveAgain)))))))} (end {(if (= (who at:0) P2) (result P2 Win)) (if (= (who at:(- (count Sites in:(sites Board)) 1)) P1) (result P1 Win))}))) 
3x12-28 board. Players begin with soldiers, equal in number to the number of spaces in one row for each player, which begin in the spaces in the row closes to the player. Each player has one king piece, which begins in the rightmost space in the central row with respect to the player. Four six-sided dice with values from 1-6. A throw of 1 is called Chong. Pieces move in a boustrophedon path along the board, from left to right in their home row, right to left in the center row, and then left to right in their opponent's row. A player must first throw a Chong to play. On this turn, when a player throws one Chong, the King exchanges places with the soldier behind it. If more than one Chong is thrown, the King exchanges places with the soldier that many spaces behind it. Any remaining values in the throw are moved by the soldier which took the king's space. Once this move has taken place, pieces move according to the throws of the dice, which can be subdivided between the pieces as the player sees fit. The King only moves with a Chong, and it exchanges the place of a piece that number of occupied squares away, i.e., only spaces occupied by the player's pieces are counted when moving the King. When the player has only one soldier and the King, the King may move normally (like a soldier does), but on throws of Chong. When only the King is left, the first Chong in a throw is ignored and only the second, third, or fourth Chongs are moved. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. An opponent's King cannot be taken by a soldier until it has first moved backwards, and then it can only be taken by a Chong. The game continues after the players' Kings have been taken. When a player reaches the end of the opponent's home line, the player wins. The game is played on a 3x14 board.
(game "Chong (Sakhalin)" (players 2) (equipment {(board (rectangle 3 14) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "41,W,S1,E,S1,W" P2 directed:True)}) (dice d:6 num:4) (piece "Marker" Each (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "King" Each (if (= 1 (pips)) (if (<= 2 (count Pieces Mover)) (if (and (!= 1 (value Player Mover)) (= 1 (count Pieces Mover))) (move (from (from)) (to (from)) (then (set Value Mover 1))) (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (firstMoveOnTrack "Track" Mover (if (and (> (site) (from)) (is Mover (who at:(site)))) (move Swap Pieces (from) (site)))))))}) (rules (start {(place "Marker1" (difference (sites Bottom) (sites Right))) (place "King1" (intersection (sites Bottom) (sites Right))) (place "Marker2" (difference (sites Top) (sites Left))) (place "King2" (intersection (sites Top) (sites Left)))}) phases:{(phase "Opening" (play (do (roll) next:(if (!= 0 (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})) (if (is Mover P1) (if (is Mover (who at:(- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (if (is Mover (who at:(+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (then (fromTo (from (last From)) (to (trackSite Move from:(last From) steps:(- (count Pips) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)}))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (nextPhase Mover (not (was Pass)) "Playing")) (phase "Playing" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Piece) (then (if (not (all DiceUsed)) (moveAgain)))))))} (end {(if (= (who at:0) P2) (result P2 Win)) (if (= (who at:(- (count Sites in:(sites Board)) 1)) P1) (result P1 Win))}))) 
The board is drawn in the sand, with any large number of holes in a spiral pattern. The starting point is before the first hole in the outer ring of the spiral, and is made as a mound of sand; the goal is another mound of sand at the center of the spiral. Each player has one piece, which they place on the starting mound. Another piece, the hyena, also begins on the starting mound. Four throwing sticks, with a black side and a white side, used as dice. The values of the throws are as follows: four white sides = 20; three white sides = 5; two white sides = 0; one white sides = 9; all black sides = 80. Players throw, move, and throw again until they throw a 0. When a player reaches the goal, they then play as the hyena on their turn. When the hyena catches up to another player's piece, it drags the piece with it, until throwing a 0. When a 0 is thrown, the player moves back to the place where they were before the hyena dragged them, and must overtake the hyena in this turn. If the player cannot, they are removed from the game. If the player is overtaken by the hyena a second time, they are removed from the game. The game has 4 players.
(game "Ishighan" (players 4) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 20) (pair 1 5) (pair 2 0) (pair 3 9) (pair 4 80)}) (piece "Stick" Each (if (= (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to 0) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2))))))) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2)))))))) maxState:85) (piece "Hyena" Neutral) (hand P1)}) (rules (start {(place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} (handSite P1)) (place Stack "Hyena0" (handSite P1))}) (play (do (roll) next:(if (= 0 (where "Stick" Mover)) (if (!= (mapEntry "Throw" (count Pips)) 0) (move (from (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) level:(where Level "Hyena" Neutral at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (if (= (last To) 0) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To) (apply (if (and (= 0 (state at:(site) level:(level))) (!= 0 (who at:(site) level:(level)))) (if (<= (site) (- (count Vertices) 1)) (set State at:(site) level:(level) (site))))))))))))) (move Pass (then (forEach Site (sites Board) (forEach Level (site) FromTop (if (!= 0 (state at:(site) level:(level))) (if (< 0 (value Player (who at:(site) level:(level)))) (remove (site) level:(level)) (fromTo (from (site) level:(level)) (to (state at:(site) level:(level)) (apply (and (set State at:(site) level:(level) 0) (set Value (player (who at:(site) level:(level))) 1)))))))))))) (if (!= (mapEntry "Throw" (count Pips)) 0) (or (forEach Piece) (forEach Piece container:1)) (move Pass (then (if (= 1 (value Player Mover)) (remove (where "Stick" Mover) level:(where Level "Stick" Neutral at:(where "Stick" Mover)))))))) (then (if (!= (mapEntry "Throw" (count Pips)) 0) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(or (= (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) 0) (and {(is Occupied 0) (>= 1 (count Sites in:(difference (sites Occupied by:All) (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))) (= 1 (size Stack at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))})) (result Player Win))}))) 
The board is drawn in the sand, with any large number of holes in a spiral pattern. The starting point is before the first hole in the outer ring of the spiral, and is made as a mound of sand; the goal is another mound of sand at the center of the spiral. Each player has one piece, which they place on the starting mound. Another piece, the hyena, also begins on the starting mound. Four throwing sticks, with a black side and a white side, used as dice. The values of the throws are as follows: four white sides = 20; three white sides = 5; two white sides = 0; one white sides = 9; all black sides = 80. Players throw, move, and throw again until they throw a 0. When a player reaches the goal, they then play as the hyena on their turn. When the hyena catches up to another player's piece, it drags the piece with it, until throwing a 0. When a 0 is thrown, the player moves back to the place where they were before the hyena dragged them, and must overtake the hyena in this turn. If the player cannot, they are removed from the game. If the player is overtaken by the hyena a second time, they are removed from the game. The game has 2 players.
(game "Ishighan" (players 2) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 20) (pair 1 5) (pair 2 0) (pair 3 9) (pair 4 80)}) (piece "Stick" Each (if (= (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to 0) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2))))))) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2)))))))) maxState:85) (piece "Hyena" Neutral) (hand P1)}) (rules (start {(place Stack items:{"Stick2" "Stick1"} (handSite P1)) (place Stack "Hyena0" (handSite P1))}) (play (do (roll) next:(if (= 0 (where "Stick" Mover)) (if (!= (mapEntry "Throw" (count Pips)) 0) (move (from (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) level:(where Level "Hyena" Neutral at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (if (= (last To) 0) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To) (apply (if (and (= 0 (state at:(site) level:(level))) (!= 0 (who at:(site) level:(level)))) (if (<= (site) (- (count Vertices) 1)) (set State at:(site) level:(level) (site))))))))))))) (move Pass (then (forEach Site (sites Board) (forEach Level (site) FromTop (if (!= 0 (state at:(site) level:(level))) (if (< 0 (value Player (who at:(site) level:(level)))) (remove (site) level:(level)) (fromTo (from (site) level:(level)) (to (state at:(site) level:(level)) (apply (and (set State at:(site) level:(level) 0) (set Value (player (who at:(site) level:(level))) 1)))))))))))) (if (!= (mapEntry "Throw" (count Pips)) 0) (or (forEach Piece) (forEach Piece container:1)) (move Pass (then (if (= 1 (value Player Mover)) (remove (where "Stick" Mover) level:(where Level "Stick" Neutral at:(where "Stick" Mover)))))))) (then (if (!= (mapEntry "Throw" (count Pips)) 0) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(or (= (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) 0) (and {(is Occupied 0) (>= 1 (count Sites in:(difference (sites Occupied by:All) (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))) (= 1 (size Stack at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))})) (result Player Win))}))) 
The board is drawn in the sand, with any large number of holes in a spiral pattern. The starting point is before the first hole in the outer ring of the spiral, and is made as a mound of sand; the goal is another mound of sand at the center of the spiral. Each player has one piece, which they place on the starting mound. Another piece, the hyena, also begins on the starting mound. Four throwing sticks, with a black side and a white side, used as dice. The values of the throws are as follows: four white sides = 20; three white sides = 5; two white sides = 0; one white sides = 9; all black sides = 80. Players throw, move, and throw again until they throw a 0. When a player reaches the goal, they then play as the hyena on their turn. When the hyena catches up to another player's piece, it drags the piece with it, until throwing a 0. When a 0 is thrown, the player moves back to the place where they were before the hyena dragged them, and must overtake the hyena in this turn. If the player cannot, they are removed from the game. If the player is overtaken by the hyena a second time, they are removed from the game. The game has 3 players.
(game "Ishighan" (players 3) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 20) (pair 1 5) (pair 2 0) (pair 3 9) (pair 4 80)}) (piece "Stick" Each (if (= (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to 0) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2))))))) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2)))))))) maxState:85) (piece "Hyena" Neutral) (hand P1)}) (rules (start {(place Stack items:{"Stick3" "Stick2" "Stick1"} (handSite P1)) (place Stack "Hyena0" (handSite P1))}) (play (do (roll) next:(if (= 0 (where "Stick" Mover)) (if (!= (mapEntry "Throw" (count Pips)) 0) (move (from (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) level:(where Level "Hyena" Neutral at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (if (= (last To) 0) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To) (apply (if (and (= 0 (state at:(site) level:(level))) (!= 0 (who at:(site) level:(level)))) (if (<= (site) (- (count Vertices) 1)) (set State at:(site) level:(level) (site))))))))))))) (move Pass (then (forEach Site (sites Board) (forEach Level (site) FromTop (if (!= 0 (state at:(site) level:(level))) (if (< 0 (value Player (who at:(site) level:(level)))) (remove (site) level:(level)) (fromTo (from (site) level:(level)) (to (state at:(site) level:(level)) (apply (and (set State at:(site) level:(level) 0) (set Value (player (who at:(site) level:(level))) 1)))))))))))) (if (!= (mapEntry "Throw" (count Pips)) 0) (or (forEach Piece) (forEach Piece container:1)) (move Pass (then (if (= 1 (value Player Mover)) (remove (where "Stick" Mover) level:(where Level "Stick" Neutral at:(where "Stick" Mover)))))))) (then (if (!= (mapEntry "Throw" (count Pips)) 0) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(or (= (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) 0) (and {(is Occupied 0) (>= 1 (count Sites in:(difference (sites Occupied by:All) (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))) (= 1 (size Stack at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))})) (result Player Win))}))) 
Forty stones, arranged in a circle, with larger gaps (doors) between the stones after every ten. The gaps between the stones are the playing spaces. Any number of players. One stick per player. Three sticks used as dice, one marked with two notches, one marked with three notches, the other marked with ten notches. The value of the throw is the number of notches which land face up. Players move their sticks around the board, beginning at one of the doors. Players may choose in which direction to proceed around the board. When a player lands on the same space as an opponent, the opponent's piece is sent back to the starting door. The first player to complete the circuit of the board wins. The game has 2 players.
(game "Kawasukuts" (players 2) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "Gates" (sites {36 37 38 39})) (piece "Marker" Each (if (= (value Player Mover) -1) (or (if (!= (trackSite Move "TrackCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 1)))) (if (!= (trackSite Move "TrackCCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 2))))) (if (!= (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) -1) (if (or (is In (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (sites Empty)) (is Enemy (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips)))))) (move (from (from) level:(level)) (to (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to))))))))))) (dice d:2 facesByDie:{{0 2} {0 3} {0 10}} num:3) (hand Each)}) (rules (start (place "Marker" "Hand")) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites "Gates")) (then (set Value at:(last To) (last To))))) (nextPhase Mover "Playing")) (phase "Playing" (play (do (roll) next:(forEach Piece))) (end (if (and (!= 0 (count Pips)) (if (= 1 (value Player Mover)) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To))) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))))) (result Mover Win))))})) 
Forty stones, arranged in a circle, with larger gaps (doors) between the stones after every ten. The gaps between the stones are the playing spaces. Any number of players. One stick per player. Three sticks used as dice, one marked with two notches, one marked with three notches, the other marked with ten notches. The value of the throw is the number of notches which land face up. Players move their sticks around the board, beginning at one of the doors. Players may choose in which direction to proceed around the board. When a player lands on the same space as an opponent, the opponent's piece is sent back to the starting door. The first player to complete the circuit of the board wins. The game has 3 players.
(game "Kawasukuts" (players 3) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "Gates" (sites {36 37 38 39})) (piece "Marker" Each (if (= (value Player Mover) -1) (or (if (!= (trackSite Move "TrackCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 1)))) (if (!= (trackSite Move "TrackCCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 2))))) (if (!= (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) -1) (if (or (is In (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (sites Empty)) (is Enemy (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips)))))) (move (from (from) level:(level)) (to (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to))))))))))) (dice d:2 facesByDie:{{0 2} {0 3} {0 10}} num:3) (hand Each)}) (rules (start (place "Marker" "Hand")) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites "Gates")) (then (set Value at:(last To) (last To))))) (nextPhase Mover "Playing")) (phase "Playing" (play (do (roll) next:(forEach Piece))) (end (if (and (!= 0 (count Pips)) (if (= 1 (value Player Mover)) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To))) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))))) (result Mover Win))))})) 
Forty stones, arranged in a circle, with larger gaps (doors) between the stones after every ten. The gaps between the stones are the playing spaces. Any number of players. One stick per player. Three sticks used as dice, one marked with two notches, one marked with three notches, the other marked with ten notches. The value of the throw is the number of notches which land face up. Players move their sticks around the board, beginning at one of the doors. Players may choose in which direction to proceed around the board. When a player lands on the same space as an opponent, the opponent's piece is sent back to the starting door. The first player to complete the circuit of the board wins. The game has 4 players.
(game "Kawasukuts" (players 4) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "Gates" (sites {36 37 38 39})) (piece "Marker" Each (if (= (value Player Mover) -1) (or (if (!= (trackSite Move "TrackCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 1)))) (if (!= (trackSite Move "TrackCCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 2))))) (if (!= (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) -1) (if (or (is In (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (sites Empty)) (is Enemy (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips)))))) (move (from (from) level:(level)) (to (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to))))))))))) (dice d:2 facesByDie:{{0 2} {0 3} {0 10}} num:3) (hand Each)}) (rules (start (place "Marker" "Hand")) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites "Gates")) (then (set Value at:(last To) (last To))))) (nextPhase Mover "Playing")) (phase "Playing" (play (do (roll) next:(forEach Piece))) (end (if (and (!= 0 (count Pips)) (if (= 1 (value Player Mover)) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To))) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))))) (result Mover Win))))})) 
Pieces move as knights in Chess. The goal is to be the first player to reach the opposite side of the board from the starting position.
(game "Knightthrough" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} forward:True (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Knight1" (expand (sites Bottom))) (place "Knight2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (is In (last To) (sites Mover)) (result Mover Win))))) 
Pieces move as knights in Chess. The goal is to be the first player to reach the opposite side of the board from the starting position.
(game "Knightthrough" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} forward:True (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Knight1" (expand (sites Bottom))) (place "Knight2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (is In (last To) (sites Mover)) (result Mover Win))))) 
Pieces move as knights in Chess. The goal is to be the first player to reach the opposite side of the board from the starting position.
(game "Knightthrough" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} forward:True (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Knight1" (expand (sites Bottom))) (place "Knight2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (is In (last To) (sites Mover)) (result Mover Win))))) 
On a player's turn he or she must perform one of the following actions: 1) Move a tower (2-stack) by distributing its two stones into the two nearest cells in any one direction. Each destination cell must be empty or contain a single friendly stone. 2) Sacrifice a single tower stone to remove an adjacent enemy wall (1-stack). Sacrifice is not forced. Goal: A player wins immediately by reaching any cell of his or her opponent's home row, or by stalemating his or her opponent. Stack limit is 2. Standard 7 x 8, one row Immediately after reaching goal.
(game "Murus Gallicus" (players {(player N) (player S)}) (equipment {(board (rectangle 7 8)) (piece "Counter_isometric" Each) (regions "RomanGoal1" P1 (sites Top)) (regions "GaulGoal2" P2 (sites Bottom))}) (rules (start {(place Stack "Counter_isometric1" (sites {0 1 2 3 4 5 6 7}) count:2) (place Stack "Counter_isometric2" (sites {48 49 50 51 52 53 54 55}) count:2)}) (play (if (is Prev Mover) (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece "Counter_isometric" (or {(move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 2))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 2)))) stack:True) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= 1 (size Stack at:(to)))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To))))) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and {(fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)}))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(and (not (is Enemy (who at:(to)))) (not (is Mover (who at:(to))))))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(is Enemy (who at:(to)))) (then (and (remove (last To)) (remove (last To)))))}) top:True))) (end {(if (no Moves Next) (result Mover Win)) (if (and {(is In (last To) (sites Mover)) (not (is Enemy (who at:(last To)))) (is Mover (who at:(last To)))}) (result Mover Win))}))) 
On a player's turn he or she must perform one of the following actions: 1) Move a tower (2-stack) by distributing its two stones into the two nearest cells in any one direction. Each destination cell must be empty or contain a single friendly stone. 2) Sacrifice a single tower stone to remove an adjacent enemy wall (1-stack). Sacrifice is not forced. Goal: A player wins immediately by reaching any cell of his or her opponent's home row, or by stalemating his or her opponent. Stack limit is 3. Square 8 x 8, one row After opponent's last chance to remove invader.
(game "Murus Gallicus" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter_isometric" Each) (regions "RomanGoal1" P1 (sites Top)) (regions "GaulGoal2" P2 (sites Bottom))}) (rules (start {(place Stack "Counter_isometric1" (sites {0 1 2 3 4 5 6 7}) count:2) (place Stack "Counter_isometric2" (sites {56 57 58 59 60 61 62 63}) count:2)}) (play (if (is Prev Mover) (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece "Counter_isometric" (or {(move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 3))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 3)))) stack:True) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= 1 (size Stack at:(to)))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To))))) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and {(fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)}))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(and (not (is Enemy (who at:(to)))) (not (is Mover (who at:(to))))))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(is Enemy (who at:(to)))) (then (and (remove (last To)) (remove (last To)))))}) top:True))) (end {(if (no Moves Next) (result Mover Win)) (if (= 1 (count Sites in:(intersection (sites Occupied by:Next) (sites Next)))) (result Next Win))}))) 
On a player's turn he or she must perform one of the following actions: 1) Move a tower (2-stack) by distributing its two stones into the two nearest cells in any one direction. Each destination cell must be empty or contain a single friendly stone. 2) Sacrifice a single tower stone to remove an adjacent enemy wall (1-stack). Sacrifice is not forced. Goal: A player wins immediately by reaching any cell of his or her opponent's home row, or by stalemating his or her opponent. Stack limit is 2. Square 8 x 8, two rows Immediately after reaching goal.
(game "Murus Gallicus" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter_isometric" Each) (regions "RomanGoal1" P1 (sites Top)) (regions "GaulGoal2" P2 (sites Bottom))}) (rules (start {(place Stack "Counter_isometric1" (sites {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15}) count:2) (place Stack "Counter_isometric2" (sites {48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63}) count:2)}) (play (if (is Prev Mover) (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece "Counter_isometric" (or {(move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 2))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 2)))) stack:True) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= 1 (size Stack at:(to)))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To))))) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and {(fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)}))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(and (not (is Enemy (who at:(to)))) (not (is Mover (who at:(to))))))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(is Enemy (who at:(to)))) (then (and (remove (last To)) (remove (last To)))))}) top:True))) (end {(if (no Moves Next) (result Mover Win)) (if (and {(is In (last To) (sites Mover)) (not (is Enemy (who at:(last To)))) (is Mover (who at:(last To)))}) (result Mover Win))}))) 
86 spaces in a spiral track. Any number of players, each having one piece, which starts on the first space in the outer ring of the spiral. A lump of charcoal, the Ghoula, also is placed on this space. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as "sig"; two white sides up = 0; three white sides up = 3; four white sides up = 4; all green sides up = 6. Throws of sig, 6, and 4 grant the player another throw. Players move their pieces along the track toward the central space. when they reach the sixth space from the end, they must make seven throws of sig before moving on, moving to the sixteenth spot on the seventh throw. After reaching the next spot, only throws of sig and 3 are used; sig to move one space, and 3 to move the Ghoula three spaces. When players reach the central space, Players control the Ghoula. When controlling the Ghoula, throws of 0 count as 6. Any pieces which have not moved from the starting space when the Ghoula is first moved are dragged with the Ghoula, and then may move normally on their next turn. The Ghoula, when reaching a space occupied by a player, continues their turn dragging the player back to the starting space. A player that is forced back to the starting space by any means loses. All players reaching the central space of the board win. The game has 4 players.
(game "Sig wa Duqqan (Houmt Taourit)" (players 4) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ExtensionTrack" {4 3 2 1 0} directed:True) (track "GhoulaTrack" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ReverseGhoulaTrack" {5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece "Stick" Each (if (= (from) 5) (if (= (state at:(from) level:(level)) 7) (move (from (from) level:(level)) (to 4)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (is In (from) (sites Track "Track")) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True)) (if (is In (from) (sites Track "ExtensionTrack")) (or {(if (and (!= (from) 0) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move "ExtensionTrack" steps:1)))) (if (= (from) 0) (move Pass (then (and (if (= 0 (mapEntry "Throw" (count Pips))) (set Var 6) (set Var (mapEntry "Throw" (count Pips)))) (moveAgain)))) (if (= 3 (mapEntry "Throw" (count Pips))) (move Pass (then (and (set Var 3) (moveAgain))))))})))) maxState:7) (piece "Ghoula" Neutral) (hand P1 size:1)}) (rules (start {(place Stack "Ghoula0" 86) (place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} 85)}) (play (do (if (<= (var) 0) (roll)) next:(if (> (var) 0) (if (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "GhoulaTrack" steps:1))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "ReverseGhoulaTrack" steps:1)) (then (if (= (last From) 84) (forEach Level (last From) FromTop (remove (last From) level:(level))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (set Var 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1)))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 6 4})) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (result Player Win))}))) 
86 spaces in a spiral track. Any number of players, each having one piece, which starts on the first space in the outer ring of the spiral. A lump of charcoal, the Ghoula, also is placed on this space. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as "sig"; two white sides up = 0; three white sides up = 3; four white sides up = 4; all green sides up = 6. Throws of sig, 6, and 4 grant the player another throw. Players move their pieces along the track toward the central space. when they reach the sixth space from the end, they must make seven throws of sig before moving on, moving to the sixteenth spot on the seventh throw. After reaching the next spot, only throws of sig and 3 are used; sig to move one space, and 3 to move the Ghoula three spaces. When players reach the central space, Players control the Ghoula. When controlling the Ghoula, throws of 0 count as 6. Any pieces which have not moved from the starting space when the Ghoula is first moved are dragged with the Ghoula, and then may move normally on their next turn. The Ghoula, when reaching a space occupied by a player, continues their turn dragging the player back to the starting space. A player that is forced back to the starting space by any means loses. All players reaching the central space of the board win. The game has 2 players.
(game "Sig wa Duqqan (Houmt Taourit)" (players 2) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ExtensionTrack" {4 3 2 1 0} directed:True) (track "GhoulaTrack" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ReverseGhoulaTrack" {5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece "Stick" Each (if (= (from) 5) (if (= (state at:(from) level:(level)) 7) (move (from (from) level:(level)) (to 4)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (is In (from) (sites Track "Track")) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True)) (if (is In (from) (sites Track "ExtensionTrack")) (or {(if (and (!= (from) 0) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move "ExtensionTrack" steps:1)))) (if (= (from) 0) (move Pass (then (and (if (= 0 (mapEntry "Throw" (count Pips))) (set Var 6) (set Var (mapEntry "Throw" (count Pips)))) (moveAgain)))) (if (= 3 (mapEntry "Throw" (count Pips))) (move Pass (then (and (set Var 3) (moveAgain))))))})))) maxState:7) (piece "Ghoula" Neutral) (hand P1 size:1)}) (rules (start {(place Stack "Ghoula0" 86) (place Stack items:{"Stick2" "Stick1"} 85)}) (play (do (if (<= (var) 0) (roll)) next:(if (> (var) 0) (if (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "GhoulaTrack" steps:1))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "ReverseGhoulaTrack" steps:1)) (then (if (= (last From) 84) (forEach Level (last From) FromTop (remove (last From) level:(level))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (set Var 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1)))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 6 4})) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (result Player Win))}))) 
86 spaces in a spiral track. Any number of players, each having one piece, which starts on the first space in the outer ring of the spiral. A lump of charcoal, the Ghoula, also is placed on this space. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as "sig"; two white sides up = 0; three white sides up = 3; four white sides up = 4; all green sides up = 6. Throws of sig, 6, and 4 grant the player another throw. Players move their pieces along the track toward the central space. when they reach the sixth space from the end, they must make seven throws of sig before moving on, moving to the sixteenth spot on the seventh throw. After reaching the next spot, only throws of sig and 3 are used; sig to move one space, and 3 to move the Ghoula three spaces. When players reach the central space, Players control the Ghoula. When controlling the Ghoula, throws of 0 count as 6. Any pieces which have not moved from the starting space when the Ghoula is first moved are dragged with the Ghoula, and then may move normally on their next turn. The Ghoula, when reaching a space occupied by a player, continues their turn dragging the player back to the starting space. A player that is forced back to the starting space by any means loses. All players reaching the central space of the board win. The game has 3 players.
(game "Sig wa Duqqan (Houmt Taourit)" (players 3) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ExtensionTrack" {4 3 2 1 0} directed:True) (track "GhoulaTrack" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ReverseGhoulaTrack" {5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece "Stick" Each (if (= (from) 5) (if (= (state at:(from) level:(level)) 7) (move (from (from) level:(level)) (to 4)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (is In (from) (sites Track "Track")) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True)) (if (is In (from) (sites Track "ExtensionTrack")) (or {(if (and (!= (from) 0) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move "ExtensionTrack" steps:1)))) (if (= (from) 0) (move Pass (then (and (if (= 0 (mapEntry "Throw" (count Pips))) (set Var 6) (set Var (mapEntry "Throw" (count Pips)))) (moveAgain)))) (if (= 3 (mapEntry "Throw" (count Pips))) (move Pass (then (and (set Var 3) (moveAgain))))))})))) maxState:7) (piece "Ghoula" Neutral) (hand P1 size:1)}) (rules (start {(place Stack "Ghoula0" 86) (place Stack items:{"Stick3" "Stick2" "Stick1"} 85)}) (play (do (if (<= (var) 0) (roll)) next:(if (> (var) 0) (if (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "GhoulaTrack" steps:1))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "ReverseGhoulaTrack" steps:1)) (then (if (= (last From) 84) (forEach Level (last From) FromTop (remove (last From) level:(level))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (set Var 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1)))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 6 4})) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (result Player Win))}))) 
5x5 board, with an X in the central square of each side of the board, as well as the central square of the board. Two players. Two pieces per player. Four cowrie shells used as dice. Throws have the value of the number of mouths that land face up, with no mouths up = 8. Players start on opposite sides of the board, the first point on their track being the marked square on that side. Players move in an anti-clockwise direction around the board, until reaching the space before the starting space, at which point they move into the space above it, and proceed around the inner part of the board in a clockwise direction, until below the central square. Players enter a piece with a throw of 1. Throws of 1 or 8 give the player another turn. When a player's piece lands on the same space as a space with an opponent's piece, the opponent's piece is removed from the board and must enter again, and the player causing this receives another throw. Pieces resting on a marked square cannot be sent back to start. To reach the central space, the player must throw the exact number required. The first player to move both pieces to the central space first wins.
(game "Siga (Sri Lanka)" (players 2) (equipment {(board (square 5) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True) (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P2 directed:True)}) (piece "Marker" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (and (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))) (moveAgain))))))) (hand Each) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair P1 2) (pair P2 22)}) (regions "SafeSites" (sites {2 10 12 14 22}))}) (rules (start {(place Stack "Marker1" (handSite P1) count:2) (place Stack "Marker2" (handSite P2) count:2)}) (play (do (roll) next:(or (if (and (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (handSite Mover)) (to (mapEntry "Entry" (mover))))) (forEach Piece)) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 8})) (moveAgain))))) (end (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (result Mover Win))))) 
5x5 board, with an X in the central square of each side of the board, as well as the central square of the board. Two players. Two pieces per player. Four cowrie shells used as dice. Throws have the value of the number of mouths that land face up, with no mouths up = 8. Players start on opposite sides of the board, the first point on their track being the marked square on that side. Players move in an anti-clockwise direction around the board, until reaching the space before the starting space, at which point they move into the space above it, and proceed around the inner part of the board in a clockwise direction, until below the central square. Players enter a piece with a throw of 1. Throws of 1 or 8 give the player another turn. When a player's piece lands on the same space as a space with an opponent's piece, the opponent's piece is removed from the board and must enter again, and the player causing this receives another throw. Pieces resting on a marked square cannot be sent back to start. To reach the central space, the player must throw the exact number required. The first player to move both pieces to the central space first wins.
(game "Siga (Sri Lanka)" (players 2) (equipment {(board (square 5) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True) (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P2 directed:True)}) (piece "Marker" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (and (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))) (moveAgain))))))) (hand Each) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair P1 2) (pair P2 22)}) (regions "SafeSites" (sites {2 10 12 14 22}))}) (rules (start {(place Stack "Marker1" (handSite P1) count:2) (place Stack "Marker2" (handSite P2) count:2)}) (play (do (roll) next:(or (if (and (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (handSite Mover)) (to (mapEntry "Entry" (mover))))) (forEach Piece)) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 8})) (moveAgain))))) (end (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (result Mover Win))))) 
5x5 board, with an X in the central square of each side of the board, as well as the central square of the board. Two players. Two pieces per player. Four cowrie shells used as dice. Throws have the value of the number of mouths that land face up, with no mouths up = 8. Players start on opposite sides of the board, the first point on their track being the marked square on that side. Players move in an anti-clockwise direction around the board, until reaching the space before the starting space, at which point they move into the space above it, and proceed around the inner part of the board in a clockwise direction, until below the central square. Players enter a piece with a throw of 1. Throws of 1 or 8 give the player another turn. When a player's piece lands on the same space as a space with an opponent's piece, the opponent's piece is removed from the board and must enter again, and the player causing this receives another throw. Pieces resting on a marked square cannot be sent back to start. To reach the central space, the player must throw the exact number required. The first player to move both pieces to the central space first wins.
(game "Siga (Sri Lanka)" (players 2) (equipment {(board (square 5) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True) (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P2 directed:True)}) (piece "Marker" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (and (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))) (moveAgain))))))) (hand Each) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair P1 2) (pair P2 22)}) (regions "SafeSites" (sites {2 10 12 14 22}))}) (rules (start {(place Stack "Marker1" (handSite P1) count:2) (place Stack "Marker2" (handSite P2) count:2)}) (play (do (roll) next:(or (if (and (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (handSite Mover)) (to (mapEntry "Entry" (mover))))) (forEach Piece)) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 8})) (moveAgain))))) (end (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (result Mover Win))))) 
5x5 grid, with six spaces extending from the central row; the final three of this extension rendered as rectangles rather than squares (Cairo, Medina, and Mecca, in that order). The central square of the grid is marked with a circle (the Minaret). Any number of players. Three pieces per player, a father, a mother, and an angel. Six sticks, black on one side and white on the other, used as dice. The throws are as follows: Five of any color plus one of the other color (known as "sir") = 1, plus an extra throw; six white = an extra throw, and the player moves the number of white faces; six black = three extra throws, and the player moves the number of white faces up. Any other throws = 0. The angel moves double the values of these throws. The father begins on the top left corner space, the angel on the next space below it, and the mother on the space below the angel. Players move vertically in a boustrophedon track in the main grid, and when reaching the bottom right corner they progress into the extended row. Players must throw sir to enter the Minaret, and then another sir to exit it. To progress into the first three spaces of the extended row, a player must throw a sir to move one space. To enter each of the three final spaces (Cairo, Medina, and Mecca), a player must throw sir three times. Upon entering the extended row, the angel no longer moves double. When a player passes the piece of an opponent, the opponent's piece is sent back to the space where it started. The first player to move their three pieces to Mecca wins. The game has 4 players.
(game "Siryu (Race)" (players 4) (equipment {(board (merge {(rectangle 5 2) (shift 2 -3 (scale 1.2 1 (rectangle 8 1))) (shift 3.2 0 (rectangle 5 2)) (shift 1.6 -6 (scale 2 1 (rectangle 3 1)))}) {(track "FirstTrack" "13,S,E1,N,E1,S1" directed:True) (track "SecondTrack" "6,S1,E1,N,E1,S" directed:True)}) (dice d:2 from:0 num:6) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 6)}) (map "ExtraThrow" {(pair 0 1) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 3)}) (piece "Father" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Angel" Each (if (!= 0 (* 2 (mapEntry "Throw" (count Pips)))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(* 2 (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(* 2 (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 24)) (move (from (from) level:(level)) (to 2))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Mother" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))})))}) (rules (start {(place Stack "Father1" 13) (place Stack "Angel1" 10) (place Stack "Mother1" 7) (place Stack "Father2" 13) (place Stack "Angel2" 10) (place Stack "Mother2" 7) (place Stack "Father3" 13) (place Stack "Angel3" 10) (place Stack "Mother3" 7) (place Stack "Father4" 13) (place Stack "Angel4" 10) (place Stack "Mother4" 7)}) (play (do (roll) next:(forEach Piece) (then (if (!= 0 (mapEntry "ExtraThrow" (count Pips))) (and (if (= 3 (mapEntry "ExtraThrow" (count Pips))) (if (<= (var) 0) (set Var 2) (set Var (+ 2 (var))))) (moveAgain)) (if (> (var) 0) (and (set Var (- (var) 1)) (moveAgain))))))) (end (if (and {(= 28 (where "Angel" Mover)) (= 28 (where "Father" Mover)) (= 28 (where "Mother" Mover))}) (result Mover Win))))) 
5x5 grid, with six spaces extending from the central row; the final three of this extension rendered as rectangles rather than squares (Cairo, Medina, and Mecca, in that order). The central square of the grid is marked with a circle (the Minaret). Any number of players. Three pieces per player, a father, a mother, and an angel. Six sticks, black on one side and white on the other, used as dice. The throws are as follows: Five of any color plus one of the other color (known as "sir") = 1, plus an extra throw; six white = an extra throw, and the player moves the number of white faces; six black = three extra throws, and the player moves the number of white faces up. Any other throws = 0. The angel moves double the values of these throws. The father begins on the top left corner space, the angel on the next space below it, and the mother on the space below the angel. Players move vertically in a boustrophedon track in the main grid, and when reaching the bottom right corner they progress into the extended row. Players must throw sir to enter the Minaret, and then another sir to exit it. To progress into the first three spaces of the extended row, a player must throw a sir to move one space. To enter each of the three final spaces (Cairo, Medina, and Mecca), a player must throw sir three times. Upon entering the extended row, the angel no longer moves double. When a player passes the piece of an opponent, the opponent's piece is sent back to the space where it started. The first player to move their three pieces to Mecca wins. The game has 2 players.
(game "Siryu (Race)" (players 2) (equipment {(board (merge {(rectangle 5 2) (shift 2 -3 (scale 1.2 1 (rectangle 8 1))) (shift 3.2 0 (rectangle 5 2)) (shift 1.6 -6 (scale 2 1 (rectangle 3 1)))}) {(track "FirstTrack" "13,S,E1,N,E1,S1" directed:True) (track "SecondTrack" "6,S1,E1,N,E1,S" directed:True)}) (dice d:2 from:0 num:6) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 6)}) (map "ExtraThrow" {(pair 0 1) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 3)}) (piece "Father" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Angel" Each (if (!= 0 (* 2 (mapEntry "Throw" (count Pips)))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(* 2 (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(* 2 (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 24)) (move (from (from) level:(level)) (to 2))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Mother" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))})))}) (rules (start {(place Stack "Father1" 13) (place Stack "Angel1" 10) (place Stack "Mother1" 7) (place Stack "Father2" 13) (place Stack "Angel2" 10) (place Stack "Mother2" 7)}) (play (do (roll) next:(forEach Piece) (then (if (!= 0 (mapEntry "ExtraThrow" (count Pips))) (and (if (= 3 (mapEntry "ExtraThrow" (count Pips))) (if (<= (var) 0) (set Var 2) (set Var (+ 2 (var))))) (moveAgain)) (if (> (var) 0) (and (set Var (- (var) 1)) (moveAgain))))))) (end (if (and {(= 28 (where "Angel" Mover)) (= 28 (where "Father" Mover)) (= 28 (where "Mother" Mover))}) (result Mover Win))))) 
5x5 grid, with six spaces extending from the central row; the final three of this extension rendered as rectangles rather than squares (Cairo, Medina, and Mecca, in that order). The central square of the grid is marked with a circle (the Minaret). Any number of players. Three pieces per player, a father, a mother, and an angel. Six sticks, black on one side and white on the other, used as dice. The throws are as follows: Five of any color plus one of the other color (known as "sir") = 1, plus an extra throw; six white = an extra throw, and the player moves the number of white faces; six black = three extra throws, and the player moves the number of white faces up. Any other throws = 0. The angel moves double the values of these throws. The father begins on the top left corner space, the angel on the next space below it, and the mother on the space below the angel. Players move vertically in a boustrophedon track in the main grid, and when reaching the bottom right corner they progress into the extended row. Players must throw sir to enter the Minaret, and then another sir to exit it. To progress into the first three spaces of the extended row, a player must throw a sir to move one space. To enter each of the three final spaces (Cairo, Medina, and Mecca), a player must throw sir three times. Upon entering the extended row, the angel no longer moves double. When a player passes the piece of an opponent, the opponent's piece is sent back to the space where it started. The first player to move their three pieces to Mecca wins. The game has 3 players.
(game "Siryu (Race)" (players 3) (equipment {(board (merge {(rectangle 5 2) (shift 2 -3 (scale 1.2 1 (rectangle 8 1))) (shift 3.2 0 (rectangle 5 2)) (shift 1.6 -6 (scale 2 1 (rectangle 3 1)))}) {(track "FirstTrack" "13,S,E1,N,E1,S1" directed:True) (track "SecondTrack" "6,S1,E1,N,E1,S" directed:True)}) (dice d:2 from:0 num:6) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 6)}) (map "ExtraThrow" {(pair 0 1) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 3)}) (piece "Father" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Angel" Each (if (!= 0 (* 2 (mapEntry "Throw" (count Pips)))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(* 2 (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(* 2 (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 24)) (move (from (from) level:(level)) (to 2))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Mother" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))})))}) (rules (start {(place Stack "Father1" 13) (place Stack "Angel1" 10) (place Stack "Mother1" 7) (place Stack "Father2" 13) (place Stack "Angel2" 10) (place Stack "Mother2" 7) (place Stack "Father3" 13) (place Stack "Angel3" 10) (place Stack "Mother3" 7)}) (play (do (roll) next:(forEach Piece) (then (if (!= 0 (mapEntry "ExtraThrow" (count Pips))) (and (if (= 3 (mapEntry "ExtraThrow" (count Pips))) (if (<= (var) 0) (set Var 2) (set Var (+ 2 (var))))) (moveAgain)) (if (> (var) 0) (and (set Var (- (var) 1)) (moveAgain))))))) (end (if (and {(= 28 (where "Angel" Mover)) (= 28 (where "Father" Mover)) (= 28 (where "Mother" Mover))}) (result Mover Win))))) 
Forty stones, arranged in a circle, with a larger gap (called a door) after every tenth stone. Two or four players, each player playing with one piece. Each piece begins in one of the doors: north/winter is yellow, west/spring is blue, south/summer is red, east/autumn is white. North and west move anti-clockwise around the circle, south and east move clockwise. Three sticks, red on one side and black on the other, used as dice, the throws are as follows: three red = 10, three black = 5, two red and one black = 3, two black and one red = 2. A throw of 10 grants the player another throw. When a player lands on a spot occupied by an opponent, the opponent's piece is sent back to start. The first player to complete four circuits of the board wins. Circuits are usually counted with beans or corn. The game has 4 players.
(game "Tasholiwe" (players 4) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (map "Throw" {(pair 0 10) (pair 1 3) (pair 2 2) (pair 3 5)}) (map "Start" {(pair 1 39) (pair 2 36) (pair 3 37) (pair 4 38)}) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each) (dice d:2 from:0 num:3) (hand Each)}) (rules (start {(place "Stick1" Edge (mapEntry "Start" P1)) (place "Stick2" Edge (mapEntry "Start" P2)) (place "Stick3" Edge (mapEntry "Start" P3)) (place "Stick4" Edge (mapEntry "Start" P4))}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P2)) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))))) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to)))))))))) (then (do (if (if (or (is Mover P1) (is Mover P2)) (is In (mapEntry "Start" Mover) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))) (is In (mapEntry "Start" Mover) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To)))) (addScore Mover 1) (then (if (= (score Mover) 4) (remove (last To))))) next:(if (and (!= 4 (score Mover)) (= 10 (mapEntry "Throw" (count Pips)))) (moveAgain)))))) (end (if (>= (score Mover) 4) (result Mover Win))))) 
Forty stones, arranged in a circle, with a larger gap (called a door) after every tenth stone. Two or four players, each player playing with one piece. Each piece begins in one of the doors: north/winter is yellow, west/spring is blue, south/summer is red, east/autumn is white. North and west move anti-clockwise around the circle, south and east move clockwise. Three sticks, red on one side and black on the other, used as dice, the throws are as follows: three red = 10, three black = 5, two red and one black = 3, two black and one red = 2. A throw of 10 grants the player another throw. When a player lands on a spot occupied by an opponent, the opponent's piece is sent back to start. The first player to complete four circuits of the board wins. Circuits are usually counted with beans or corn. The game has 2 players.
(game "Tasholiwe" (players 2) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (map "Throw" {(pair 0 10) (pair 1 3) (pair 2 2) (pair 3 5)}) (map "Start" {(pair 1 39) (pair 2 37)}) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each) (dice d:2 from:0 num:3) (hand Each)}) (rules (start {(place "Stick1" Edge (mapEntry "Start" P1)) (place "Stick2" Edge (mapEntry "Start" P2))}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P2)) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))))) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to)))))))))) (then (do (if (if (or (is Mover P1) (is Mover P2)) (is In (mapEntry "Start" Mover) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))) (is In (mapEntry "Start" Mover) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To)))) (addScore Mover 1) (then (if (= (score Mover) 4) (remove (last To))))) next:(if (and (!= 4 (score Mover)) (= 10 (mapEntry "Throw" (count Pips)))) (moveAgain)))))) (end (if (>= (score Mover) 4) (result Mover Win))))) 
Forty stones, arranged in a circle, with a larger gap (called a door) after every tenth stone. Two or four players, each player playing with one piece. Each piece begins in one of the doors: north/winter is yellow, west/spring is blue, south/summer is red, east/autumn is white. North and west move anti-clockwise around the circle, south and east move clockwise. Three sticks, red on one side and black on the other, used as dice, the throws are as follows: three red = 10, three black = 5, two red and one black = 3, two black and one red = 2. A throw of 10 grants the player another throw. When a player lands on a spot occupied by an opponent, the opponent's piece is sent back to start. The first player to complete four circuits of the board wins. Circuits are usually counted with beans or corn. The game has 4 players.
(game "Tasholiwe" (players 4) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (map "Throw" {(pair 0 10) (pair 1 3) (pair 2 2) (pair 3 5)}) (map "Start" {(pair 1 39) (pair 2 36) (pair 3 37) (pair 4 38)}) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each) (dice d:2 from:0 num:3) (hand Each)}) (rules (start {(place "Stick1" Edge (mapEntry "Start" P1)) (place "Stick2" Edge (mapEntry "Start" P2)) (place "Stick3" Edge (mapEntry "Start" P3)) (place "Stick4" Edge (mapEntry "Start" P4))}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P2)) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))))) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to)))))))))) (then (do (if (if (or (is Mover P1) (is Mover P2)) (is In (mapEntry "Start" Mover) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))) (is In (mapEntry "Start" Mover) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To)))) (addScore Mover 1) (then (if (= (score Mover) 4) (remove (last To))))) next:(if (and (!= 4 (score Mover)) (= 10 (mapEntry "Throw" (count Pips)))) (moveAgain)))))) (end (if (>= (score Mover) 4) (result Mover Win))))) 
Each side has a line of pawns. The pawns move as in chess i.e. The pawn moves forwards one square (optionally two squares on its first move) and captures diagonally forwards one square by replacing the opponent’s piece. The rule of En Passant is also allowed. White goes first. The first person to reach the other side is the winner. You also win if it is your opponent’s move and they have no moves left. In Ludii, options are also available to add each of the five other Chess piece types. In the variant with the king piece, if you capture the opponent king, you win as well. The game is played with only pawns.
(game "The Pawn Game" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))})) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6))}) (play (forEach Piece)) (end {(if (is In (last To) (sites Mover)) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Each side has a line of pawns. The pawns move as in chess i.e. The pawn moves forwards one square (optionally two squares on its first move) and captures diagonally forwards one square by replacing the opponent’s piece. The rule of En Passant is also allowed. White goes first. The first person to reach the other side is the winner. You also win if it is your opponent’s move and they have no moves left. In Ludii, options are also available to add each of the five other Chess piece types. In the variant with the king piece, if you capture the opponent king, you win as well. Chess rooks are added to the game.
(game "The Pawn Game" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Rook2" {"A8" "H8"})}) (play (forEach Piece)) (end {(if (is In (last To) (sites Mover)) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Each side has a line of pawns. The pawns move as in chess i.e. The pawn moves forwards one square (optionally two squares on its first move) and captures diagonally forwards one square by replacing the opponent’s piece. The rule of En Passant is also allowed. White goes first. The first person to reach the other side is the winner. You also win if it is your opponent’s move and they have no moves left. In Ludii, options are also available to add each of the five other Chess piece types. In the variant with the king piece, if you capture the opponent king, you win as well. Chess knights are added to the game.
(game "The Pawn Game" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))})) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Knight1" {"B1" "G1"}) (place "Knight2" {"B8" "G8"})}) (play (forEach Piece)) (end {(if (is In (last To) (sites Mover)) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
4x8 board. The fifth hole from the left in the inner row is rectangular, the rest are circular. 64 counters. Play begins with one counter in each hole in the inner row. Players take turns placing their remaining counters on the board in their inner rows. When they place a counter, they capture the hole facing it in the opponent's inner row, and sows the counters from either the leftmost or the rightmost hole of the player's inner row, sowing along the inner row. However, if the capture occurs from the rightmost, leftmost, or the next hole adjacent to each in the inner row, the captured pieces must be placed in the leftmost or rightmost hole, whichever is closer. The player may choose which hole to place captured counters in when captures are made from the central four holes in the inner row. The player must capture if possible, if not possible they place a counter into any of the holes in their inner row, pick up the contents of that hole, and sow in either direction. While sowing, if the final counter falls into an occupied hole and the opponent's hole opposite it has counters, the counters in the opponent's hole are captured. If the final counter falls into an occupied hole and the hole opposite it is empty, the counters are picked up and sowing continues in the same direction. If the final counter falls into an empty hole, the turn ends. If during this phase, the opponent's inner row is cleared of counters, the player wins. If all of the counters have been introduced and both players still have counters in their inner row, play proceeds to a second phase. Second Phase: Counters are picked up from any hole on the player's side and sown in either direction. The same capture, sowing, and victory rules apply as before. Captures, however, can only be made on subsequent sowings if there was a capture in the first round of a sowing.
(game "Bao Kiswahili (DR Congo)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (map "LeftMostInner" {(pair P1 8) (pair P2 23)}) (map "RightMostInner" {(pair P1 15) (pair P2 16)}) (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)}) (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})}) (rules (start {(set Count 24 at:(handSite P1)) (set Count 24 at:(handSite P2)) (set Count 1 to:(union (sites Row 1) (sites Row 2)))}) phases:{(phase "Placement" (play (if (is Prev Mover) (if (is Pending) (or (if (or (= 1 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "LeftMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "LeftMostInner" Mover)) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)})))))))) (if (or (= 2 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "RightMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "RightMostInner" Mover)) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (or (if (or (= (var "Direction") 1) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))))) (if (or (= (var "Direction") 2) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (if (is Occupied (handSite Mover)) (priority {(move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) count:1 (then (and {(moveAgain) (set Pending) (if (is In (last To) (expand (sites Right))) (set Value Mover 2) (if (is In (last To) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}))) (move (from (handSite Mover)) (to (sites Mover "Inner")) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)})))}) (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))))} (end (forEach Player if:(all Sites (sites Player "Inner") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. The fifth hole from the left in the inner row is rectangular, the rest are circular. 64 counters. Play begins with one counter in each hole in the inner row. Players take turns placing their remaining counters on the board in their inner rows. When they place a counter, they capture the hole facing it in the opponent's inner row, and sows the counters from either the leftmost or the rightmost hole of the player's inner row, sowing along the inner row. However, if the capture occurs from the rightmost, leftmost, or the next hole adjacent to each in the inner row, the captured pieces must be placed in the leftmost or rightmost hole, whichever is closer. The player may choose which hole to place captured counters in when captures are made from the central four holes in the inner row. The player must capture if possible, if not possible they place a counter into any of the holes in their inner row, pick up the contents of that hole, and sow in either direction. While sowing, if the final counter falls into an occupied hole and the opponent's hole opposite it has counters, the counters in the opponent's hole are captured. If the final counter falls into an occupied hole and the hole opposite it is empty, the counters are picked up and sowing continues in the same direction. If the final counter falls into an empty hole, the turn ends. If during this phase, the opponent's inner row is cleared of counters, the player wins. If all of the counters have been introduced and both players still have counters in their inner row, play proceeds to a second phase. Second Phase: Counters are picked up from any hole on the player's side and sown in either direction. The same capture, sowing, and victory rules apply as before. Captures, however, can only be made on subsequent sowings if there was a capture in the first round of a sowing.
(game "Bao Kiswahili (DR Congo)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (map "LeftMostInner" {(pair P1 8) (pair P2 23)}) (map "RightMostInner" {(pair P1 15) (pair P2 16)}) (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)}) (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})}) (rules (start {(set Count 24 at:(handSite P1)) (set Count 24 at:(handSite P2)) (set Count 1 to:(union (sites Row 1) (sites Row 2)))}) phases:{(phase "Placement" (play (if (is Prev Mover) (if (is Pending) (or (if (or (= 1 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "LeftMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "LeftMostInner" Mover)) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)})))))))) (if (or (= 2 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "RightMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "RightMostInner" Mover)) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (or (if (or (= (var "Direction") 1) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))))) (if (or (= (var "Direction") 2) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (if (is Occupied (handSite Mover)) (priority {(move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) count:1 (then (and {(moveAgain) (set Pending) (if (is In (last To) (expand (sites Right))) (set Value Mover 2) (if (is In (last To) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}))) (move (from (handSite Mover)) (to (sites Mover "Inner")) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)})))}) (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))))} (end (forEach Player if:(all Sites (sites Player "Inner") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. The fifth hole from the left in the inner row is rectangular, the rest are circular. 64 counters. Play begins with one counter in each hole in the inner row. Players take turns placing their remaining counters on the board in their inner rows. When they place a counter, they capture the hole facing it in the opponent's inner row, and sows the counters from either the leftmost or the rightmost hole of the player's inner row, sowing along the inner row. However, if the capture occurs from the rightmost, leftmost, or the next hole adjacent to each in the inner row, the captured pieces must be placed in the leftmost or rightmost hole, whichever is closer. The player may choose which hole to place captured counters in when captures are made from the central four holes in the inner row. The player must capture if possible, if not possible they place a counter into any of the holes in their inner row, pick up the contents of that hole, and sow in either direction. While sowing, if the final counter falls into an occupied hole and the opponent's hole opposite it has counters, the counters in the opponent's hole are captured. If the final counter falls into an occupied hole and the hole opposite it is empty, the counters are picked up and sowing continues in the same direction. If the final counter falls into an empty hole, the turn ends. If during this phase, the opponent's inner row is cleared of counters, the player wins. If all of the counters have been introduced and both players still have counters in their inner row, play proceeds to a second phase. Second Phase: Counters are picked up from any hole on the player's side and sown in either direction. The same capture, sowing, and victory rules apply as before. Captures, however, can only be made on subsequent sowings if there was a capture in the first round of a sowing.
(game "Bao Kiswahili (DR Congo)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (map "LeftMostInner" {(pair P1 8) (pair P2 23)}) (map "RightMostInner" {(pair P1 15) (pair P2 16)}) (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)}) (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})}) (rules (start {(set Count 24 at:(handSite P1)) (set Count 24 at:(handSite P2)) (set Count 1 to:(union (sites Row 1) (sites Row 2)))}) phases:{(phase "Placement" (play (if (is Prev Mover) (if (is Pending) (or (if (or (= 1 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "LeftMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "LeftMostInner" Mover)) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)})))))))) (if (or (= 2 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "RightMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "RightMostInner" Mover)) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (or (if (or (= (var "Direction") 1) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))))) (if (or (= (var "Direction") 2) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (if (is Occupied (handSite Mover)) (priority {(move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) count:1 (then (and {(moveAgain) (set Pending) (if (is In (last To) (expand (sites Right))) (set Value Mover 2) (if (is In (last To) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}))) (move (from (handSite Mover)) (to (sites Mover "Inner")) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)})))}) (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))))} (end (forEach Player if:(all Sites (sites Player "Inner") if:(= 0 (count at:(site)))) (result Player Loss))))) 
Play begins with two seeds in each hole. Each player owns the two rows closest to them. Play proceeds by taking the seeds from one hole and sowing them one by one in consecutive holes in an anti-clockwise direction. If the last seed falls in a hole in the inner row, and the opponent's hole opposite it is not empty, then the opponent's seeds in that hole are captured. Players can only play from holes with single counters when there is no other option, and they may not sow into another hole that already contains a counter. Play continues until one player no longer has any seeds.
(game "Hawalis" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "14,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (priority (move Select (from (sites Mover "Home") if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))) (move Select (from (sites Mover "Home") if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
Play begins with two seeds in each hole. Each player owns the two rows closest to them. Play proceeds by taking the seeds from one hole and sowing them one by one in consecutive holes in an anti-clockwise direction. If the last seed falls in a hole in the inner row, and the opponent's hole opposite it is not empty, then the opponent's seeds in that hole are captured. Players can only play from holes with single counters when there is no other option, and they may not sow into another hole that already contains a counter. Play continues until one player no longer has any seeds.
(game "Hawalis" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "14,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (priority (move Select (from (sites Mover "Home") if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))) (move Select (from (sites Mover "Home") if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
Play begins with two seeds in each hole. Each player owns the two rows closest to them. Play proceeds by taking the seeds from one hole and sowing them one by one in consecutive holes in an anti-clockwise direction. If the last seed falls in a hole in the inner row, and the opponent's hole opposite it is not empty, then the opponent's seeds in that hole are captured. Players can only play from holes with single counters when there is no other option, and they may not sow into another hole that already contains a counter. Play continues until one player no longer has any seeds.
(game "Hawalis" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "14,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (priority (move Select (from (sites Mover "Home") if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))) (move Select (from (sites Mover "Home") if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x8 board. Four pieces in each of the holes in the inner two rows. Sowing occurs in an anti-clockwise direction. Single counters cannot be sown. When the final counter of a sowing falls into an occupied hole, these counters are picked up and the sowing continues. If this hole is in the player's inner row, the counters in the opponent's opposite holes in both rows are captured. Both the inner and outer opposite holes must contain counters for a capture to occur. Play continues with the captured counters, and the player sows these beginning with the next hole after the last one on the player's side from which they picked up holes. Captures cannot be made on the first move. Clockwise sowing can begin from the following holes only if it will allow a capture to occur: the rightmost and leftmost holes of the outer row, the second from the right and second from the left holes in the inner row. Direction can be changed in the middle of a turn if the final counter lands in one of these holes and a clockwise move will result in a capture. When no capture is available, the player must resume in an anti-clockwise direction. When the final counter falls into an empty hole, the turn ends.
(game "Kubuguza" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "HolesCW" P1 (sites {15 8 1 6})) (regions "HolesCW" P2 (sites {16 23 25 30})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(union (sites P1 "Inner") (sites P2 "Inner")))) (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "HolesCW")) if:(and {(> (count at:(from)) 1) (is In (from) (sites Mover "HolesCW")) (if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (and (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8)))) False)})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Four pieces in each of the holes in the inner two rows. Sowing occurs in an anti-clockwise direction. Single counters cannot be sown. When the final counter of a sowing falls into an occupied hole, these counters are picked up and the sowing continues. If this hole is in the player's inner row, the counters in the opponent's opposite holes in both rows are captured. Both the inner and outer opposite holes must contain counters for a capture to occur. Play continues with the captured counters, and the player sows these beginning with the next hole after the last one on the player's side from which they picked up holes. Captures cannot be made on the first move. Clockwise sowing can begin from the following holes only if it will allow a capture to occur: the rightmost and leftmost holes of the outer row, the second from the right and second from the left holes in the inner row. Direction can be changed in the middle of a turn if the final counter lands in one of these holes and a clockwise move will result in a capture. When no capture is available, the player must resume in an anti-clockwise direction. When the final counter falls into an empty hole, the turn ends.
(game "Kubuguza" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "HolesCW" P1 (sites {15 8 1 6})) (regions "HolesCW" P2 (sites {16 23 25 30})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(union (sites P1 "Inner") (sites P2 "Inner")))) (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "HolesCW")) if:(and {(> (count at:(from)) 1) (is In (from) (sites Mover "HolesCW")) (if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (and (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8)))) False)})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Four pieces in each of the holes in the inner two rows. Sowing occurs in an anti-clockwise direction. Single counters cannot be sown. When the final counter of a sowing falls into an occupied hole, these counters are picked up and the sowing continues. If this hole is in the player's inner row, the counters in the opponent's opposite holes in both rows are captured. Both the inner and outer opposite holes must contain counters for a capture to occur. Play continues with the captured counters, and the player sows these beginning with the next hole after the last one on the player's side from which they picked up holes. Captures cannot be made on the first move. Clockwise sowing can begin from the following holes only if it will allow a capture to occur: the rightmost and leftmost holes of the outer row, the second from the right and second from the left holes in the inner row. Direction can be changed in the middle of a turn if the final counter lands in one of these holes and a clockwise move will result in a capture. When no capture is available, the player must resume in an anti-clockwise direction. When the final counter falls into an empty hole, the turn ends.
(game "Kubuguza" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "HolesCW" P1 (sites {15 8 1 6})) (regions "HolesCW" P2 (sites {16 23 25 30})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(union (sites P1 "Inner") (sites P2 "Inner")))) (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "HolesCW")) if:(and {(> (count at:(from)) 1) (is In (from) (sites Mover "HolesCW")) (if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (and (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8)))) False)})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Before play, players may arrange their counters as they see fit in their holes. Players alternate turns sowing the counters from one of their holes in an anticlockwise direction. When the final counter lands in an empty hole, their turn is over. If the final counter lands in an occupied hole, the contents of the two opposite hole in the opponent's rows are captured. If both do not have counters, then the player picks up the counters from the hole the last counter fell into and continues sowing. The player who captures all of the opponent's counters wins.
(game "Lisolo" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top)))}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (or (forEach Site (sites Mover "Home") (if (is Occupied (site)) (move (from (site)) (to (forEach (sites Mover "Home") if:(!= (to) (site))))))) (move Pass))) (nextPhase (all Passed) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (not (is In (to) (sites Mover "Inner"))) (moveAgain) (if (and (= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (moveAgain) (and (if (!= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))))))))))} (end (forEach Player if:(= 0 (count in:(sites Player "Home"))) (result Player Loss))))) 
4x8 board. Two counters in each hole. Before play, players may arrange their counters as they see fit in their holes. Players alternate turns sowing the counters from one of their holes in an anticlockwise direction. When the final counter lands in an empty hole, their turn is over. If the final counter lands in an occupied hole, the contents of the two opposite hole in the opponent's rows are captured. If both do not have counters, then the player picks up the counters from the hole the last counter fell into and continues sowing. The player who captures all of the opponent's counters wins.
(game "Lisolo" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top)))}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (or (forEach Site (sites Mover "Home") (if (is Occupied (site)) (move (from (site)) (to (forEach (sites Mover "Home") if:(!= (to) (site))))))) (move Pass))) (nextPhase (all Passed) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (not (is In (to) (sites Mover "Inner"))) (moveAgain) (if (and (= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (moveAgain) (and (if (!= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))))))))))} (end (forEach Player if:(= 0 (count in:(sites Player "Home"))) (result Player Loss))))) 
4x8 board. Two counters in each hole. Before play, players may arrange their counters as they see fit in their holes. Players alternate turns sowing the counters from one of their holes in an anticlockwise direction. When the final counter lands in an empty hole, their turn is over. If the final counter lands in an occupied hole, the contents of the two opposite hole in the opponent's rows are captured. If both do not have counters, then the player picks up the counters from the hole the last counter fell into and continues sowing. The player who captures all of the opponent's counters wins.
(game "Lisolo" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top)))}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (or (forEach Site (sites Mover "Home") (if (is Occupied (site)) (move (from (site)) (to (forEach (sites Mover "Home") if:(!= (to) (site))))))) (move Pass))) (nextPhase (all Passed) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (not (is In (to) (sites Mover "Inner"))) (moveAgain) (if (and (= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (moveAgain) (and (if (!= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))))))))))} (end (forEach Player if:(= 0 (count in:(sites Player "Home"))) (result Player Loss))))) 
4x8 board. Two counters in each hole. Play begins with each player taking the two counters in the leftmost hole of either the inner or outer row and placing them both in the following hole in an anti-clockwise direction, and continuing with the two counters in the next hole, until there is an alternating pattern of holes with four counters followed by empty holes in all of the player's holes. On the next turn, the player sows from one of the holes on the end of one of their rows. Sowing occurs in an anti-clockwise direction. After this turn, sowing can be from any hole on the player's side of the board. Single counters cannot be sown. When the final counter falls into an occupied hole, the player picks up these counters and continues to sow. When the final counter is supposed to fall into an empty hole, it is not placed there but placed in the next hole. When the final counter falls into an occupied hole in the inner row, any counters in the opponent's two holes opposite are captured. These are then sown on the player's side of the board, beginning with the first occupied hole immediately after an empty hole before the hole from which the capture was made. Play continues until one player can no longer play, and the opponent wins.
(game "Mangola" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "LeftMost" P1 (intersection (sites Left) (sites Track "TrackCCW1"))) (regions "LeftMost" P2 (intersection (sites Right) (sites Track "TrackCCW2"))) (regions "EndHoles" P1 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW1"))) (regions "EndHoles" P2 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW2"))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCCW" steps:1)}) (sites Mover "LeftMost")) if:(> (count at:(from)) 0)) (then (sow numPerHole:2 "TrackCCW" owner:(mover) apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Opening2")) (phase "Opening2" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "EndHoles")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))) (nextPhase Mover (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Play begins with each player taking the two counters in the leftmost hole of either the inner or outer row and placing them both in the following hole in an anti-clockwise direction, and continuing with the two counters in the next hole, until there is an alternating pattern of holes with four counters followed by empty holes in all of the player's holes. On the next turn, the player sows from one of the holes on the end of one of their rows. Sowing occurs in an anti-clockwise direction. After this turn, sowing can be from any hole on the player's side of the board. Single counters cannot be sown. When the final counter falls into an occupied hole, the player picks up these counters and continues to sow. When the final counter is supposed to fall into an empty hole, it is not placed there but placed in the next hole. When the final counter falls into an occupied hole in the inner row, any counters in the opponent's two holes opposite are captured. These are then sown on the player's side of the board, beginning with the first occupied hole immediately after an empty hole before the hole from which the capture was made. Play continues until one player can no longer play, and the opponent wins.
(game "Mangola" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "LeftMost" P1 (intersection (sites Left) (sites Track "TrackCCW1"))) (regions "LeftMost" P2 (intersection (sites Right) (sites Track "TrackCCW2"))) (regions "EndHoles" P1 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW1"))) (regions "EndHoles" P2 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW2"))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCCW" steps:1)}) (sites Mover "LeftMost")) if:(> (count at:(from)) 0)) (then (sow numPerHole:2 "TrackCCW" owner:(mover) apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Opening2")) (phase "Opening2" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "EndHoles")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))) (nextPhase Mover (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Play begins with each player taking the two counters in the leftmost hole of either the inner or outer row and placing them both in the following hole in an anti-clockwise direction, and continuing with the two counters in the next hole, until there is an alternating pattern of holes with four counters followed by empty holes in all of the player's holes. On the next turn, the player sows from one of the holes on the end of one of their rows. Sowing occurs in an anti-clockwise direction. After this turn, sowing can be from any hole on the player's side of the board. Single counters cannot be sown. When the final counter falls into an occupied hole, the player picks up these counters and continues to sow. When the final counter is supposed to fall into an empty hole, it is not placed there but placed in the next hole. When the final counter falls into an occupied hole in the inner row, any counters in the opponent's two holes opposite are captured. These are then sown on the player's side of the board, beginning with the first occupied hole immediately after an empty hole before the hole from which the capture was made. Play continues until one player can no longer play, and the opponent wins.
(game "Mangola" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "LeftMost" P1 (intersection (sites Left) (sites Track "TrackCCW1"))) (regions "LeftMost" P2 (intersection (sites Right) (sites Track "TrackCCW2"))) (regions "EndHoles" P1 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW1"))) (regions "EndHoles" P2 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW2"))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCCW" steps:1)}) (sites Mover "LeftMost")) if:(> (count at:(from)) 0)) (then (sow numPerHole:2 "TrackCCW" owner:(mover) apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Opening2")) (phase "Opening2" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "EndHoles")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))) (nextPhase Mover (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x6-28 board; 16-20 is most common, only even numbers of holes. Two counters in each hole except the leftmost on the inner row, which is left empty, and the one to its right which contains one counter. Players sow by picking up the counters in any of their holes and sowing them in an anti-clockwise direction. Sowing continues when the last counter falls into an occupied hole by picking up the counters in that hole and continuing in the same direction. When the final counter lands in an empty hole in the inner row, the counters in the opponent's hole opposite in the inner row are captured; if there are also counters in the opponent's outer row opposite, these are also captured. The player is also entitled to capture counters in any other hole on the opponent's side. The turn ends with a capture and the opponent's turn begins. Play always begins with a stylized move, where the counters are taken from the third hole from the left in the inner row, sowing and making captures as described above. Players may not sow single counters unless there are no holes on their side containing multiple counters. Play ends when one player has captured all of their opponent's counters. Each player has 16 holes per row.
(game "Mefuvha" (players 2) (equipment {(mancalaBoard 4 16 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "32,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (union (sites P1 "Home") (sites P2 "Home")) (union (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (expand (intersection (sites Row 2) (sites Right)) steps:1 W)))) (set Count 1 to:(union (difference (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (sites Left)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:1 W) (sites Right))))}) (play (if (and (is Pending) (is Prev Mover)) (move Select (from (sites Next "Home") if:(> (count at:(from)) 0)) (then (fromTo (from (last From)) (to (handSite Mover)) count:(count at:(last From))))) (priority (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (< (count Turns) 3) (if (is Mover P1) (difference (expand (intersection (sites Row 1) (sites Left)) steps:2 E) (expand (intersection (sites Row 1) (sites Left)) steps:1 E)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:2 W) (expand (intersection (sites Row 2) (sites Right)) steps:1 W))) (sites Mover "Home"))) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))) 0) (fromTo (from (if (is Mover P1) (+ (to) 16) (- (to) 16))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))))) (set Pending) (moveAgain)})))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))) 0) (fromTo (from (if (is Mover P1) (+ (to) 16) (- (to) 16))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))))) (set Pending) (moveAgain)}))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x6-28 board; 16-20 is most common, only even numbers of holes. Two counters in each hole except the leftmost on the inner row, which is left empty, and the one to its right which contains one counter. Players sow by picking up the counters in any of their holes and sowing them in an anti-clockwise direction. Sowing continues when the last counter falls into an occupied hole by picking up the counters in that hole and continuing in the same direction. When the final counter lands in an empty hole in the inner row, the counters in the opponent's hole opposite in the inner row are captured; if there are also counters in the opponent's outer row opposite, these are also captured. The player is also entitled to capture counters in any other hole on the opponent's side. The turn ends with a capture and the opponent's turn begins. Play always begins with a stylized move, where the counters are taken from the third hole from the left in the inner row, sowing and making captures as described above. Players may not sow single counters unless there are no holes on their side containing multiple counters. Play ends when one player has captured all of their opponent's counters. Each player has 6 holes per row.
(game "Mefuvha" (players 2) (equipment {(mancalaBoard 4 6 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "12,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (union (sites P1 "Home") (sites P2 "Home")) (union (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (expand (intersection (sites Row 2) (sites Right)) steps:1 W)))) (set Count 1 to:(union (difference (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (sites Left)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:1 W) (sites Right))))}) (play (if (and (is Pending) (is Prev Mover)) (move Select (from (sites Next "Home") if:(> (count at:(from)) 0)) (then (fromTo (from (last From)) (to (handSite Mover)) count:(count at:(last From))))) (priority (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (< (count Turns) 3) (if (is Mover P1) (difference (expand (intersection (sites Row 1) (sites Left)) steps:2 E) (expand (intersection (sites Row 1) (sites Left)) steps:1 E)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:2 W) (expand (intersection (sites Row 2) (sites Right)) steps:1 W))) (sites Mover "Home"))) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))) (set Pending) (moveAgain)})))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))) (set Pending) (moveAgain)}))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x6-28 board; 16-20 is most common, only even numbers of holes. Two counters in each hole except the leftmost on the inner row, which is left empty, and the one to its right which contains one counter. Players sow by picking up the counters in any of their holes and sowing them in an anti-clockwise direction. Sowing continues when the last counter falls into an occupied hole by picking up the counters in that hole and continuing in the same direction. When the final counter lands in an empty hole in the inner row, the counters in the opponent's hole opposite in the inner row are captured; if there are also counters in the opponent's outer row opposite, these are also captured. The player is also entitled to capture counters in any other hole on the opponent's side. The turn ends with a capture and the opponent's turn begins. Play always begins with a stylized move, where the counters are taken from the third hole from the left in the inner row, sowing and making captures as described above. Players may not sow single counters unless there are no holes on their side containing multiple counters. Play ends when one player has captured all of their opponent's counters. Each player has 8 holes per row.
(game "Mefuvha" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (union (sites P1 "Home") (sites P2 "Home")) (union (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (expand (intersection (sites Row 2) (sites Right)) steps:1 W)))) (set Count 1 to:(union (difference (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (sites Left)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:1 W) (sites Right))))}) (play (if (and (is Pending) (is Prev Mover)) (move Select (from (sites Next "Home") if:(> (count at:(from)) 0)) (then (fromTo (from (last From)) (to (handSite Mover)) count:(count at:(last From))))) (priority (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (< (count Turns) 3) (if (is Mover P1) (difference (expand (intersection (sites Row 1) (sites Left)) steps:2 E) (expand (intersection (sites Row 1) (sites Left)) steps:1 E)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:2 W) (expand (intersection (sites Row 2) (sites Right)) steps:1 W))) (sites Mover "Home"))) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Pending) (moveAgain)})))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Pending) (moveAgain)}))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x12 board. Four counters in each hole. Players alternate turns sowing the counters from one hole in an anti-clockwise direction. When the counters fall into a hole in their inner row, the contents of the opponent's opposite inner row hole are captured, as are any in the opponent's corresponding outer row hole, but only if counters were captured from the inner row hole. The player who captures the most counters wins.
(game "Moruba" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) if:(and {(is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0)}) apply:(and (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))))))))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
4x12 board. Four counters in each hole. Players alternate turns sowing the counters from one hole in an anti-clockwise direction. When the counters fall into a hole in their inner row, the contents of the opponent's opposite inner row hole are captured, as are any in the opponent's corresponding outer row hole, but only if counters were captured from the inner row hole. The player who captures the most counters wins.
(game "Moruba" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) if:(and {(is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0)}) apply:(and (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))))))))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
4x12 board. Four counters in each hole. Players alternate turns sowing the counters from one hole in an anti-clockwise direction. When the counters fall into a hole in their inner row, the contents of the opponent's opposite inner row hole are captured, as are any in the opponent's corresponding outer row hole, but only if counters were captured from the inner row hole. The player who captures the most counters wins.
(game "Moruba" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) if:(and {(is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0)}) apply:(and (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))))))))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
4x10-20 holes, with even numbers. Two counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.
(game "Msuwa wa Kunja" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 holes, with even numbers. Two counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 12 holes.
(game "Msuwa wa Kunja" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (and (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (and (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 holes, with even numbers. Two counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 14 holes.
(game "Msuwa wa Kunja" (players 2) (equipment {(mancalaBoard 4 14 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "28,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (and (remove (if (is Mover P1) (+ (to) 14) (- (to) 14))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (and (remove (if (is Mover P1) (+ (to) 14) (- (to) 14))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 holes, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero, and the hole to its left, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.
(game "Msuwa" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start {(set Count 2 to:(difference (sites Board) (sites {18 19 20 21}))) (set Count 1 to:(sites {18 21}))}) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 holes, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero, and the hole to its left, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 12 holes.
(game "Msuwa" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start {(set Count 2 to:(difference (sites Board) (sites {22 23 24 25}))) (set Count 1 to:(sites {22 25}))}) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (and (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (and (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 holes, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero, and the hole to its left, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 14 holes.
(game "Msuwa" (players 2) (equipment {(mancalaBoard 4 14 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "28,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start {(set Count 2 to:(difference (sites Board) (sites {26 27 28 29}))) (set Count 1 to:(sites {26 29}))}) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (and (remove (if (is Mover P1) (+ (to) 14) (- (to) 14))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (and (remove (if (is Mover P1) (+ (to) 14) (- (to) 14))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x7-10 board (seven most common). One counter in each hole, with the player's leftmost hole in the outer row empty. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. Captures are made when the final counter of a sowing lands in an empty hole in the inner row. Captures are only made from the opponent's opposite outer row hole, and only when their inner row hole is empty. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 7 holes.
(game "Namudilakunze" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "14,E,N1,W" loop:True P2) (track "TrackCW1" "6,W,N1,E" loop:True P1) (track "TrackCW2" "20,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (hand Each)}) (rules (start (set Count 1 to:(difference (sites Board) (sites {0 (- (* 7 4) 1)})))) phases:{(phase "FirstTurn" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (remove (if (is Mover P1) (+ (to) 7) (- (to) 7))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (remove (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (or (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 1)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 7) (- (to) 7))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (remove (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))) (if (!= 1 (value Player Mover)) (set Value Mover 1))))))) (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 2)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 7) (- (to) 7))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (remove (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))) (if (!= 2 (value Player Mover)) (set Value Mover 2))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x7-10 board (seven most common). One counter in each hole, with the player's leftmost hole in the outer row empty. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. Captures are made when the final counter of a sowing lands in an empty hole in the inner row. Captures are only made from the opponent's opposite outer row hole, and only when their inner row hole is empty. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 8 holes.
(game "Namudilakunze" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (hand Each)}) (rules (start (set Count 1 to:(difference (sites Board) (sites {0 (- (* 8 4) 1)})))) phases:{(phase "FirstTurn" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (or (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 1)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (if (!= 1 (value Player Mover)) (set Value Mover 1))))))) (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 2)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (if (!= 2 (value Player Mover)) (set Value Mover 2))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x7-10 board (seven most common). One counter in each hole, with the player's leftmost hole in the outer row empty. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. Captures are made when the final counter of a sowing lands in an empty hole in the inner row. Captures are only made from the opponent's opposite outer row hole, and only when their inner row hole is empty. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 9 holes.
(game "Namudilakunze" (players 2) (equipment {(mancalaBoard 4 9 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "18,E,N1,W" loop:True P2) (track "TrackCW1" "8,W,N1,E" loop:True P1) (track "TrackCW2" "26,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (hand Each)}) (rules (start (set Count 1 to:(difference (sites Board) (sites {0 (- (* 9 4) 1)})))) phases:{(phase "FirstTurn" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 9) (- (to) 9))) (remove (if (is Mover P1) (+ (to) 9) (- (to) 9))) (if (is Occupied (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))) (remove (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))))))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (or (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 1)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 9) (- (to) 9))) (if (is Occupied (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))) (remove (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))))))) (if (!= 1 (value Player Mover)) (set Value Mover 1))))))) (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 2)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 9) (- (to) 9))) (if (is Occupied (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))) (remove (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))))))) (if (!= 2 (value Player Mover)) (set Value Mover 2))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 12 holes.
(game "Owela (Benguela)" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "InnerInit" P1 (sites {19 20 21 22 23})) (regions "InnerInit" P2 (sites {24 25 26 27 28})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(sites P1 "Outer") (sites P1 "InnerInit") (sites P2 "Outer") (sites P2 "InnerInit")}))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(value Pending)}) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (and (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0)) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))))) (if (> (count at:(if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) 1) (and (set Pending (if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) (moveAgain)))}) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 13 holes.
(game "Owela (Benguela)" (players 2) (equipment {(mancalaBoard 4 13 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "26,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "InnerInit" P1 (sites {21 22 23 24 25})) (regions "InnerInit" P2 (sites {26 27 28 29 30})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(sites P1 "Outer") (sites P1 "InnerInit") (sites P2 "Outer") (sites P2 "InnerInit")}))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(value Pending)}) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (and (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 13) (- (to) 13))) 0)) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 13) (- (to) 13))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 13) (- (to) 13)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))))) (if (> (count at:(if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) 1) (and (set Pending (if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) (moveAgain)))}) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 14 holes.
(game "Owela (Benguela)" (players 2) (equipment {(mancalaBoard 4 14 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "28,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "InnerInit" P1 (sites {24 25 26 27})) (regions "InnerInit" P2 (sites {28 29 30 31})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(sites P1 "Outer") (sites P1 "InnerInit") (sites P2 "Outer") (sites P2 "InnerInit")}))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(value Pending)}) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (and (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 14) (- (to) 14))) 0)) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 14) (- (to) 14))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))))) (if (> (count at:(if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) 1) (and (set Pending (if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) (moveAgain)))}) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
4x4, 8, 10, 16, or 22 board. Two counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter lands in an empty hole in the player's inner row, the contents of the opponent's hole in the inner row opposite it are captured, and if there are counters also in the corresponding outer row hole, these are also captured. The player may also capture from another hole from the opponent's side of the board of their choosing. The turn ends. If the final counter lands in an empty hole in the player's outer row, the turn ends. Play continues until one player captures all of the opponent's counters, thus winning. Each player has 4 holes on each row.
(game "Tshuba" (players 2) (equipment {(mancalaBoard 4 4 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "8,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (if (= 1 (var "ExtraCapture")) (move Remove (difference (sites Next "Home") (sites Empty)) count:(count at:(to)) (then (set Var "ExtraCapture" 0))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))) 0) (remove (if (is Mover P1) (+ (to) 4) (- (to) 4)) count:(count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2))) count:(count at:(if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))))) (set Var "ExtraCapture" 1) (moveAgain)})))))))) (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Mover Win))))) 
4x4, 8, 10, 16, or 22 board. Two counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter lands in an empty hole in the player's inner row, the contents of the opponent's hole in the inner row opposite it are captured, and if there are counters also in the corresponding outer row hole, these are also captured. The player may also capture from another hole from the opponent's side of the board of their choosing. The turn ends. If the final counter lands in an empty hole in the player's outer row, the turn ends. Play continues until one player captures all of the opponent's counters, thus winning. Each player has 8 holes on each row.
(game "Tshuba" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (if (= 1 (var "ExtraCapture")) (move Remove (difference (sites Next "Home") (sites Empty)) count:(count at:(to)) (then (set Var "ExtraCapture" 0))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Var "ExtraCapture" 1) (moveAgain)})))))))) (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Mover Win))))) 
4x4, 8, 10, 16, or 22 board. Two counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter lands in an empty hole in the player's inner row, the contents of the opponent's hole in the inner row opposite it are captured, and if there are counters also in the corresponding outer row hole, these are also captured. The player may also capture from another hole from the opponent's side of the board of their choosing. The turn ends. If the final counter lands in an empty hole in the player's outer row, the turn ends. Play continues until one player captures all of the opponent's counters, thus winning. Each player has 10 holes on each row.
(game "Tshuba" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (if (= 1 (var "ExtraCapture")) (move Remove (difference (sites Next "Home") (sites Empty)) count:(count at:(to)) (then (set Var "ExtraCapture" 0))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))) 0) (remove (if (is Mover P1) (+ (to) 10) (- (to) 10)) count:(count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))) count:(count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))))) (set Var "ExtraCapture" 1) (moveAgain)})))))))) (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Mover Win))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Before the game starts, players choose to make additional captures from one, two, or three holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player then captures again, from the agreed-upon number of extra holes, chosen from any of the opponent's holes. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 3 extra captures. 8 Holes per row.
(game "Tsoro (Additional Capture)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (< 0 (var)) (move Remove (forEach (sites Next) if:(< 0 (count at:(site)))) (then (and (if (< 1 (var)) (moveAgain)) (set Var (- (var) 1))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and {(remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (moveAgain) (set Var 3)}))) (moveAgain))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Before the game starts, players choose to make additional captures from one, two, or three holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player then captures again, from the agreed-upon number of extra holes, chosen from any of the opponent's holes. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 1 extra capture. 12 Holes per row.
(game "Tsoro (Additional Capture)" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (< 0 (var)) (move Remove (forEach (sites Next) if:(< 0 (count at:(site)))) (then (and (if (< 1 (var)) (moveAgain)) (set Var (- (var) 1))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0) (and {(remove (if (is Mover P1) (+ (to) 12) (- (to) 12))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))) (moveAgain) (set Var 1)}))) (moveAgain))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Before the game starts, players choose to make additional captures from one, two, or three holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player then captures again, from the agreed-upon number of extra holes, chosen from any of the opponent's holes. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 2 extra captures. 15 Holes per row.
(game "Tsoro (Additional Capture)" (players 2) (equipment {(mancalaBoard 4 15 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "30,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (< 0 (var)) (move Remove (forEach (sites Next) if:(< 0 (count at:(site)))) (then (and (if (< 1 (var)) (moveAgain)) (set Var (- (var) 1))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 15) (- (to) 15))) 0) (and {(remove (if (is Mover P1) (+ (to) 15) (- (to) 15))) (if (> (count at:(if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2))))) (moveAgain) (set Var 2)}))) (moveAgain))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x13-19 board. Two counters in every hole, except the leftmost in both of a player's rows, which are empty, and the second from the left in the inner row, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. Captures are made when the final counters lands in an empty hole in the inner row, capturing the contents of the opponent's opposite inner row hole, as well as the contents of the outer row hole only if there was a capture from the inner row hole. Captures from extra holes are also made, which are graduated based on the number of captures the player has made. On their first turn, players sow from the third hole from the left in the front row. This triggers a capture of the counters in the opposite holes in the opponent's inner and outer rows, plus the contents of any other five holes on the opponent's side of the board. In subsequent turns, sowing must occur from a hole which follows an empty hole according to the circuit of the holes. On their second capture, the player captures three extra holes. All other subsequent captures capture from two extra holes. Sowing a single counter cannot result in a capture. The player who captures all of their opponent's counters wins. Each row has 13 holes.
(game "Tsoro (Baia)" (players 2) (equipment {(mancalaBoard 4 13 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "26,E,N1,W" loop:True P2) (track "TrackCW1" "12,W,N1,E" loop:True P1) (track "TrackCW2" "39,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "FirstMove" P1 (difference (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) steps:2 E) (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) E))) (regions "FirstMove" P2 (difference (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) steps:2 W) (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) W))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (sites P1 "Outer") (sites Left))) (set Count 2 to:(difference (sites P2 "Outer") (sites Right))) (set Count 2 to:(difference (sites P1 "Inner") (expand (sites Left)))) (set Count 2 to:(difference (sites P2 "Inner") (expand (sites Right)))) (set Count 1 to:(difference (sites P1 "Inner") (union (sites Left) (difference (sites P1 "Inner") (expand (sites Left)))))) (set Count 1 to:(difference (sites P2 "Inner") (union (sites Right) (difference (sites P2 "Inner") (expand (sites Right))))))}) phases:{(phase "FirstTurn" (play (if (>= 0 (var "FreeCapture")) (move Select (from (sites Mover "FirstMove")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 13) (- (to) 13))) (and {(fromTo (from (if (is Mover P1) (+ (to) 13) (- (to) 13))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 13) (- (to) 13)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))))) (set Value Mover (+ 1 (value Player Mover))) (set Var "FreeCapture" 5) (moveAgain)})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (if (>= 0 (var "FreeCapture")) (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (< 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))}) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 13) (- (to) 13))) (and {(fromTo (from (if (is Mover P1) (+ (to) 13) (- (to) 13))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 13) (- (to) 13)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))))) (set Value Mover (+ 1 (value Player Mover))) (if (= 0 (value Player Mover)) (set Var "FreeCapture" 3) (set Var "FreeCapture" 2)) (moveAgain)}))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (= 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))))} (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x13-19 board. Two counters in every hole, except the leftmost in both of a player's rows, which are empty, and the second from the left in the inner row, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. Captures are made when the final counters lands in an empty hole in the inner row, capturing the contents of the opponent's opposite inner row hole, as well as the contents of the outer row hole only if there was a capture from the inner row hole. Captures from extra holes are also made, which are graduated based on the number of captures the player has made. On their first turn, players sow from the third hole from the left in the front row. This triggers a capture of the counters in the opposite holes in the opponent's inner and outer rows, plus the contents of any other five holes on the opponent's side of the board. In subsequent turns, sowing must occur from a hole which follows an empty hole according to the circuit of the holes. On their second capture, the player captures three extra holes. All other subsequent captures capture from two extra holes. Sowing a single counter cannot result in a capture. The player who captures all of their opponent's counters wins. Each row has 14 holes.
(game "Tsoro (Baia)" (players 2) (equipment {(mancalaBoard 4 14 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "28,E,N1,W" loop:True P2) (track "TrackCW1" "13,W,N1,E" loop:True P1) (track "TrackCW2" "42,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "FirstMove" P1 (difference (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) steps:2 E) (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) E))) (regions "FirstMove" P2 (difference (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) steps:2 W) (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) W))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (sites P1 "Outer") (sites Left))) (set Count 2 to:(difference (sites P2 "Outer") (sites Right))) (set Count 2 to:(difference (sites P1 "Inner") (expand (sites Left)))) (set Count 2 to:(difference (sites P2 "Inner") (expand (sites Right)))) (set Count 1 to:(difference (sites P1 "Inner") (union (sites Left) (difference (sites P1 "Inner") (expand (sites Left)))))) (set Count 1 to:(difference (sites P2 "Inner") (union (sites Right) (difference (sites P2 "Inner") (expand (sites Right))))))}) phases:{(phase "FirstTurn" (play (if (>= 0 (var "FreeCapture")) (move Select (from (sites Mover "FirstMove")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 14) (- (to) 14))) (and {(fromTo (from (if (is Mover P1) (+ (to) 14) (- (to) 14))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))))) (set Value Mover (+ 1 (value Player Mover))) (set Var "FreeCapture" 5) (moveAgain)})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (if (>= 0 (var "FreeCapture")) (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (< 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))}) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 14) (- (to) 14))) (and {(fromTo (from (if (is Mover P1) (+ (to) 14) (- (to) 14))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 14) (- (to) 14)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 14 2)) (- (to) (* 14 2)))))) (set Value Mover (+ 1 (value Player Mover))) (if (= 0 (value Player Mover)) (set Var "FreeCapture" 3) (set Var "FreeCapture" 2)) (moveAgain)}))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (= 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))))} (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x13-19 board. Two counters in every hole, except the leftmost in both of a player's rows, which are empty, and the second from the left in the inner row, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. Captures are made when the final counters lands in an empty hole in the inner row, capturing the contents of the opponent's opposite inner row hole, as well as the contents of the outer row hole only if there was a capture from the inner row hole. Captures from extra holes are also made, which are graduated based on the number of captures the player has made. On their first turn, players sow from the third hole from the left in the front row. This triggers a capture of the counters in the opposite holes in the opponent's inner and outer rows, plus the contents of any other five holes on the opponent's side of the board. In subsequent turns, sowing must occur from a hole which follows an empty hole according to the circuit of the holes. On their second capture, the player captures three extra holes. All other subsequent captures capture from two extra holes. Sowing a single counter cannot result in a capture. The player who captures all of their opponent's counters wins. Each row has 15 holes.
(game "Tsoro (Baia)" (players 2) (equipment {(mancalaBoard 4 15 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "30,E,N1,W" loop:True P2) (track "TrackCW1" "14,W,N1,E" loop:True P1) (track "TrackCW2" "45,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "FirstMove" P1 (difference (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) steps:2 E) (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) E))) (regions "FirstMove" P2 (difference (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) steps:2 W) (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) W))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (sites P1 "Outer") (sites Left))) (set Count 2 to:(difference (sites P2 "Outer") (sites Right))) (set Count 2 to:(difference (sites P1 "Inner") (expand (sites Left)))) (set Count 2 to:(difference (sites P2 "Inner") (expand (sites Right)))) (set Count 1 to:(difference (sites P1 "Inner") (union (sites Left) (difference (sites P1 "Inner") (expand (sites Left)))))) (set Count 1 to:(difference (sites P2 "Inner") (union (sites Right) (difference (sites P2 "Inner") (expand (sites Right))))))}) phases:{(phase "FirstTurn" (play (if (>= 0 (var "FreeCapture")) (move Select (from (sites Mover "FirstMove")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 15) (- (to) 15))) (and {(fromTo (from (if (is Mover P1) (+ (to) 15) (- (to) 15))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 15) (- (to) 15)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))))) (set Value Mover (+ 1 (value Player Mover))) (set Var "FreeCapture" 5) (moveAgain)})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (if (>= 0 (var "FreeCapture")) (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (< 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))}) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 15) (- (to) 15))) (and {(fromTo (from (if (is Mover P1) (+ (to) 15) (- (to) 15))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 15) (- (to) 15)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))))) (set Value Mover (+ 1 (value Player Mover))) (if (= 0 (value Player Mover)) (set Var "FreeCapture" 3) (set Var "FreeCapture" 2)) (moveAgain)}))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (= 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))))} (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Captured counters are then sown on the player's own side of the board, starting with the hole following the one from which the capture was triggered. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 8 Holes per row.
(game "Tsoro (Reentered Captures)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) "Track" owner:(mover))}))) (moveAgain)))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Captured counters are then sown on the player's own side of the board, starting with the hole following the one from which the capture was triggered. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 12 Holes per row.
(game "Tsoro (Reentered Captures)" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) "Track" owner:(mover))}))) (moveAgain)))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Captured counters are then sown on the player's own side of the board, starting with the hole following the one from which the capture was triggered. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 15 Holes per row.
(game "Tsoro (Reentered Captures)" (players 2) (equipment {(mancalaBoard 4 15 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "30,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 15) (- (to) 15))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) 15) (- (to) 15))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 15) (- (to) 15)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) (* 15 2)) (- (to) (* 15 2)))) (count at:(if (is Mover P1) (+ (to) 15) (- (to) 15)))) "Track" owner:(mover))}))) (moveAgain)))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
2x5 board. Ten counters in each hole. Sowing occurs in an anti-clockwise direction, sowing first into the hole from which the counters originally came. Opening phase: In the first ten turns, each player must sow from each of their five holes. Main phase: Captures are made when the last counter of a sowing falls into a hole preceding a hole containing one, three, or five counters. These counters are taken. Any subsequent holes also containing one, three, or five counters are captured, until a hole is reached that does not have one of these numbers of counters. The exception to this is in the first move when no captures are made. Sowing cannot begin from a hole with a single counter. A player wins when his opponent can no longer sow. However, if a player can no longer move, they can redistribute their captured beans into their holes, and if all five can be filled with ten, the game is a draw.
(game "Adjiboto" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 10 to:(sites Track))) phases:{(phase "Opening" (play (move Select (from (difference (sites Mover) (sites (if (is Mover P1) (values Remembered "SowedHolesP1") (values Remembered "SowedHolesP2")))) if:(< 1 (count at:(to)))) (then (and (sow origin:True) (if (is Mover P1) (remember Value "SowedHolesP1" (last From) unique:True) (remember Value "SowedHolesP2" (last From) unique:True)))))) (nextPhase Mover (< 8 (count Turns)))) (phase "Main" (play (move Select (from (sites Mover) if:(< 1 (count at:(to)))) (then (sow if:(or {(= 1 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 3 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 5 (count at:(trackSite Move from:(to) "Track" steps:1)))}) apply:(fromTo (from (trackSite Move from:(to) "Track" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "Track" steps:1))) origin:True forward:True)))) (end (if (no Moves Next) {(if (< (count Cell at:(handSite Next)) 50) (result Mover Win)) (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))})))})) 
2x5 board. Ten counters in each hole. Sowing occurs in an anti-clockwise direction, sowing first into the hole from which the counters originally came. Opening phase: In the first ten turns, each player must sow from each of their five holes. Main phase: Captures are made when the last counter of a sowing falls into a hole preceding a hole containing one, three, or five counters. These counters are taken. Any subsequent holes also containing one, three, or five counters are captured, until a hole is reached that does not have one of these numbers of counters. The exception to this is in the first move when no captures are made. Sowing cannot begin from a hole with a single counter. A player wins when his opponent can no longer sow. However, if a player can no longer move, they can redistribute their captured beans into their holes, and if all five can be filled with ten, the game is a draw.
(game "Adjiboto" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 10 to:(sites Track))) phases:{(phase "Opening" (play (move Select (from (difference (sites Mover) (sites (if (is Mover P1) (values Remembered "SowedHolesP1") (values Remembered "SowedHolesP2")))) if:(< 1 (count at:(to)))) (then (and (sow origin:True) (if (is Mover P1) (remember Value "SowedHolesP1" (last From) unique:True) (remember Value "SowedHolesP2" (last From) unique:True)))))) (nextPhase Mover (< 8 (count Turns)))) (phase "Main" (play (move Select (from (sites Mover) if:(< 1 (count at:(to)))) (then (sow if:(or {(= 1 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 3 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 5 (count at:(trackSite Move from:(to) "Track" steps:1)))}) apply:(fromTo (from (trackSite Move from:(to) "Track" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "Track" steps:1))) origin:True forward:True)))) (end (if (no Moves Next) {(if (< (count Cell at:(handSite Next)) 50) (result Mover Win)) (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))})))})) 
2x5 board. Ten counters in each hole. Sowing occurs in an anti-clockwise direction, sowing first into the hole from which the counters originally came. Opening phase: In the first ten turns, each player must sow from each of their five holes. Main phase: Captures are made when the last counter of a sowing falls into a hole preceding a hole containing one, three, or five counters. These counters are taken. Any subsequent holes also containing one, three, or five counters are captured, until a hole is reached that does not have one of these numbers of counters. The exception to this is in the first move when no captures are made. Sowing cannot begin from a hole with a single counter. A player wins when his opponent can no longer sow. However, if a player can no longer move, they can redistribute their captured beans into their holes, and if all five can be filled with ten, the game is a draw.
(game "Adjiboto" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 10 to:(sites Track))) phases:{(phase "Opening" (play (move Select (from (difference (sites Mover) (sites (if (is Mover P1) (values Remembered "SowedHolesP1") (values Remembered "SowedHolesP2")))) if:(< 1 (count at:(to)))) (then (and (sow origin:True) (if (is Mover P1) (remember Value "SowedHolesP1" (last From) unique:True) (remember Value "SowedHolesP2" (last From) unique:True)))))) (nextPhase Mover (< 8 (count Turns)))) (phase "Main" (play (move Select (from (sites Mover) if:(< 1 (count at:(to)))) (then (sow if:(or {(= 1 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 3 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 5 (count at:(trackSite Move from:(to) "Track" steps:1)))}) apply:(fromTo (from (trackSite Move from:(to) "Track" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "Track" steps:1))) origin:True forward:True)))) (end (if (no Moves Next) {(if (< (count Cell at:(handSite Next)) 50) (result Mover Win)) (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))})))})) 
2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing ends. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Awagagae" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (if (is Mover P1) (not (is In (from) (values Remembered "CapturedP2"))) (not (is In (from) (values Remembered "CapturedP1")))) (< 0 (count at:(from))))) (then (sow "Track" apply:(if (not (if (= (mover) P1) (is In (to) (values Remembered "CapturedP1")) (is In (to) (values Remembered "CapturedP2")))) (if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (if (is Mover P1) (remember Value "CapturedP1" (to)) (remember Value "CapturedP2" (to))) (if (if (= (mover) P1) (is In (to) (values Remembered "CapturedP2")) (is In (to) (values Remembered "CapturedP1"))) (fromTo (from (to)) (to (handSite Next)) count:1) (if (> (count at:(to)) 1) (moveAgain))))))))} (then (if (no Pieces in:(forEach (sites Board) if:(and (not (is In (site) (values Remembered "CapturedP1"))) (not (is In (site) (values Remembered "CapturedP2")))))) (and {(forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP1")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP2")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "CapturedP1" All) (forget Value "CapturedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Next) (sites Mover)) if:(is Empty (to))) count:4 (then (and (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2)))) (and {(fromTo (from Cell (handSite P1)) (to (sites Empty)) count:(count Cell at:(handSite P1))) (fromTo (from Cell (handSite P2)) (to (sites Empty)) count:(count Cell at:(handSite P2))) (if (= 3 (count Cell at:(handSite P1))) (remember Value "OwnedP1" (regionSite (sites Empty) index:0)) (remember Value "OwnedP2" (regionSite (sites Empty) index:0)))}))))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing ends. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Awagagae" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (if (is Mover P1) (not (is In (from) (values Remembered "CapturedP2"))) (not (is In (from) (values Remembered "CapturedP1")))) (< 0 (count at:(from))))) (then (sow "Track" apply:(if (not (if (= (mover) P1) (is In (to) (values Remembered "CapturedP1")) (is In (to) (values Remembered "CapturedP2")))) (if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (if (is Mover P1) (remember Value "CapturedP1" (to)) (remember Value "CapturedP2" (to))) (if (if (= (mover) P1) (is In (to) (values Remembered "CapturedP2")) (is In (to) (values Remembered "CapturedP1"))) (fromTo (from (to)) (to (handSite Next)) count:1) (if (> (count at:(to)) 1) (moveAgain))))))))} (then (if (no Pieces in:(forEach (sites Board) if:(and (not (is In (site) (values Remembered "CapturedP1"))) (not (is In (site) (values Remembered "CapturedP2")))))) (and {(forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP1")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP2")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "CapturedP1" All) (forget Value "CapturedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Next) (sites Mover)) if:(is Empty (to))) count:4 (then (and (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2)))) (and {(fromTo (from Cell (handSite P1)) (to (sites Empty)) count:(count Cell at:(handSite P1))) (fromTo (from Cell (handSite P2)) (to (sites Empty)) count:(count Cell at:(handSite P2))) (if (= 3 (count Cell at:(handSite P1))) (remember Value "OwnedP1" (regionSite (sites Empty) index:0)) (remember Value "OwnedP2" (regionSite (sites Empty) index:0)))}))))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing ends. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Awagagae" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (if (is Mover P1) (not (is In (from) (values Remembered "CapturedP2"))) (not (is In (from) (values Remembered "CapturedP1")))) (< 0 (count at:(from))))) (then (sow "Track" apply:(if (not (if (= (mover) P1) (is In (to) (values Remembered "CapturedP1")) (is In (to) (values Remembered "CapturedP2")))) (if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (if (is Mover P1) (remember Value "CapturedP1" (to)) (remember Value "CapturedP2" (to))) (if (if (= (mover) P1) (is In (to) (values Remembered "CapturedP2")) (is In (to) (values Remembered "CapturedP1"))) (fromTo (from (to)) (to (handSite Next)) count:1) (if (> (count at:(to)) 1) (moveAgain))))))))} (then (if (no Pieces in:(forEach (sites Board) if:(and (not (is In (site) (values Remembered "CapturedP1"))) (not (is In (site) (values Remembered "CapturedP2")))))) (and {(forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP1")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP2")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "CapturedP1" All) (forget Value "CapturedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Next) (sites Mover)) if:(is Empty (to))) count:4 (then (and (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2)))) (and {(fromTo (from Cell (handSite P1)) (to (sites Empty)) count:(count Cell at:(handSite P1))) (fromTo (from Cell (handSite P2)) (to (sites Empty)) count:(count Cell at:(handSite P2))) (if (= 3 (count Cell at:(handSite P1))) (remember Value "OwnedP1" (regionSite (sites Empty) index:0)) (remember Value "OwnedP2" (regionSite (sites Empty) index:0)))}))))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The hole from which sowing begins must remain empty throughout the player's turn. Captures are made when the last counter of a sowing fall into the opponent's row in a hole containing one or two counters (thus making two or three), capturing all of the counters in that hole. A continuous series of holes holding two or three counters behind it are also captured, provided the player's sowing caused them to contain this number. If a player has no counters in their holes, the opponent must play to place seeds in their row, if possible. The game ends when players have holes with only empty and single counters. The player who captured the most counters wins.
(game "Awari" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (if (all Sites (sites Track) if:(<= (count at:(site)) 1)) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The hole from which sowing begins must remain empty throughout the player's turn. Captures are made when the last counter of a sowing fall into the opponent's row in a hole containing one or two counters (thus making two or three), capturing all of the counters in that hole. A continuous series of holes holding two or three counters behind it are also captured, provided the player's sowing caused them to contain this number. If a player has no counters in their holes, the opponent must play to place seeds in their row, if possible. The game ends when players have holes with only empty and single counters. The player who captured the most counters wins.
(game "Awari" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (if (all Sites (sites Track) if:(<= (count at:(site)) 1)) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The hole from which sowing begins must remain empty throughout the player's turn. Captures are made when the last counter of a sowing fall into the opponent's row in a hole containing one or two counters (thus making two or three), capturing all of the counters in that hole. A continuous series of holes holding two or three counters behind it are also captured, provided the player's sowing caused them to contain this number. If a player has no counters in their holes, the opponent must play to place seeds in their row, if possible. The game ends when players have holes with only empty and single counters. The player who captured the most counters wins.
(game "Awari" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (if (all Sites (sites Track) if:(<= (count at:(site)) 1)) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Each player has 36 counters which they arrange however they like in their holes. Play begins from any hole in a player's row. Sowing occurs in an anti-clockwise direction. When the last counter falls makes an odd number of counters in the final hole of the sowing, these are picked up and sowing continues. If the last hole is made to be even, these are captured, as well as the contents of the opposite hole. If the previous hole is also even, those counters and those in the opposite hole are also taken, continuing until there is an odd or empty hole. If the final counter falls into an empty hole, play ends. The round ends when one player is unable to move. A new round begins. The player with the smaller number of counters distributes them as they like in their holes. The opponent then copies this arrangement, keeping the surplus of counters. Play continues as before. Rounds are played until one player has no remaining counters.
(game "Baqura" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 36 at:(handSite P1)) (set Count 36 at:(handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Mover)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing")) (phase "Sowing" (play (if (not (all Sites (sites Mover) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:(> (count at:(to)) 1) apply:(if (and (> (count at:(to)) 1) (is Odd (count at:(to)))) (moveAgain) (and (if (> (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))) backtracking:(and {(is In (to) (sites Mover)) (> (count at:(to)) 1) (is Even (count at:(to)))})))) (move Pass (then (and (forEach Site (sites Next) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite Next)) count:(count at:(site))))) (if (< (+ (count Cell at:(handSite P1)) (count in:(sites P1))) (+ (count Cell at:(handSite P2)) (count in:(sites P2)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))))))) (nextPhase (was Pass) "PlacementLosingPlayer")) (phase "PlacementLosingPlayer" (play (move (from (handSite Mover)) (to (sites Mover)) (then (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from Cell (handSite Next)) (to (if (is In (site) (sites Bottom)) (+ (site) 6) (- (site) 6))) count:(count at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing"))} (end (forEach Player if:(= 0 (+ (count Cell at:(handSite Player)) (count in:(sites Player)))) (result Player Loss))))) 
2x6 board. Each player has 36 counters which they arrange however they like in their holes. Play begins from any hole in a player's row. Sowing occurs in an anti-clockwise direction. When the last counter falls makes an odd number of counters in the final hole of the sowing, these are picked up and sowing continues. If the last hole is made to be even, these are captured, as well as the contents of the opposite hole. If the previous hole is also even, those counters and those in the opposite hole are also taken, continuing until there is an odd or empty hole. If the final counter falls into an empty hole, play ends. The round ends when one player is unable to move. A new round begins. The player with the smaller number of counters distributes them as they like in their holes. The opponent then copies this arrangement, keeping the surplus of counters. Play continues as before. Rounds are played until one player has no remaining counters.
(game "Baqura" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 36 at:(handSite P1)) (set Count 36 at:(handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Mover)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing")) (phase "Sowing" (play (if (not (all Sites (sites Mover) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:(> (count at:(to)) 1) apply:(if (and (> (count at:(to)) 1) (is Odd (count at:(to)))) (moveAgain) (and (if (> (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))) backtracking:(and {(is In (to) (sites Mover)) (> (count at:(to)) 1) (is Even (count at:(to)))})))) (move Pass (then (and (forEach Site (sites Next) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite Next)) count:(count at:(site))))) (if (< (+ (count Cell at:(handSite P1)) (count in:(sites P1))) (+ (count Cell at:(handSite P2)) (count in:(sites P2)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))))))) (nextPhase (was Pass) "PlacementLosingPlayer")) (phase "PlacementLosingPlayer" (play (move (from (handSite Mover)) (to (sites Mover)) (then (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from Cell (handSite Next)) (to (if (is In (site) (sites Bottom)) (+ (site) 6) (- (site) 6))) count:(count at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing"))} (end (forEach Player if:(= 0 (+ (count Cell at:(handSite Player)) (count in:(sites Player)))) (result Player Loss))))) 
2x6 board. Each player has 36 counters which they arrange however they like in their holes. Play begins from any hole in a player's row. Sowing occurs in an anti-clockwise direction. When the last counter falls makes an odd number of counters in the final hole of the sowing, these are picked up and sowing continues. If the last hole is made to be even, these are captured, as well as the contents of the opposite hole. If the previous hole is also even, those counters and those in the opposite hole are also taken, continuing until there is an odd or empty hole. If the final counter falls into an empty hole, play ends. The round ends when one player is unable to move. A new round begins. The player with the smaller number of counters distributes them as they like in their holes. The opponent then copies this arrangement, keeping the surplus of counters. Play continues as before. Rounds are played until one player has no remaining counters.
(game "Baqura" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 36 at:(handSite P1)) (set Count 36 at:(handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Mover)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing")) (phase "Sowing" (play (if (not (all Sites (sites Mover) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:(> (count at:(to)) 1) apply:(if (and (> (count at:(to)) 1) (is Odd (count at:(to)))) (moveAgain) (and (if (> (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))) backtracking:(and {(is In (to) (sites Mover)) (> (count at:(to)) 1) (is Even (count at:(to)))})))) (move Pass (then (and (forEach Site (sites Next) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite Next)) count:(count at:(site))))) (if (< (+ (count Cell at:(handSite P1)) (count in:(sites P1))) (+ (count Cell at:(handSite P2)) (count in:(sites P2)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))))))) (nextPhase (was Pass) "PlacementLosingPlayer")) (phase "PlacementLosingPlayer" (play (move (from (handSite Mover)) (to (sites Mover)) (then (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from Cell (handSite Next)) (to (if (is In (site) (sites Bottom)) (+ (site) 6) (- (site) 6))) count:(count at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing"))} (end (forEach Player if:(= 0 (+ (count Cell at:(handSite Player)) (count in:(sites Player)))) (result Player Loss))))) 
2x4 board, rendered as holes in the sand. Six counters per hole. A player picks up all of the counters in one of the holes in their row and sows them in an anti-clockwise direction. When the final counter lands in an empty hole, the contents of the following hole are picked up and the sowing continues. When the final counter lands in a hole in the opponent's row causing it to contain six counters, these counters are captured. Play continues until one player has no counters in their holes, and the opponent wins.
(game "Boukerourou" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "Track" steps:1)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (and (= 1 (count at:(to))) (is Occupied (trackSite Move from:(to) "Track" steps:1))) (moveAgain) (if (and (is In (to) (sites Next)) (= 6 (count at:(to)))) (remove (to)))))))) (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
2x4 board, rendered as holes in the sand. Six counters per hole. A player picks up all of the counters in one of the holes in their row and sows them in an anti-clockwise direction. When the final counter lands in an empty hole, the contents of the following hole are picked up and the sowing continues. When the final counter lands in a hole in the opponent's row causing it to contain six counters, these counters are captured. Play continues until one player has no counters in their holes, and the opponent wins.
(game "Boukerourou" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "Track" steps:1)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (and (= 1 (count at:(to))) (is Occupied (trackSite Move from:(to) "Track" steps:1))) (moveAgain) (if (and (is In (to) (sites Next)) (= 6 (count at:(to)))) (remove (to)))))))) (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
2x4 board, rendered as holes in the sand. Six counters per hole. A player picks up all of the counters in one of the holes in their row and sows them in an anti-clockwise direction. When the final counter lands in an empty hole, the contents of the following hole are picked up and the sowing continues. When the final counter lands in a hole in the opponent's row causing it to contain six counters, these counters are captured. Play continues until one player has no counters in their holes, and the opponent wins.
(game "Boukerourou" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "Track" steps:1)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (and (= 1 (count at:(to))) (is Occupied (trackSite Move from:(to) "Track" steps:1))) (moveAgain) (if (and (is In (to) (sites Next)) (= 6 (count at:(to)))) (remove (to)))))))) (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
Two rows of six holes encircling a larger hole in the center. Two counters in each hole, except the center hole. Players move by removing the counters from one of the holes in their row and sowing them in an anti-clockwise direction. If the final counter of the sowing falls into an occupied hole, these counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole already containing two others, the player takes these counters and covers the hole. The three counters are sown beginning with the following hole. When sowing, if a player reaches a covered hole in their row, they skip it and continue sowing with the next available hole. If the player reaches a covered hole in the opponent's row, the counter that would fall into it is instead deposited into the central hole. If this is the final counter, the turn ends. It is possible to sow a single counter. The player who can no longer sow from their row loses.
(game "Deka" (players 2) (equipment {(board (merge {(rectangle 1 5) (rectangle 3 1) (shift 0 2 (rectangle 1 5)) (shift 4 0 (rectangle 3 1)) (shift 2 1 (square 1))}) (track "Track" "0,E,N,W,S1" loop:True) use:Vertex) (regions P1 (sites {0 1 2 3 4 11})) (regions P2 (sites {5 6 7 8 9 10})) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(difference (sites Board) 12))) (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow apply:(if (not (and (is In (to) (sites Next)) (= (next) (state at:(to))))) (if (= 3 (count at:(to))) (and {(fromTo (from (to)) (to (trackSite Move from:(to) steps:1)) count:3) (sow (trackSite Move from:(to) steps:1) count:3 skipIf:(and (is In (to) (sites Mover)) (= 1 (state at:(to))))) (set State at:(to) 1)}) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) skipIf:(and (is In (to) (sites Mover)) (= (mover) (state at:(to)))))))} (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= 1 (state at:(site))) (and (fromTo (from (site)) (to (centrePoint)) count:(count at:(site))) (set State at:(site) 1))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
Two rows of six holes encircling a larger hole in the center. Two counters in each hole, except the center hole. Players move by removing the counters from one of the holes in their row and sowing them in an anti-clockwise direction. If the final counter of the sowing falls into an occupied hole, these counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole already containing two others, the player takes these counters and covers the hole. The three counters are sown beginning with the following hole. When sowing, if a player reaches a covered hole in their row, they skip it and continue sowing with the next available hole. If the player reaches a covered hole in the opponent's row, the counter that would fall into it is instead deposited into the central hole. If this is the final counter, the turn ends. It is possible to sow a single counter. The player who can no longer sow from their row loses.
(game "Deka" (players 2) (equipment {(board (merge {(rectangle 1 5) (rectangle 3 1) (shift 0 2 (rectangle 1 5)) (shift 4 0 (rectangle 3 1)) (shift 2 1 (square 1))}) (track "Track" "0,E,N,W,S1" loop:True) use:Vertex) (regions P1 (sites {0 1 2 3 4 11})) (regions P2 (sites {5 6 7 8 9 10})) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(difference (sites Board) 12))) (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow apply:(if (not (and (is In (to) (sites Next)) (= (next) (state at:(to))))) (if (= 3 (count at:(to))) (and {(fromTo (from (to)) (to (trackSite Move from:(to) steps:1)) count:3) (sow (trackSite Move from:(to) steps:1) count:3 skipIf:(and (is In (to) (sites Mover)) (= 1 (state at:(to))))) (set State at:(to) 1)}) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) skipIf:(and (is In (to) (sites Mover)) (= (mover) (state at:(to)))))))} (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= 1 (state at:(site))) (and (fromTo (from (site)) (to (centrePoint)) count:(count at:(site))) (set State at:(site) 1))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
Two rows of six holes encircling a larger hole in the center. Two counters in each hole, except the center hole. Players move by removing the counters from one of the holes in their row and sowing them in an anti-clockwise direction. If the final counter of the sowing falls into an occupied hole, these counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole already containing two others, the player takes these counters and covers the hole. The three counters are sown beginning with the following hole. When sowing, if a player reaches a covered hole in their row, they skip it and continue sowing with the next available hole. If the player reaches a covered hole in the opponent's row, the counter that would fall into it is instead deposited into the central hole. If this is the final counter, the turn ends. It is possible to sow a single counter. The player who can no longer sow from their row loses.
(game "Deka" (players 2) (equipment {(board (merge {(rectangle 1 5) (rectangle 3 1) (shift 0 2 (rectangle 1 5)) (shift 4 0 (rectangle 3 1)) (shift 2 1 (square 1))}) (track "Track" "0,E,N,W,S1" loop:True) use:Vertex) (regions P1 (sites {0 1 2 3 4 11})) (regions P2 (sites {5 6 7 8 9 10})) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(difference (sites Board) 12))) (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow apply:(if (not (and (is In (to) (sites Next)) (= (next) (state at:(to))))) (if (= 3 (count at:(to))) (and {(fromTo (from (to)) (to (trackSite Move from:(to) steps:1)) count:3) (sow (trackSite Move from:(to) steps:1) count:3 skipIf:(and (is In (to) (sites Mover)) (= 1 (state at:(to))))) (set State at:(to) 1)}) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) skipIf:(and (is In (to) (sites Mover)) (= (mover) (state at:(to)))))))} (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= 1 (state at:(site))) (and (fromTo (from (site)) (to (centrePoint)) count:(count at:(site))) (set State at:(site) 1))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
2x6 board. Four counters in each hole. Play begins with a stylised move. One player takes the four counters in their leftmost hole and places them into the next hole, moving in an anti-clockwise direction. They then take the four counters in the next hole, and place them in the following holes. This continues until the entire board has an alternation pattern of a hole with eight counters followed by one with zero counters. The player then sows beginning from the final hole with eight counters they created. When the final counter of a sowing lands in a hole with counters, the player picks up these counters and sowing continues. When the final counter falls into an empty hole, the turn ends. At any time during the sowing a hole is made to contain four counters, they are captured by the player who is sowing, except when it is the final hole of a sowing, in which case they are picked up and sowing continues. If a player cannot play, they must pass their turn and may resume play when they are next able. When all of the counters have been captured, the player who captured the most counters wins.
(game "Gabata (Oromo)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (var "Replay") 0)) (then (sow numPerHole:4 apply:(and (moveAgain) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" -1))))))) (nextPhase (= -1 (var "Replay")) "Opening2")) (phase "Opening2" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (var "Replay") 6)) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))) (nextPhase (not (is Next Prev)) "Sowing")) (phase "Sowing" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Play begins with a stylised move. One player takes the four counters in their leftmost hole and places them into the next hole, moving in an anti-clockwise direction. They then take the four counters in the next hole, and place them in the following holes. This continues until the entire board has an alternation pattern of a hole with eight counters followed by one with zero counters. The player then sows beginning from the final hole with eight counters they created. When the final counter of a sowing lands in a hole with counters, the player picks up these counters and sowing continues. When the final counter falls into an empty hole, the turn ends. At any time during the sowing a hole is made to contain four counters, they are captured by the player who is sowing, except when it is the final hole of a sowing, in which case they are picked up and sowing continues. If a player cannot play, they must pass their turn and may resume play when they are next able. When all of the counters have been captured, the player who captured the most counters wins.
(game "Gabata (Oromo)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (var "Replay") 0)) (then (sow numPerHole:4 apply:(and (moveAgain) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" -1))))))) (nextPhase (= -1 (var "Replay")) "Opening2")) (phase "Opening2" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (var "Replay") 6)) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))) (nextPhase (not (is Next Prev)) "Sowing")) (phase "Sowing" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Play begins with a stylised move. One player takes the four counters in their leftmost hole and places them into the next hole, moving in an anti-clockwise direction. They then take the four counters in the next hole, and place them in the following holes. This continues until the entire board has an alternation pattern of a hole with eight counters followed by one with zero counters. The player then sows beginning from the final hole with eight counters they created. When the final counter of a sowing lands in a hole with counters, the player picks up these counters and sowing continues. When the final counter falls into an empty hole, the turn ends. At any time during the sowing a hole is made to contain four counters, they are captured by the player who is sowing, except when it is the final hole of a sowing, in which case they are picked up and sowing continues. If a player cannot play, they must pass their turn and may resume play when they are next able. When all of the counters have been captured, the player who captured the most counters wins.
(game "Gabata (Oromo)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (var "Replay") 0)) (then (sow numPerHole:4 apply:(and (moveAgain) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" -1))))))) (nextPhase (= -1 (var "Replay")) "Opening2")) (phase "Opening2" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (var "Replay") 6)) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))) (nextPhase (not (is Next Prev)) "Sowing")) (phase "Sowing" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x5 board, the right-most hole is the store. Four counters in each hole. Sowing in an anti-clockwise direction, including the store. Play begins by each player placing the counters in their fourth hole into their store. Moves may begin from any of a player's holes except the store. If the last counter of a sowing drops into a hole making it contain two or three counters, these are taken and placed in the store. As soon as a player has at least thirteen counters in their store, they are picked up and sown, omitting each player's store and takes any counters in the opponent's holes which now contain two or three counters. Each player performs this move only once. The player who captures the most counters wins.
(game "I Pere" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 4) (pair P2 5)}) (map "Fourth" {(pair P1 3) (pair P2 6)})}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (mapEntry "Fourth" Mover)) (to (mapEntry Mover)) count:4)) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (and (<= 13 (count at:(mapEntry Mover))) (!= 1 (value Player Mover))) (or {(move Select (from (mapEntry Mover)) (then (and (sow skipIf:(or (= (to) (mapEntry P1)) (= (to) (mapEntry P2)))) (set Value Mover 1))))} (then (forEach Site (difference (sites Next) (mapEntry Next)) (if (or (= 2 (count at:(site))) (= 3 (count at:(site)))) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site))))))) (move Select (from (difference (sites Mover) (mapEntry Mover)) if:(is Occupied (from))) (then (sow apply:(if (or (= 2 (count at:(to))) (= 3 (count at:(to)))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))))))))))} (end (if (no Moves Next) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x5 board, the right-most hole is the store. Four counters in each hole. Sowing in an anti-clockwise direction, including the store. Play begins by each player placing the counters in their fourth hole into their store. Moves may begin from any of a player's holes except the store. If the last counter of a sowing drops into a hole making it contain two or three counters, these are taken and placed in the store. As soon as a player has at least thirteen counters in their store, they are picked up and sown, omitting each player's store and takes any counters in the opponent's holes which now contain two or three counters. Each player performs this move only once. The player who captures the most counters wins.
(game "I Pere" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 4) (pair P2 5)}) (map "Fourth" {(pair P1 3) (pair P2 6)})}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (mapEntry "Fourth" Mover)) (to (mapEntry Mover)) count:4)) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (and (<= 13 (count at:(mapEntry Mover))) (!= 1 (value Player Mover))) (or {(move Select (from (mapEntry Mover)) (then (and (sow skipIf:(or (= (to) (mapEntry P1)) (= (to) (mapEntry P2)))) (set Value Mover 1))))} (then (forEach Site (difference (sites Next) (mapEntry Next)) (if (or (= 2 (count at:(site))) (= 3 (count at:(site)))) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site))))))) (move Select (from (difference (sites Mover) (mapEntry Mover)) if:(is Occupied (from))) (then (sow apply:(if (or (= 2 (count at:(to))) (= 3 (count at:(to)))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))))))))))} (end (if (no Moves Next) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x5 board, the right-most hole is the store. Four counters in each hole. Sowing in an anti-clockwise direction, including the store. Play begins by each player placing the counters in their fourth hole into their store. Moves may begin from any of a player's holes except the store. If the last counter of a sowing drops into a hole making it contain two or three counters, these are taken and placed in the store. As soon as a player has at least thirteen counters in their store, they are picked up and sown, omitting each player's store and takes any counters in the opponent's holes which now contain two or three counters. Each player performs this move only once. The player who captures the most counters wins.
(game "I Pere" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 4) (pair P2 5)}) (map "Fourth" {(pair P1 3) (pair P2 6)})}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (mapEntry "Fourth" Mover)) (to (mapEntry Mover)) count:4)) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (and (<= 13 (count at:(mapEntry Mover))) (!= 1 (value Player Mover))) (or {(move Select (from (mapEntry Mover)) (then (and (sow skipIf:(or (= (to) (mapEntry P1)) (= (to) (mapEntry P2)))) (set Value Mover 1))))} (then (forEach Site (difference (sites Next) (mapEntry Next)) (if (or (= 2 (count at:(site))) (= 3 (count at:(site)))) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site))))))) (move Select (from (difference (sites Mover) (mapEntry Mover)) if:(is Occupied (from))) (then (sow apply:(if (or (= 2 (count at:(to))) (= 3 (count at:(to)))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))))))))))} (end (if (no Moves Next) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x12 board. Starting position, from the left hand hole, for each player: 0-3-3-0-3-3-0-3-3-0-3-3 In the opening play, one player must sow two counters from the second hole from their right. The opponent then makes the same play from their row, or from the fourth hole from their right. When the final counter lands in an occupied hole, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. Players may now begin their move from any hole in their row, but only if it ends in an empty hole in their row or if it enters the opponent's row. If the final counter lands in an occupied hole in the opponent's row, these are picked up and sowing continues. If the final counter lands in an occupied hole in the player's row, the contents of the hole in the opponent's hole opposite it are captured. Sowing ends when a capture is made or when a counter falls into an empty hole.
(game "Intotoi" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "Opening1" (play (move Select (from 10) (then (sow count:2)))) (nextPhase "Opening2")) (phase "Opening2" (play (if (is Prev Mover) (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (!= 1 (count at:(to))) (moveAgain))))) (move Select (from (sites {13 15}) if:(> (count at:(from)) 0)) (then (sow count:2 apply:(if (!= 1 (count at:(to))) (moveAgain))))))) (nextPhase (not (is Next Mover)) "Play")) (phase "Play" (play (move Select (from (sites From (do (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow))) ifAfterwards:(or (and (= 1 (count at:(last To afterConsequence:True))) (is In (last To afterConsequence:True) (sites Mover))) (is In (last To afterConsequence:True) (sites Next))))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (is Next Mover) "Replay")) (phase "Replay" (play (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Play"))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x12 board. Starting position, from the left hand hole, for each player: 0-3-3-0-3-3-0-3-3-0-3-3 In the opening play, one player must sow two counters from the second hole from their right. The opponent then makes the same play from their row, or from the fourth hole from their right. When the final counter lands in an occupied hole, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. Players may now begin their move from any hole in their row, but only if it ends in an empty hole in their row or if it enters the opponent's row. If the final counter lands in an occupied hole in the opponent's row, these are picked up and sowing continues. If the final counter lands in an occupied hole in the player's row, the contents of the hole in the opponent's hole opposite it are captured. Sowing ends when a capture is made or when a counter falls into an empty hole.
(game "Intotoi" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "Opening1" (play (move Select (from 10) (then (sow count:2)))) (nextPhase "Opening2")) (phase "Opening2" (play (if (is Prev Mover) (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (!= 1 (count at:(to))) (moveAgain))))) (move Select (from (sites {13 15}) if:(> (count at:(from)) 0)) (then (sow count:2 apply:(if (!= 1 (count at:(to))) (moveAgain))))))) (nextPhase (not (is Next Mover)) "Play")) (phase "Play" (play (move Select (from (sites From (do (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow))) ifAfterwards:(or (and (= 1 (count at:(last To afterConsequence:True))) (is In (last To afterConsequence:True) (sites Mover))) (is In (last To afterConsequence:True) (sites Next))))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (is Next Mover) "Replay")) (phase "Replay" (play (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Play"))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x12 board. Starting position, from the left hand hole, for each player: 0-3-3-0-3-3-0-3-3-0-3-3 In the opening play, one player must sow two counters from the second hole from their right. The opponent then makes the same play from their row, or from the fourth hole from their right. When the final counter lands in an occupied hole, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. Players may now begin their move from any hole in their row, but only if it ends in an empty hole in their row or if it enters the opponent's row. If the final counter lands in an occupied hole in the opponent's row, these are picked up and sowing continues. If the final counter lands in an occupied hole in the player's row, the contents of the hole in the opponent's hole opposite it are captured. Sowing ends when a capture is made or when a counter falls into an empty hole.
(game "Intotoi" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "Opening1" (play (move Select (from 10) (then (sow count:2)))) (nextPhase "Opening2")) (phase "Opening2" (play (if (is Prev Mover) (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (!= 1 (count at:(to))) (moveAgain))))) (move Select (from (sites {13 15}) if:(> (count at:(from)) 0)) (then (sow count:2 apply:(if (!= 1 (count at:(to))) (moveAgain))))))) (nextPhase (not (is Next Mover)) "Play")) (phase "Play" (play (move Select (from (sites From (do (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow))) ifAfterwards:(or (and (= 1 (count at:(last To afterConsequence:True))) (is In (last To afterConsequence:True) (sites Mover))) (is In (last To afterConsequence:True) (sites Next))))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (is Next Mover) "Replay")) (phase "Replay" (play (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Play"))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters per hole. Each player's rightmost hole is their "hogon," from which they cannot sow, except they must when it reaches fourteen counters. Sowing occurs in an anti-clockwise direction. Sowing from a hole with a single counter is forbidden. When the older player has only single counters in their regular holes, they pass. When the younger player has only single counters in their regular holes, they sow from their hogon. When a player must sow from their hogon and the opponent's holes only contain single counters, the player picks these up and sows them along with the contents of the hogon. When one player only has single counters in their row, the opponent wins. Each row has 6 holes. Each hole has initially 4 seeds.
(game "Koro" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (map "Hogon" {(pair P1 5) (pair P2 6)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) (play (if (<= 14 (count at:(mapEntry "Hogon" Mover))) (move Select (from (mapEntry "Hogon" Mover)) (then (sow))) (if (all Sites (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(>= 1 (count at:(site)))) (if (is Mover P1) (move Pass) (do (if (all Sites (difference (sites Next) (mapEntry "Hogon" Next)) if:(>= 1 (count at:(site)))) (forEach Site (difference (sites Next) (mapEntry "Hogon" Next)) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry "Hogon" Mover)))))) next:(move Select (from (mapEntry "Hogon" Mover) if:(< 1 (count at:(from)))) (then (sow))))) (move Select (from (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(< 1 (count at:(from)))) (then (sow)))))) (end (forEach Player if:(all Sites (sites Player) if:(>= 1 (count at:(site)))) (result Player Loss))))) 
2x6 board. Four counters per hole. Each player's rightmost hole is their "hogon," from which they cannot sow, except they must when it reaches fourteen counters. Sowing occurs in an anti-clockwise direction. Sowing from a hole with a single counter is forbidden. When the older player has only single counters in their regular holes, they pass. When the younger player has only single counters in their regular holes, they sow from their hogon. When a player must sow from their hogon and the opponent's holes only contain single counters, the player picks these up and sows them along with the contents of the hogon. When one player only has single counters in their row, the opponent wins. Each row has 5 holes. Each hole has initially 5 seeds.
(game "Koro" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (map "Hogon" {(pair P1 4) (pair P2 5)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 5 to:(sites Track))) (play (if (<= 15 (count at:(mapEntry "Hogon" Mover))) (move Select (from (mapEntry "Hogon" Mover)) (then (sow))) (if (all Sites (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(>= 1 (count at:(site)))) (if (is Mover P1) (move Pass) (do (if (all Sites (difference (sites Next) (mapEntry "Hogon" Next)) if:(>= 1 (count at:(site)))) (forEach Site (difference (sites Next) (mapEntry "Hogon" Next)) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry "Hogon" Mover)))))) next:(move Select (from (mapEntry "Hogon" Mover) if:(< 1 (count at:(from)))) (then (sow))))) (move Select (from (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(< 1 (count at:(from)))) (then (sow)))))) (end (forEach Player if:(all Sites (sites Player) if:(>= 1 (count at:(site)))) (result Player Loss))))) 
2x6 board. Four counters per hole. Each player's rightmost hole is their "hogon," from which they cannot sow, except they must when it reaches fourteen counters. Sowing occurs in an anti-clockwise direction. Sowing from a hole with a single counter is forbidden. When the older player has only single counters in their regular holes, they pass. When the younger player has only single counters in their regular holes, they sow from their hogon. When a player must sow from their hogon and the opponent's holes only contain single counters, the player picks these up and sows them along with the contents of the hogon. When one player only has single counters in their row, the opponent wins. Each row has 6 holes. Each hole has initially 6 seeds.
(game "Koro" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (map "Hogon" {(pair P1 5) (pair P2 6)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 6 to:(sites Track))) (play (if (<= 16 (count at:(mapEntry "Hogon" Mover))) (move Select (from (mapEntry "Hogon" Mover)) (then (sow))) (if (all Sites (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(>= 1 (count at:(site)))) (if (is Mover P1) (move Pass) (do (if (all Sites (difference (sites Next) (mapEntry "Hogon" Next)) if:(>= 1 (count at:(site)))) (forEach Site (difference (sites Next) (mapEntry "Hogon" Next)) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry "Hogon" Mover)))))) next:(move Select (from (mapEntry "Hogon" Mover) if:(< 1 (count at:(from)))) (then (sow))))) (move Select (from (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(< 1 (count at:(from)))) (then (sow)))))) (end (forEach Player if:(all Sites (sites Player) if:(>= 1 (count at:(site)))) (result Player Loss))))) 
2x6, 8, or 12 holes. Four counters in each hole. Play begins from a player's righthand hole and counters are sown clockwise. After this, a player may begin sowing from any hole in their row. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. The player with the most counters wins. Each player has 6 holes.
(game "Leyla Gobale (Somaliland)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (or {(move Select (from (if (= 0 (count Moves)) (sites {5}) (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover))) if:(and (is Occupied (from)) (= 0 (state at:(from))))) (then (sow apply:(if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover)) (if (!= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (and {(fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (to)) count:1) (set State at:(to) (mover)) (set State at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)) (mover))})))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites P1) if:(or (!= 0 (state at:(site))) (is Empty (site)))) (all Sites (sites P2) if:(or (!= 0 (state at:(site))) (is Empty (site)))))) (and {(forEach Site (sites P1) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (= (state at:(site)) P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (if (= (state at:(site)) P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6, 8, or 12 holes. Four counters in each hole. Play begins from a player's righthand hole and counters are sown clockwise. After this, a player may begin sowing from any hole in their row. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. The player with the most counters wins. Each player has 8 holes.
(game "Leyla Gobale (Somaliland)" (players 2) (equipment {(mancalaBoard 2 8 store:None (track "Track" "7,W,N,E" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (or {(move Select (from (if (= 0 (count Moves)) (sites {5}) (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover))) if:(and (is Occupied (from)) (= 0 (state at:(from))))) (then (sow apply:(if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover)) (if (!= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (and {(fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (to)) count:1) (set State at:(to) (mover)) (set State at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)) (mover))})))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites P1) if:(or (!= 0 (state at:(site))) (is Empty (site)))) (all Sites (sites P2) if:(or (!= 0 (state at:(site))) (is Empty (site)))))) (and {(forEach Site (sites P1) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (= (state at:(site)) P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (if (= (state at:(site)) P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6, 8, or 12 holes. Four counters in each hole. Play begins from a player's righthand hole and counters are sown clockwise. After this, a player may begin sowing from any hole in their row. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. The player with the most counters wins. Each player has 12 holes.
(game "Leyla Gobale (Somaliland)" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "11,W,N,E" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (or {(move Select (from (if (= 0 (count Moves)) (sites {5}) (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover))) if:(and (is Occupied (from)) (= 0 (state at:(from))))) (then (sow apply:(if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover)) (if (!= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (and {(fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (to)) count:1) (set State at:(to) (mover)) (set State at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)) (mover))})))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites P1) if:(or (!= 0 (state at:(site))) (is Empty (site)))) (all Sites (sites P2) if:(or (!= 0 (state at:(site))) (is Empty (site)))))) (and {(forEach Site (sites P1) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (= (state at:(site)) P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (if (= (state at:(site)) P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x7 board. Four counters per hole. The first player takes all of the counters from one of their holes. If they take from the central hole, they can be placed in any other hole on the board. If they are from any other hole, they can be placed in any hole except the opposite hole on the opponent's side. Once both players have made this initial move, the main phase of the game begins. Players alternate turns taking counters from one of the holes on their side of the board and sowing them. Groups of four counters are always sown. Play can occur in a clockwise or anti-clockwise direction. Players sow four counters at a time; that is, placing four counters in each hole. When the final four counters land in an empty hole in the player's row, any counters in the opponent's opposite hole are captured, and the player may sow again from another hole. Play continues until all of the counters have been captured, and the player with the most counters wins.
(game "Luuth" (players 2) (equipment {(mancalaBoard 2 7 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (sites Mover)) (to (if (is In (from) (sites Centre)) (difference (sites Board) (from)) (difference (sites Board) (sites {(from) (if (is Mover P1) (+ (from) 7) (- (from) 7))})))) count:(count at:(from)))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))))))} (end (if (= 4 (count Pieces All in:(sites Board))) (byScore {(score P1 (+ (count in:(sites Mover)) (count Cell at:(handSite P1)))) (score P2 (+ (count in:(sites Mover)) (count Cell at:(handSite P2))))}))))) 
2x7 board. Four counters per hole. The first player takes all of the counters from one of their holes. If they take from the central hole, they can be placed in any other hole on the board. If they are from any other hole, they can be placed in any hole except the opposite hole on the opponent's side. Once both players have made this initial move, the main phase of the game begins. Players alternate turns taking counters from one of the holes on their side of the board and sowing them. Groups of four counters are always sown. Play can occur in a clockwise or anti-clockwise direction. Players sow four counters at a time; that is, placing four counters in each hole. When the final four counters land in an empty hole in the player's row, any counters in the opponent's opposite hole are captured, and the player may sow again from another hole. Play continues until all of the counters have been captured, and the player with the most counters wins.
(game "Luuth" (players 2) (equipment {(mancalaBoard 2 7 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (sites Mover)) (to (if (is In (from) (sites Centre)) (difference (sites Board) (from)) (difference (sites Board) (sites {(from) (if (is Mover P1) (+ (from) 7) (- (from) 7))})))) count:(count at:(from)))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))))))} (end (if (= 4 (count Pieces All in:(sites Board))) (byScore {(score P1 (+ (count in:(sites Mover)) (count Cell at:(handSite P1)))) (score P2 (+ (count in:(sites Mover)) (count Cell at:(handSite P2))))}))))) 
2x7 board. Four counters per hole. The first player takes all of the counters from one of their holes. If they take from the central hole, they can be placed in any other hole on the board. If they are from any other hole, they can be placed in any hole except the opposite hole on the opponent's side. Once both players have made this initial move, the main phase of the game begins. Players alternate turns taking counters from one of the holes on their side of the board and sowing them. Groups of four counters are always sown. Play can occur in a clockwise or anti-clockwise direction. Players sow four counters at a time; that is, placing four counters in each hole. When the final four counters land in an empty hole in the player's row, any counters in the opponent's opposite hole are captured, and the player may sow again from another hole. Play continues until all of the counters have been captured, and the player with the most counters wins.
(game "Luuth" (players 2) (equipment {(mancalaBoard 2 7 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (sites Mover)) (to (if (is In (from) (sites Centre)) (difference (sites Board) (from)) (difference (sites Board) (sites {(from) (if (is Mover P1) (+ (from) 7) (- (from) 7))})))) count:(count at:(from)))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))))))} (end (if (= 4 (count Pieces All in:(sites Board))) (byScore {(score P1 (+ (count in:(sites Mover)) (count Cell at:(handSite P1)))) (score P2 (+ (count in:(sites Mover)) (count Cell at:(handSite P2))))}))))) 
2x7 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins from one of the holes in the player's row. When the final counter lands in an occupied hole, these are picked up and sowing continues. If the occupied hole has three counters (four including the final counter from the sowing), these are captured. Then, the player picks up the counters in the next hole after the one from which the capture was made and continues sowing from there. When the final counter lands into an empty hole the turn ends. The game ends when one player no longer has any counters on their side of the board. The opponent then captures the remaining counters on the board. A new game begins, with each player filling holes with the counters they captured, four to each hole. The player now controls as many holes as they can fill with counters. Play begins with the player who played second in the previous game. Subsequent games are played until one player captures all of the holes, becoming the winner.
(game "Motiq" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow apply:(if (= 4 (count at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (if (is Occupied (trackSite Move from:(to) steps:1)) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) steps:1))))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 4 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Board) (sites Mover)) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x7 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins from one of the holes in the player's row. When the final counter lands in an occupied hole, these are picked up and sowing continues. If the occupied hole has three counters (four including the final counter from the sowing), these are captured. Then, the player picks up the counters in the next hole after the one from which the capture was made and continues sowing from there. When the final counter lands into an empty hole the turn ends. The game ends when one player no longer has any counters on their side of the board. The opponent then captures the remaining counters on the board. A new game begins, with each player filling holes with the counters they captured, four to each hole. The player now controls as many holes as they can fill with counters. Play begins with the player who played second in the previous game. Subsequent games are played until one player captures all of the holes, becoming the winner.
(game "Motiq" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow apply:(if (= 4 (count at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (if (is Occupied (trackSite Move from:(to) steps:1)) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) steps:1))))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 4 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Board) (sites Mover)) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x7 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins from one of the holes in the player's row. When the final counter lands in an occupied hole, these are picked up and sowing continues. If the occupied hole has three counters (four including the final counter from the sowing), these are captured. Then, the player picks up the counters in the next hole after the one from which the capture was made and continues sowing from there. When the final counter lands into an empty hole the turn ends. The game ends when one player no longer has any counters on their side of the board. The opponent then captures the remaining counters on the board. A new game begins, with each player filling holes with the counters they captured, four to each hole. The player now controls as many holes as they can fill with counters. Play begins with the player who played second in the previous game. Subsequent games are played until one player captures all of the holes, becoming the winner.
(game "Motiq" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow apply:(if (= 4 (count at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (if (is Occupied (trackSite Move from:(to) steps:1)) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) steps:1))))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 4 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Board) (sites Mover)) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x10-20 board, 10 most common. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-1-0-0-0-0-0-0-0-0-0. Boards have even numbers of holes, and the farthest left and farthest right holes are eliminated in succession from this opening arrangement to make smaller boards. The challenger concedes the first move. Opening phase: Player 1 removes the counters in the opponent's final four holes with counters and conceals them from the opponent. Player 2 removes the same counters, except leaving the single counter in the opponent's final hole with counters. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and the opposite hole contains one, three, or five counters, theses are taken and added to the concealed store. In place of a move, a player may add some or all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing continues from the leftmost hole rather than continuing into the opponent's rows. Each row has 10 holes.
(game "Okwe (Nigeria)" (players 2) (equipment {(mancalaBoard 2 10 store:None {(track "Track" "0,E,N,W" loop:True) (track "TrackSpecialHome1" "0,E" loop:True P1) (track "TrackSpecialHome2" "19,W" loop:True P2)}) (regions "OpeningRegion" P1 (sites {14 15 16 17})) (regions "OpeningRegion" P2 (sites {2 3 4})) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 (- (* 10 2) 1))}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(set Count 5 to:(sites {0 1 4 19 18 15})) (set Count 1 to:(sites {2 3 5 17 16 14}))}) phases:{(phase "Opening" (play (move (from (sites Mover "OpeningRegion") if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)))) (nextPhase (all Sites (union (sites P1 "OpeningRegion") (sites P2 "OpeningRegion")) if:(is Empty (site))) "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover "Home") if:(is Occupied (from))) (then (sow "Track" apply:(if (and (is In (to) (sites Next "Home")) (or {(= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10)))) (= 5 (count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10))))})) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10))))) origin:(< 1 (count at:(from)))))) (if (is Occupied Cell (handSite Mover)) (do (set Var "NumToSow" (count Cell at:(handSite Mover))) next:(move (from (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(count Cell at:(handSite Mover)) (then (and (sow count:(var "NumToSow") "TrackSpecialHome" owner:(mover) origin:True) (set Var "NumToSow" 0)))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (is Empty (handSite P1)) (result P2 Win)) (if (is Empty (handSite P2)) (result P1 Win))})))) 
2x10-20 board, 10 most common. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-1-0-0-0-0-0-0-0-0-0. Boards have even numbers of holes, and the farthest left and farthest right holes are eliminated in succession from this opening arrangement to make smaller boards. The challenger concedes the first move. Opening phase: Player 1 removes the counters in the opponent's final four holes with counters and conceals them from the opponent. Player 2 removes the same counters, except leaving the single counter in the opponent's final hole with counters. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and the opposite hole contains one, three, or five counters, theses are taken and added to the concealed store. In place of a move, a player may add some or all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing continues from the leftmost hole rather than continuing into the opponent's rows. Each row has 12 holes.
(game "Okwe (Nigeria)" (players 2) (equipment {(mancalaBoard 2 12 store:None {(track "Track" "0,E,N,W" loop:True) (track "TrackSpecialHome1" "0,E" loop:True P1) (track "TrackSpecialHome2" "23,W" loop:True P2)}) (regions "OpeningRegion" P1 (sites {17 18 19 20})) (regions "OpeningRegion" P2 (sites {5 4 3})) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 (- (* 12 2) 1))}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(set Count 5 to:(sites {0 1 2 5 23 22 21 18})) (set Count 1 to:(sites {3 4 6 20 19 17}))}) phases:{(phase "Opening" (play (move (from (sites Mover "OpeningRegion") if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)))) (nextPhase (all Sites (union (sites P1 "OpeningRegion") (sites P2 "OpeningRegion")) if:(is Empty (site))) "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover "Home") if:(is Occupied (from))) (then (sow "Track" apply:(if (and (is In (to) (sites Next "Home")) (or {(= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 12) (- (to) 12)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 12) (- (to) 12)))) (= 5 (count at:(if (is In (to) (sites Bottom)) (+ (to) 12) (- (to) 12))))})) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 12) (- (to) 12))))) origin:(< 1 (count at:(from)))))) (if (is Occupied Cell (handSite Mover)) (do (set Var "NumToSow" (count Cell at:(handSite Mover))) next:(move (from (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(count Cell at:(handSite Mover)) (then (and (sow count:(var "NumToSow") "TrackSpecialHome" owner:(mover) origin:True) (set Var "NumToSow" 0)))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (is Empty (handSite P1)) (result P2 Win)) (if (is Empty (handSite P2)) (result P1 Win))})))) 
2x10-20 board, 10 most common. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-1-0-0-0-0-0-0-0-0-0. Boards have even numbers of holes, and the farthest left and farthest right holes are eliminated in succession from this opening arrangement to make smaller boards. The challenger concedes the first move. Opening phase: Player 1 removes the counters in the opponent's final four holes with counters and conceals them from the opponent. Player 2 removes the same counters, except leaving the single counter in the opponent's final hole with counters. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and the opposite hole contains one, three, or five counters, theses are taken and added to the concealed store. In place of a move, a player may add some or all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing continues from the leftmost hole rather than continuing into the opponent's rows. Each row has 14 holes.
(game "Okwe (Nigeria)" (players 2) (equipment {(mancalaBoard 2 14 store:None {(track "Track" "0,E,N,W" loop:True) (track "TrackSpecialHome1" "0,E" loop:True P1) (track "TrackSpecialHome2" "27,W" loop:True P2)}) (regions "OpeningRegion" P1 (sites {20 21 22 23})) (regions "OpeningRegion" P2 (sites {6 5 4})) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 (- (* 14 2) 1))}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(set Count 5 to:(sites {0 1 2 3 6 27 26 25 24 21})) (set Count 1 to:(sites {4 5 7 22 23 20}))}) phases:{(phase "Opening" (play (move (from (sites Mover "OpeningRegion") if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)))) (nextPhase (all Sites (union (sites P1 "OpeningRegion") (sites P2 "OpeningRegion")) if:(is Empty (site))) "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover "Home") if:(is Occupied (from))) (then (sow "Track" apply:(if (and (is In (to) (sites Next "Home")) (or {(= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 14) (- (to) 14)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 14) (- (to) 14)))) (= 5 (count at:(if (is In (to) (sites Bottom)) (+ (to) 14) (- (to) 14))))})) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 14) (- (to) 14))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 14) (- (to) 14))))) origin:(< 1 (count at:(from)))))) (if (is Occupied Cell (handSite Mover)) (do (set Var "NumToSow" (count Cell at:(handSite Mover))) next:(move (from (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(count Cell at:(handSite Mover)) (then (and (sow count:(var "NumToSow") "TrackSpecialHome" owner:(mover) origin:True) (set Var "NumToSow" 0)))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (is Empty (handSite P1)) (result P2 Win)) (if (is Empty (handSite P2)) (result P1 Win))})))) 
2x5 board. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counters of a sowing lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter lands in a hole, and the next hole, from which sowing would normally continue, is empty, the player captures any counters in the next hole after the empty one. and the turn ends. Play continues until no more captures are possible, and the player who captured the most counters wins.
(game "Pachgarhwa" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(value Pending)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:True apply:(if (is Occupied (trackSite Move from:(to) steps:1)) (and {(set Pending (to)) (fromTo (from (trackSite Move from:(to) steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:1))) (moveAgain)}) (if (is Occupied (trackSite Move from:(to) steps:2)) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:2))))))))) (end (if (= 1 (count in:(sites Board))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x5 board. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counters of a sowing lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter lands in a hole, and the next hole, from which sowing would normally continue, is empty, the player captures any counters in the next hole after the empty one. and the turn ends. Play continues until no more captures are possible, and the player who captured the most counters wins.
(game "Pachgarhwa" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(value Pending)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:True apply:(if (is Occupied (trackSite Move from:(to) steps:1)) (and {(set Pending (to)) (fromTo (from (trackSite Move from:(to) steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:1))) (moveAgain)}) (if (is Occupied (trackSite Move from:(to) steps:2)) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:2))))))))) (end (if (= 1 (count in:(sites Board))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x5 board. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counters of a sowing lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter lands in a hole, and the next hole, from which sowing would normally continue, is empty, the player captures any counters in the next hole after the empty one. and the turn ends. Play continues until no more captures are possible, and the player who captured the most counters wins.
(game "Pachgarhwa" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(value Pending)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:True apply:(if (is Occupied (trackSite Move from:(to) steps:1)) (and {(set Pending (to)) (fromTo (from (trackSite Move from:(to) steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:1))) (moveAgain)}) (if (is Occupied (trackSite Move from:(to) steps:2)) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:2))))))))) (end (if (= 1 (count in:(sites Board))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. The player with counters remaining in their holes captures these counters. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Puhulmutu" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" (play (or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 1)))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 2)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. The player with counters remaining in their holes captures these counters. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Puhulmutu" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" (play (or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 1)))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 2)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. The player with counters remaining in their holes captures these counters. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Puhulmutu" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" (play (or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 1)))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 2)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
2x6 board with two stores. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole in the opponent's row containing one or two counters, thus making it contain two or three counters, they are captured. Any other holes in the opponent's row which also contain two or three counters, in an unbroken sequence preceding the hole where the first capture was made, are captured. When a player sows around the board, the hole from which the coutners were taken is left empty. Play ends when one player cannot play from their row, and players capture any remaining counters in their holes. The player with the most counters wins. The seeds have a normal size.
(game "Shono" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board with two stores. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole in the opponent's row containing one or two counters, thus making it contain two or three counters, they are captured. Any other holes in the opponent's row which also contain two or three counters, in an unbroken sequence preceding the hole where the first capture was made, are captured. When a player sows around the board, the hole from which the coutners were taken is left empty. Play ends when one player cannot play from their row, and players capture any remaining counters in their holes. The player with the most counters wins. The seeds are small.
(game "Shono" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board with two stores. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole in the opponent's row containing one or two counters, thus making it contain two or three counters, they are captured. Any other holes in the opponent's row which also contain two or three counters, in an unbroken sequence preceding the hole where the first capture was made, are captured. When a player sows around the board, the hole from which the coutners were taken is left empty. Play ends when one player cannot play from their row, and players capture any remaining counters in their holes. The player with the most counters wins. The seeds have a normal size.
(game "Shono" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x12 board. Beginning from the leftmost hole closest to a player and proceeding in an anti-clockwise direction, the opening arrangement of counters is an alternating pattern of one empty hole, followed by two holes with three counters each. The first move for each player must be from an occupied hole in the right half of their row. Players sow in an anti-clockwise direction, but if the final counter is about to fall in a hole in the player's own row, it is instead placed in the first hole in the opponent's row. After this, players may sow from any hole in their row, provided that the final counter does not fall into an occupied hole in their row. When the final counter of a sowing lands in an occupied hole in the opponent's row, the counters there are picked up and sowing continues. When this happens, the player is allowed to drop the final counter into an occupied hole in their row, which would then be picked up and sowing would continue as before. When the final counter falls into an empty hole in the player's row, any counters in the opponent's hole opposite are captured. When the final counter falls into an empty hole in the opponent's row, the turn ends. The player who captures all of the opponent's counters wins. Players typically play to achieve five consecutive wins.
(game "Tapata" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "TrackCCW" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "Right Half" P1 (intersection (sites Bottom) (expand (sites Right) steps:5))) (regions "Right Half" P2 (intersection (sites Top) (expand (sites Left) steps:5))) (map {(pair P1 0) (pair P2 23)})}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "FirstMove" (play (move Select (from (difference (sites Mover "Right Half") (sites Empty))) (then (sow apply:(if (is In (to) (sites Mover "Home")) (fromTo (from (to)) (to (mapEntry Next)))))))) (nextPhase Mover "Play")) (phase "Play" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(and (> (count at:(from)) 0) (or (is Prev Mover) (and (not (is Prev Mover)) (not (and (is In (trackSite Move from:(from) steps:(count at:(from))) (sites Mover "Home")) (!= 0 (count at:(trackSite Move from:(from) steps:(count at:(from))))))))))) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (!= 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (is In (to) (sites Mover "Home"))) (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))))))))))} (end (forEach NonMover if:(= (count in:(sites Player "Home")) 0) (result Player Loss))))) 
2x12 board. Beginning from the leftmost hole closest to a player and proceeding in an anti-clockwise direction, the opening arrangement of counters is an alternating pattern of one empty hole, followed by two holes with three counters each. The first move for each player must be from an occupied hole in the right half of their row. Players sow in an anti-clockwise direction, but if the final counter is about to fall in a hole in the player's own row, it is instead placed in the first hole in the opponent's row. After this, players may sow from any hole in their row, provided that the final counter does not fall into an occupied hole in their row. When the final counter of a sowing lands in an occupied hole in the opponent's row, the counters there are picked up and sowing continues. When this happens, the player is allowed to drop the final counter into an occupied hole in their row, which would then be picked up and sowing would continue as before. When the final counter falls into an empty hole in the player's row, any counters in the opponent's hole opposite are captured. When the final counter falls into an empty hole in the opponent's row, the turn ends. The player who captures all of the opponent's counters wins. Players typically play to achieve five consecutive wins.
(game "Tapata" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "TrackCCW" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "Right Half" P1 (intersection (sites Bottom) (expand (sites Right) steps:5))) (regions "Right Half" P2 (intersection (sites Top) (expand (sites Left) steps:5))) (map {(pair P1 0) (pair P2 23)})}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "FirstMove" (play (move Select (from (difference (sites Mover "Right Half") (sites Empty))) (then (sow apply:(if (is In (to) (sites Mover "Home")) (fromTo (from (to)) (to (mapEntry Next)))))))) (nextPhase Mover "Play")) (phase "Play" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(and (> (count at:(from)) 0) (or (is Prev Mover) (and (not (is Prev Mover)) (not (and (is In (trackSite Move from:(from) steps:(count at:(from))) (sites Mover "Home")) (!= 0 (count at:(trackSite Move from:(from) steps:(count at:(from))))))))))) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (!= 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (is In (to) (sites Mover "Home"))) (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))))))))))} (end (forEach NonMover if:(= (count in:(sites Player "Home")) 0) (result Player Loss))))) 
2x12 board. Beginning from the leftmost hole closest to a player and proceeding in an anti-clockwise direction, the opening arrangement of counters is an alternating pattern of one empty hole, followed by two holes with three counters each. The first move for each player must be from an occupied hole in the right half of their row. Players sow in an anti-clockwise direction, but if the final counter is about to fall in a hole in the player's own row, it is instead placed in the first hole in the opponent's row. After this, players may sow from any hole in their row, provided that the final counter does not fall into an occupied hole in their row. When the final counter of a sowing lands in an occupied hole in the opponent's row, the counters there are picked up and sowing continues. When this happens, the player is allowed to drop the final counter into an occupied hole in their row, which would then be picked up and sowing would continue as before. When the final counter falls into an empty hole in the player's row, any counters in the opponent's hole opposite are captured. When the final counter falls into an empty hole in the opponent's row, the turn ends. The player who captures all of the opponent's counters wins. Players typically play to achieve five consecutive wins.
(game "Tapata" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "TrackCCW" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "Right Half" P1 (intersection (sites Bottom) (expand (sites Right) steps:5))) (regions "Right Half" P2 (intersection (sites Top) (expand (sites Left) steps:5))) (map {(pair P1 0) (pair P2 23)})}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "FirstMove" (play (move Select (from (difference (sites Mover "Right Half") (sites Empty))) (then (sow apply:(if (is In (to) (sites Mover "Home")) (fromTo (from (to)) (to (mapEntry Next)))))))) (nextPhase Mover "Play")) (phase "Play" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(and (> (count at:(from)) 0) (or (is Prev Mover) (and (not (is Prev Mover)) (not (and (is In (trackSite Move from:(from) steps:(count at:(from))) (sites Mover "Home")) (!= 0 (count at:(trackSite Move from:(from) steps:(count at:(from))))))))))) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (!= 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (is In (to) (sites Mover "Home"))) (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))))))))))} (end (forEach NonMover if:(= (count in:(sites Player "Home")) 0) (result Player Loss))))) 
2x6 board. Six counters in each hole. Sowing occurs from any of the holes in the player's row, and continues in a clockwise direction. If the final counter lands in a hole in the player's row containing three counters, four with the addition of the final counter, these are captured. Play continues until one player cannot move or the board position repeats. When one player cannot move, the other player captures the remaining counters. The player with the most counters wins. The game ends if no moves or a repeating state is detected.
(game "Unnee Tugalluulax" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 4) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))))) (end (if (or (no Moves Mover) (is Cycle)) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Six counters in each hole. Sowing occurs from any of the holes in the player's row, and continues in a clockwise direction. If the final counter lands in a hole in the player's row containing three counters, four with the addition of the final counter, these are captured. Play continues until one player cannot move or the board position repeats. When one player cannot move, the other player captures the remaining counters. The player with the most counters wins. The game ends if no moves.
(game "Unnee Tugalluulax" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 4) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Six counters in each hole. Sowing occurs from any of the holes in the player's row, and continues in a clockwise direction. If the final counter lands in a hole in the player's row containing three counters, four with the addition of the final counter, these are captured. Play continues until one player cannot move or the board position repeats. When one player cannot move, the other player captures the remaining counters. The player with the most counters wins. The game ends if no moves or a repeating state is detected.
(game "Unnee Tugalluulax" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 4) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))))) (end (if (or (no Moves Mover) (is Cycle)) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board with a store on either end. Four counters in each hole. Players take turns sowing in an anti-clockwise direction from one of the holes in their row. Counters are captured when the final counter of a sowing is dropped into a hole in the opponent's row containing one or two counters, making it contain two or three counters. If the previous hole also contains two or three counters, they are also captured, in an unbroken line until a hole with a different number of counters is reached. If, while sowing, the hole from which the sowing originated is reached, this hole is skipped and sowing continues. If a player has no counters in their holes, the opponent must play so as to place counters in their row. The player who captures 25 coutners first wins.
(game "Uril" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (forEach Player if:(>= (count at:(mapEntry Player)) 25) (result Player Win))))) 
2x6 board with a store on either end. Four counters in each hole. Players take turns sowing in an anti-clockwise direction from one of the holes in their row. Counters are captured when the final counter of a sowing is dropped into a hole in the opponent's row containing one or two counters, making it contain two or three counters. If the previous hole also contains two or three counters, they are also captured, in an unbroken line until a hole with a different number of counters is reached. If, while sowing, the hole from which the sowing originated is reached, this hole is skipped and sowing continues. If a player has no counters in their holes, the opponent must play so as to place counters in their row. The player who captures 25 coutners first wins.
(game "Uril" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (forEach Player if:(>= (count at:(mapEntry Player)) 25) (result Player Win))))) 
2x6 board with a store on either end. Four counters in each hole. Players take turns sowing in an anti-clockwise direction from one of the holes in their row. Counters are captured when the final counter of a sowing is dropped into a hole in the opponent's row containing one or two counters, making it contain two or three counters. If the previous hole also contains two or three counters, they are also captured, in an unbroken line until a hole with a different number of counters is reached. If, while sowing, the hole from which the sowing originated is reached, this hole is skipped and sowing continues. If a player has no counters in their holes, the opponent must play so as to place counters in their row. The player who captures 25 coutners first wins.
(game "Uril" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (forEach Player if:(>= (count at:(mapEntry Player)) 25) (result Player Win))))) 
Two rows of six holes with two stores. Four counters in each hole. Players sow in an anti-clockwise direction from a hole in their row. Sowing ends when the last counter falls into a hole, making it contain four counters, which are taken. Sowing also ends when the last counter falls into an empty hole. Sowing continues in any other scenario by picking up the contents of the hole where the last counter was dropped and continuing to sow. The game ends when one player can no longer move. The remaining counters are taken by the last player that was able to move and put into the store. A new round begins: The winner of the previous round now owns seven holes - the six in his row and the next hole in the opponent's row. Player takes fours from the extra hole.
(game "Whyo" (players 2) (equipment {(mancalaBoard 2 6 (track "TrackCCW" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (= (score P1) 1) (if (is Mover P1) (union (sites Mover) (sites {12})) (difference (sites Mover) (sites {12}))) (if (= (score P2) 1) (if (is Mover P2) (union (sites Mover) (sites {1})) (difference (sites Mover) (sites {1}))) (sites Mover)))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (count at:(to)) 4) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< (count at:(to)) 1) (moveAgain))) (then (if (no Moves Next) (and (forEach Site (union (sites P1) (sites P2)) (if (> (count at:(site)) 0) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site)))) (then (and {(if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (addScore P2 1)) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (addScore P1 1)) (if (< (var) 0) (and {(forEach Site (sites Board) (if (> (count at:(site)) 0) (remove (site)))) (forEach Site (union (sites P1) (sites P2)) (add (piece (id "Seed" Shared)) (to (site)) count:4))}))}))) (set Var (+ (var) 1))))))))) (end (if (= (var) 1) (byScore))))) 
Two rows of six holes with two stores. Four counters in each hole. Players sow in an anti-clockwise direction from a hole in their row. Sowing ends when the last counter falls into a hole, making it contain four counters, which are taken. Sowing also ends when the last counter falls into an empty hole. Sowing continues in any other scenario by picking up the contents of the hole where the last counter was dropped and continuing to sow. The game ends when one player can no longer move. The remaining counters are taken by the last player that was able to move and put into the store. A new round begins: The winner of the previous round now owns seven holes - the six in his row and the next hole in the opponent's row. Player takes fours from the extra hole.
(game "Whyo" (players 2) (equipment {(mancalaBoard 2 6 (track "TrackCCW" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (= (score P1) 1) (if (is Mover P1) (union (sites Mover) (sites {12})) (difference (sites Mover) (sites {12}))) (if (= (score P2) 1) (if (is Mover P2) (union (sites Mover) (sites {1})) (difference (sites Mover) (sites {1}))) (sites Mover)))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (count at:(to)) 4) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< (count at:(to)) 1) (moveAgain))) (then (if (no Moves Next) (and (forEach Site (union (sites P1) (sites P2)) (if (> (count at:(site)) 0) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site)))) (then (and {(if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (addScore P2 1)) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (addScore P1 1)) (if (< (var) 0) (and {(forEach Site (sites Board) (if (> (count at:(site)) 0) (remove (site)))) (forEach Site (union (sites P1) (sites P2)) (add (piece (id "Seed" Shared)) (to (site)) count:4))}))}))) (set Var (+ (var) 1))))))))) (end (if (= (var) 1) (byScore))))) 
Two rows of six holes with two stores. Four counters in each hole. Players sow in an anti-clockwise direction from a hole in their row. Sowing ends when the last counter falls into a hole, making it contain four counters, which are taken. Sowing also ends when the last counter falls into an empty hole. Sowing continues in any other scenario by picking up the contents of the hole where the last counter was dropped and continuing to sow. The game ends when one player can no longer move. The remaining counters are taken by the last player that was able to move and put into the store. A new round begins: The winner of the previous round now owns seven holes - the six in his row and the next hole in the opponent's row. Player takes fours from the extra hole.
(game "Whyo" (players 2) (equipment {(mancalaBoard 2 6 (track "TrackCCW" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (= (score P1) 1) (if (is Mover P1) (union (sites Mover) (sites {12})) (difference (sites Mover) (sites {12}))) (if (= (score P2) 1) (if (is Mover P2) (union (sites Mover) (sites {1})) (difference (sites Mover) (sites {1}))) (sites Mover)))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (count at:(to)) 4) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< (count at:(to)) 1) (moveAgain))) (then (if (no Moves Next) (and (forEach Site (union (sites P1) (sites P2)) (if (> (count at:(site)) 0) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site)))) (then (and {(if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (addScore P2 1)) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (addScore P1 1)) (if (< (var) 0) (and {(forEach Site (sites Board) (if (> (count at:(site)) 0) (remove (site)))) (forEach Site (union (sites P1) (sites P2)) (add (piece (id "Seed" Shared)) (to (site)) count:4))}))}))) (set Var (+ (var) 1))))))))) (end (if (= (var) 1) (byScore))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible.
(game "Wouri" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= (count at:(site)) 4) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site))))))) (if (< 1 (count at:(to))) (moveAgain))) includeSelf:False))) ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1)))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible.
(game "Wouri" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= (count at:(site)) 4) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site))))))) (if (< 1 (count at:(to))) (moveAgain))) includeSelf:False))) ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1)))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible.
(game "Wouri" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= (count at:(site)) 4) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site))))))) (if (< 1 (count at:(to))) (moveAgain))) includeSelf:False))) ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1)))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
Each turn a player places a stone of their color on an empty hex. The placement is subject to the following restriction: After your placement you may not have a group containing more stones than the number of groups you have on the board. The first player unable to place a stone loses the game. A size 5 board is currently selected The standard goal is selected, which means that the first player unable to place loses.
(game "Bamboo" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(<= (max (results from:(sites Occupied by:Mover) to:1 (* 1 (size Group at:(from))))) (count Groups if:(= (who at:(to)) (mover)))))) (end (if (no Moves Next) (result Next Loss))))) 
Each turn a player places a stone of their color on an empty hex. The placement is subject to the following restriction: After your placement you may not have a group containing more stones than the number of groups you have on the board. The first player unable to place a stone loses the game. A size 4 board is currently selected The misere goal is selected, which means that the first player unable to place wins.
(game "Bamboo" (players 2) (equipment {(board (hex 4)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(<= (max (results from:(sites Occupied by:Mover) to:1 (* 1 (size Group at:(from))))) (count Groups if:(= (who at:(to)) (mover)))))) (end (if (no Moves Next) (result Next Win))))) 
Each turn a player places a stone of their color on an empty hex. The placement is subject to the following restriction: After your placement you may not have a group containing more stones than the number of groups you have on the board. The first player unable to place a stone loses the game. A size 6 board is currently selected The standard goal is selected, which means that the first player unable to place loses.
(game "Bamboo" (players 2) (equipment {(board (hex 6)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(<= (max (results from:(sites Occupied by:Mover) to:1 (* 1 (size Group at:(from))))) (count Groups if:(= (who at:(to)) (mover)))))) (end (if (no Moves Next) (result Next Loss))))) 
The 32 pieces are shuffled and randomly allocated face-down to squares on the board. The first player turns up a piece to begin the game. The color of that first uncovered piece is the color he or she will play in the game. The second player then makes a move, and the two alternate until the game is finished. There are three kinds of moves. A player may turn a piece face-up, move a piece, or capture an enemy piece. In some game variants, multiple captures may be made in one turn. Turning a piece face-up is a legal move if there are any face-down pieces on the board. Once revealed, a piece may move, capture, or be captured. A player may only move face-up pieces of their own color. Unlike Xiangqi, all pieces move identically: a piece may move only one square up, down, left, or right. A piece may never move onto a square that is already occupied unless such a move is a legal capture. A player may only capture with a face-up piece of their own color, and may only capture a face-up piece of the opposing color. In all captures, the captured piece is removed from the board and its square is occupied by the capturing piece. The pieces are ranked, forming a hierarchy with the general at the top and soldiers at the bottom. Only pieces of equal or lower rank may be captured, with one exception. For instance, a chariot may capture a horse, and the general may capture either, but a horse cannot capture a chariot, and neither can capture the general. The one exception concerns generals and soldiers: the general cannot capture soldiers, and soldiers can capture the general. In the Hong Kong version, the pieces are ranked in this order: General>Chariot>Horse>Cannon, Advisor>Minster>Soldier. This ranking reflects the approximate value of the corresponding pieces in Xiangqi (though the relative rank of horse and cannon is arguable). All pieces capture exactly as they move: one square up, down, left, or right. The game ends when a player cannot move, and that player is the loser. Most often, the game is lost because all of a player's pieces have been captured and so he has no pieces to move. However, it is possible for one player to surround all of the other player's remaining pieces in a manner that makes it impossible for them to move.
(game "Banqi" (players 2) (equipment {(board (rectangle 4 8)) (piece "Jiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ju" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ma" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Pao" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Shi" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Xiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Zu" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to))))))}) (rules (start {(place Random {"Zu1"} count:5 value:1) (place Random {"Zu2"} count:5 value:1) (place Random {"Pao1"} count:2 value:4) (place Random {"Pao2"} count:2 value:4) (place Random {"Ju1"} count:2 value:6) (place Random {"Ju2"} count:2 value:6) (place Random {"Ma1"} count:2 value:5) (place Random {"Ma2"} count:2 value:5) (place Random {"Xiang1"} count:2 value:2) (place Random {"Xiang2"} count:2 value:2) (place Random {"Shi1"} count:2 value:3) (place Random {"Shi2"} count:2 value:3) (place Random {"Jiang1"} count:1 value:7) (place Random {"Jiang2"} count:1 value:7) (set Hidden {What Who} (sites Board) to:P1) (set Hidden {What Who} (sites Board) to:P2)}) phases:{(phase "Opening" P1 (play (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2) (set NextPlayer (player (who at:(last To))))})))) (nextPhase Mover "Play")) (phase "Play" (play (or (forEach Piece) (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2)}))))))} (end (if (no Moves Next) (result Mover Win))))) 
The 32 pieces are shuffled and randomly allocated face-down to squares on the board. The first player turns up a piece to begin the game. The color of that first uncovered piece is the color he or she will play in the game. The second player then makes a move, and the two alternate until the game is finished. There are three kinds of moves. A player may turn a piece face-up, move a piece, or capture an enemy piece. In some game variants, multiple captures may be made in one turn. Turning a piece face-up is a legal move if there are any face-down pieces on the board. Once revealed, a piece may move, capture, or be captured. A player may only move face-up pieces of their own color. Unlike Xiangqi, all pieces move identically: a piece may move only one square up, down, left, or right. A piece may never move onto a square that is already occupied unless such a move is a legal capture. A player may only capture with a face-up piece of their own color, and may only capture a face-up piece of the opposing color. In all captures, the captured piece is removed from the board and its square is occupied by the capturing piece. The pieces are ranked, forming a hierarchy with the general at the top and soldiers at the bottom. Only pieces of equal or lower rank may be captured, with one exception. For instance, a chariot may capture a horse, and the general may capture either, but a horse cannot capture a chariot, and neither can capture the general. The one exception concerns generals and soldiers: the general cannot capture soldiers, and soldiers can capture the general. In the Hong Kong version, the pieces are ranked in this order: General>Chariot>Horse>Cannon, Advisor>Minster>Soldier. This ranking reflects the approximate value of the corresponding pieces in Xiangqi (though the relative rank of horse and cannon is arguable). All pieces capture exactly as they move: one square up, down, left, or right. The game ends when a player cannot move, and that player is the loser. Most often, the game is lost because all of a player's pieces have been captured and so he has no pieces to move. However, it is possible for one player to surround all of the other player's remaining pieces in a manner that makes it impossible for them to move.
(game "Banqi" (players 2) (equipment {(board (rectangle 4 8)) (piece "Jiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ju" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ma" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Pao" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Shi" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Xiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Zu" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to))))))}) (rules (start {(place Random {"Zu1"} count:5 value:1) (place Random {"Zu2"} count:5 value:1) (place Random {"Pao1"} count:2 value:4) (place Random {"Pao2"} count:2 value:4) (place Random {"Ju1"} count:2 value:6) (place Random {"Ju2"} count:2 value:6) (place Random {"Ma1"} count:2 value:5) (place Random {"Ma2"} count:2 value:5) (place Random {"Xiang1"} count:2 value:2) (place Random {"Xiang2"} count:2 value:2) (place Random {"Shi1"} count:2 value:3) (place Random {"Shi2"} count:2 value:3) (place Random {"Jiang1"} count:1 value:7) (place Random {"Jiang2"} count:1 value:7) (set Hidden {What Who} (sites Board) to:P1) (set Hidden {What Who} (sites Board) to:P2)}) phases:{(phase "Opening" P1 (play (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2) (set NextPlayer (player (who at:(last To))))})))) (nextPhase Mover "Play")) (phase "Play" (play (or (forEach Piece) (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2)}))))))} (end (if (no Moves Next) (result Mover Win))))) 
The 32 pieces are shuffled and randomly allocated face-down to squares on the board. The first player turns up a piece to begin the game. The color of that first uncovered piece is the color he or she will play in the game. The second player then makes a move, and the two alternate until the game is finished. There are three kinds of moves. A player may turn a piece face-up, move a piece, or capture an enemy piece. In some game variants, multiple captures may be made in one turn. Turning a piece face-up is a legal move if there are any face-down pieces on the board. Once revealed, a piece may move, capture, or be captured. A player may only move face-up pieces of their own color. Unlike Xiangqi, all pieces move identically: a piece may move only one square up, down, left, or right. A piece may never move onto a square that is already occupied unless such a move is a legal capture. A player may only capture with a face-up piece of their own color, and may only capture a face-up piece of the opposing color. In all captures, the captured piece is removed from the board and its square is occupied by the capturing piece. The pieces are ranked, forming a hierarchy with the general at the top and soldiers at the bottom. Only pieces of equal or lower rank may be captured, with one exception. For instance, a chariot may capture a horse, and the general may capture either, but a horse cannot capture a chariot, and neither can capture the general. The one exception concerns generals and soldiers: the general cannot capture soldiers, and soldiers can capture the general. In the Hong Kong version, the pieces are ranked in this order: General>Chariot>Horse>Cannon, Advisor>Minster>Soldier. This ranking reflects the approximate value of the corresponding pieces in Xiangqi (though the relative rank of horse and cannon is arguable). All pieces capture exactly as they move: one square up, down, left, or right. The game ends when a player cannot move, and that player is the loser. Most often, the game is lost because all of a player's pieces have been captured and so he has no pieces to move. However, it is possible for one player to surround all of the other player's remaining pieces in a manner that makes it impossible for them to move.
(game "Banqi" (players 2) (equipment {(board (rectangle 4 8)) (piece "Jiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ju" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ma" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Pao" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Shi" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Xiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Zu" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to))))))}) (rules (start {(place Random {"Zu1"} count:5 value:1) (place Random {"Zu2"} count:5 value:1) (place Random {"Pao1"} count:2 value:4) (place Random {"Pao2"} count:2 value:4) (place Random {"Ju1"} count:2 value:6) (place Random {"Ju2"} count:2 value:6) (place Random {"Ma1"} count:2 value:5) (place Random {"Ma2"} count:2 value:5) (place Random {"Xiang1"} count:2 value:2) (place Random {"Xiang2"} count:2 value:2) (place Random {"Shi1"} count:2 value:3) (place Random {"Shi2"} count:2 value:3) (place Random {"Jiang1"} count:1 value:7) (place Random {"Jiang2"} count:1 value:7) (set Hidden {What Who} (sites Board) to:P1) (set Hidden {What Who} (sites Board) to:P2)}) phases:{(phase "Opening" P1 (play (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2) (set NextPlayer (player (who at:(last To))))})))) (nextPhase Mover "Play")) (phase "Play" (play (or (forEach Piece) (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2)}))))))} (end (if (no Moves Next) (result Mover Win))))) 
Played on a hexagonal board with five spaces per side. Players take turns placing stones on an empty space. The stone must be adjacent to the last stone played but cannot be adjacent to any other. The last player to be able to make a legal move wins.
(game "Blue Nile" (players 2) (equipment {(board (hex 5)) (piece "Marker" Neutral)}) (rules phases:{(phase "start" P1 (play (move Add (piece (id "Marker0")) (to (sites Empty)))) (nextPhase "play")) (phase "play" (play (move Add (piece "Marker0") (to (sites Around (last To) if:(and (is Empty (to)) (= (count Sites in:(difference (sites Around (to) if:(not (is In (to) (sites Empty)))) (last To))) 0)))))))} (end (if (no Moves Next) (result Next Loss))))) 
Played on a hexagonal board with five spaces per side. Players take turns placing stones on an empty space. The stone must be adjacent to the last stone played but cannot be adjacent to any other. The last player to be able to make a legal move wins.
(game "Blue Nile" (players 2) (equipment {(board (hex 5)) (piece "Marker" Neutral)}) (rules phases:{(phase "start" P1 (play (move Add (piece (id "Marker0")) (to (sites Empty)))) (nextPhase "play")) (phase "play" (play (move Add (piece "Marker0") (to (sites Around (last To) if:(and (is Empty (to)) (= (count Sites in:(difference (sites Around (to) if:(not (is In (to) (sites Empty)))) (last To))) 0)))))))} (end (if (no Moves Next) (result Next Loss))))) 
Played on a hexagonal board with five spaces per side. Players take turns placing stones on an empty space. The stone must be adjacent to the last stone played but cannot be adjacent to any other. The last player to be able to make a legal move wins.
(game "Blue Nile" (players 2) (equipment {(board (hex 5)) (piece "Marker" Neutral)}) (rules phases:{(phase "start" P1 (play (move Add (piece (id "Marker0")) (to (sites Empty)))) (nextPhase "play")) (phase "play" (play (move Add (piece "Marker0") (to (sites Around (last To) if:(and (is Empty (to)) (= (count Sites in:(difference (sites Around (to) if:(not (is In (to) (sites Empty)))) (last To))) 0)))))))} (end (if (no Moves Next) (result Next Loss))))) 
The game is played on a sheet of graph paper, with any set of designs traced out. It is most commonly played on rectangular board like a 6×6 square. Two players have a collection of dominoes which they place on the grid in turn. A player can place a domino either horizontally or vertically. Contrary to the related game of Domineering, the possible moves are the same for the two players, and Cram is then an impartial game. As for all impartial games, there are two possible conventions for victory: in the normal game, the first player who cannot move loses, and on the contrary, in the misere version, the first player who cannot move wins. The board has 6 rows. The board has 6 columns. The Last player to play wins.
(game "Cram" (players 2) (equipment {(board (rectangle 6 6)) (tile "Tile" P1 {F} numSides:4) (tile "Tile" P2 {F} numSides:4)}) (rules (play (or (move Add (piece (mover) state:0) (to (sites Empty))) (move Add (piece (mover) state:1) (to (sites Empty))))) (end (if (no Moves Next) (result Next Loss))))) 
The game is played on a sheet of graph paper, with any set of designs traced out. It is most commonly played on rectangular board like a 6×6 square. Two players have a collection of dominoes which they place on the grid in turn. A player can place a domino either horizontally or vertically. Contrary to the related game of Domineering, the possible moves are the same for the two players, and Cram is then an impartial game. As for all impartial games, there are two possible conventions for victory: in the normal game, the first player who cannot move loses, and on the contrary, in the misere version, the first player who cannot move wins. The board has 1 row. The board has 2 columns. The Last player to play loses.
(game "Cram" (players 2) (equipment {(board (rectangle 1 2)) (tile "Tile" P1 {F} numSides:4) (tile "Tile" P2 {F} numSides:4)}) (rules (play (or (move Add (piece (mover) state:0) (to (sites Empty))) (move Add (piece (mover) state:1) (to (sites Empty))))) (end (if (no Moves Next) (result Next Win))))) 
The game is played on a sheet of graph paper, with any set of designs traced out. It is most commonly played on rectangular board like a 6×6 square. Two players have a collection of dominoes which they place on the grid in turn. A player can place a domino either horizontally or vertically. Contrary to the related game of Domineering, the possible moves are the same for the two players, and Cram is then an impartial game. As for all impartial games, there are two possible conventions for victory: in the normal game, the first player who cannot move loses, and on the contrary, in the misere version, the first player who cannot move wins. The board has 2 rows. The board has 3 columns. The Last player to play wins.
(game "Cram" (players 2) (equipment {(board (rectangle 2 3)) (tile "Tile" P1 {F} numSides:4) (tile "Tile" P2 {F} numSides:4)}) (rules (play (or (move Add (piece (mover) state:0) (to (sites Empty))) (move Add (piece (mover) state:1) (to (sites Empty))))) (end (if (no Moves Next) (result Next Loss))))) 
One player has three dwarfs and the other has one giant. Firstly, the giant is placed on one of the top sites. After this first move of the giant, it is the dwarfs' move. Each piece can move between the different sites only if they are connected by an edge. The dwarfs can move only forwards or sideways, the giant can move in all the directions. The goal of the dwarfs is to block the giant on the top site. The giant has to break through the line of dwarfs to get 2 points and win. In case of a repetition of moves, the giant is winning with one point.
(game "Game of Dwarfs" (players {(player S) (player N)}) (equipment {(board (add (remove (rotate 90 (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))})) vertices:{3 7 1}) edges:{{0 1} {4 5} {2 7} {0 4}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(and (if (= 1 (count Turns)) (!= (centrePoint) (to)) True) (is Empty (to)))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (expand (sites Top))))) (nextPhase P1 "MainP1")) (phase "MainP1" P1 (play (forEach Piece (then (if (is In (where "Foot" P1) (sites P2)) (set Score P1 2) (if (is Cycle) (set Score P1 1))))))) (phase "MainP2" P2 (play (forEach Piece (then (if (no Moves Next) (set Score P2 1) (if (is Cycle) (set Score P1 1)))))))} (end (forEach Player if:(!= 0 (score Player)) (result Player Win))))) 
One player has three dwarfs and the other has one giant. Firstly, the giant is placed on one of the top sites. After this first move of the giant, it is the dwarfs' move. Each piece can move between the different sites only if they are connected by an edge. The dwarfs can move only forwards or sideways, the giant can move in all the directions. The goal of the dwarfs is to block the giant on the top site. The giant has to break through the line of dwarfs to get 2 points and win. In case of a repetition of moves, the giant is winning with one point.
(game "Game of Dwarfs" (players {(player S) (player N)}) (equipment {(board (add (remove (rotate 90 (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))})) vertices:{3 7 1}) edges:{{0 1} {4 5} {2 7} {0 4}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(and (if (= 1 (count Turns)) (!= (centrePoint) (to)) True) (is Empty (to)))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (expand (sites Top))))) (nextPhase P1 "MainP1")) (phase "MainP1" P1 (play (forEach Piece (then (if (is In (where "Foot" P1) (sites P2)) (set Score P1 2) (if (is Cycle) (set Score P1 1))))))) (phase "MainP2" P2 (play (forEach Piece (then (if (no Moves Next) (set Score P2 1) (if (is Cycle) (set Score P1 1)))))))} (end (forEach Player if:(!= 0 (score Player)) (result Player Win))))) 
One player has three dwarfs and the other has one giant. Firstly, the giant is placed on one of the top sites. After this first move of the giant, it is the dwarfs' move. Each piece can move between the different sites only if they are connected by an edge. The dwarfs can move only forwards or sideways, the giant can move in all the directions. The goal of the dwarfs is to block the giant on the top site. The giant has to break through the line of dwarfs to get 2 points and win. In case of a repetition of moves, the giant is winning with one point.
(game "Game of Dwarfs" (players {(player S) (player N)}) (equipment {(board (add (remove (rotate 90 (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))})) vertices:{3 7 1}) edges:{{0 1} {4 5} {2 7} {0 4}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(and (if (= 1 (count Turns)) (!= (centrePoint) (to)) True) (is Empty (to)))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (expand (sites Top))))) (nextPhase P1 "MainP1")) (phase "MainP1" P1 (play (forEach Piece (then (if (is In (where "Foot" P1) (sites P2)) (set Score P1 2) (if (is Cycle) (set Score P1 1))))))) (phase "MainP2" P2 (play (forEach Piece (then (if (no Moves Next) (set Score P2 1) (if (is Cycle) (set Score P1 1)))))))} (end (forEach Player if:(!= 0 (score Player)) (result Player Win))))) 
Each player has three pieces. Players take turns moving a piece to an empty dot. Players cannot return to their starting three dots. Pieces that move into the opponent’s starting three dots cannot exit them. A player wins by blocking the other player from being able to move.
(game "Ho-Bag Gonu" (players 2) (equipment {(board (add (merge {(rectangle 1 3) (shift 1 1 (scale 0.5 (concentric {1 4}))) (shift 0 2 (rectangle 1 3))}) edges:{{5 1} {9 7}}) use:Vertex) (piece "Disc" Each (move Step (to if:(or (and {(is In (from) (sites Next)) (is In (to) (sites Next)) (is Empty (to))}) (and (not (is In (from) (sites Next))) (if (not (is In (from) (sites Mover))) (is In (to) (difference (sites Empty) (sites Mover))) (is Empty (to)))))))) (regions "Home" P1 (sites {"A1" "C1" "E1"})) (regions "Home" P2 (sites {"A5" "C5" "E5"}))}) (rules (start {(place "Disc1" (sites P1)) (place "Disc2" (sites P2))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Each player has three pieces. Players take turns moving a piece to an empty dot. Players cannot return to their starting three dots. Pieces that move into the opponent’s starting three dots cannot exit them. A player wins by blocking the other player from being able to move.
(game "Ho-Bag Gonu" (players 2) (equipment {(board (add (merge {(rectangle 1 3) (shift 1 1 (scale 0.5 (concentric {1 4}))) (shift 0 2 (rectangle 1 3))}) edges:{{5 1} {9 7}}) use:Vertex) (piece "Disc" Each (move Step (to if:(or (and {(is In (from) (sites Next)) (is In (to) (sites Next)) (is Empty (to))}) (and (not (is In (from) (sites Next))) (if (not (is In (from) (sites Mover))) (is In (to) (difference (sites Empty) (sites Mover))) (is Empty (to)))))))) (regions "Home" P1 (sites {"A1" "C1" "E1"})) (regions "Home" P2 (sites {"A5" "C5" "E5"}))}) (rules (start {(place "Disc1" (sites P1)) (place "Disc2" (sites P2))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Each player has three pieces. Players take turns moving a piece to an empty dot. Players cannot return to their starting three dots. Pieces that move into the opponent’s starting three dots cannot exit them. A player wins by blocking the other player from being able to move.
(game "Ho-Bag Gonu" (players 2) (equipment {(board (add (merge {(rectangle 1 3) (shift 1 1 (scale 0.5 (concentric {1 4}))) (shift 0 2 (rectangle 1 3))}) edges:{{5 1} {9 7}}) use:Vertex) (piece "Disc" Each (move Step (to if:(or (and {(is In (from) (sites Next)) (is In (to) (sites Next)) (is Empty (to))}) (and (not (is In (from) (sites Next))) (if (not (is In (from) (sites Mover))) (is In (to) (difference (sites Empty) (sites Mover))) (is Empty (to)))))))) (regions "Home" P1 (sites {"A1" "C1" "E1"})) (regions "Home" P2 (sites {"A5" "C5" "E5"}))}) (rules (start {(place "Disc1" (sites P1)) (place "Disc2" (sites P2))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as three notched sticks, called hares, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When the players have placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. The first player to block their opponent from being able to move wins.
(game "Janes Soppi (Symmetrical)" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) edges:{{6 4} {4 2} {0 4} {4 8}}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2) count:3)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Mover Win))))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as three notched sticks, called hares, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When the players have placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. The first player to block their opponent from being able to move wins.
(game "Janes Soppi (Symmetrical)" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) edges:{{6 4} {4 2} {0 4} {4 8}}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2) count:3)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Mover Win))))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as three notched sticks, called hares, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When the players have placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. The first player to block their opponent from being able to move wins.
(game "Janes Soppi (Symmetrical)" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) edges:{{6 4} {4 2} {0 4} {4 8}}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2) count:3)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Mover Win))))) 
Played on a board of 4x4 squares. Each player controls a 3x2 L-shaped piece, and there are two 1x1 pieces which either player can manipulate. On a turn, a player moves the L piece to a new available position, and then has the option to move one of the 1x1 pieces. When a player cannot move their L piece, they lose.
(game "L Game" (players 2) (equipment {(board (square 4)) (piece "Dot" Neutral) (tile "L" Each {{L F R F F} {R F L F F}})}) (rules (start {(place "Dot0" {"A4" "D1"}) (place "L1" coord:"C1" state:0) (place "L2" coord:"B4" state:2)}) (play (if (is Prev Mover) (or (move Pass) (move (from (sites Occupied by:Neutral)) (to (sites Empty)))) (move (from (sites Occupied by:Mover)) (to (union (sites Empty) (sites Occupied by:Mover))) (then (moveAgain))))) (end (if (and (not (is Mover (next))) (no Moves Next)) (result Mover Win))))) 
Played on a board of 4x4 squares. Each player controls a 3x2 L-shaped piece, and there are two 1x1 pieces which either player can manipulate. On a turn, a player moves the L piece to a new available position, and then has the option to move one of the 1x1 pieces. When a player cannot move their L piece, they lose.
(game "L Game" (players 2) (equipment {(board (square 4)) (piece "Dot" Neutral) (tile "L" Each {{L F R F F} {R F L F F}})}) (rules (start {(place "Dot0" {"A4" "D1"}) (place "L1" coord:"C1" state:0) (place "L2" coord:"B4" state:2)}) (play (if (is Prev Mover) (or (move Pass) (move (from (sites Occupied by:Neutral)) (to (sites Empty)))) (move (from (sites Occupied by:Mover)) (to (union (sites Empty) (sites Occupied by:Mover))) (then (moveAgain))))) (end (if (and (not (is Mover (next))) (no Moves Next)) (result Mover Win))))) 
Played on a board of 4x4 squares. Each player controls a 3x2 L-shaped piece, and there are two 1x1 pieces which either player can manipulate. On a turn, a player moves the L piece to a new available position, and then has the option to move one of the 1x1 pieces. When a player cannot move their L piece, they lose.
(game "L Game" (players 2) (equipment {(board (square 4)) (piece "Dot" Neutral) (tile "L" Each {{L F R F F} {R F L F F}})}) (rules (start {(place "Dot0" {"A4" "D1"}) (place "L1" coord:"C1" state:0) (place "L2" coord:"B4" state:2)}) (play (if (is Prev Mover) (or (move Pass) (move (from (sites Occupied by:Neutral)) (to (sites Empty)))) (move (from (sites Occupied by:Mover)) (to (union (sites Empty) (sites Occupied by:Mover))) (then (moveAgain))))) (end (if (and (not (is Mover (next))) (no Moves Next)) (result Mover Win))))) 
Players move their pieces to an adjacent empty point. The goal is to block the other player from being able to move.
(game "Madelinette" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{7 1}) edges:{{0 1}}) use:Vertex) (piece "Counter" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Counter1" (sites {"A1" "C2" "A3"})) (place "Counter2" (sites {"C1" "A2" "C3"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Players move their pieces to an adjacent empty point. The goal is to block the other player from being able to move.
(game "Madelinette" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{7 1}) edges:{{0 1}}) use:Vertex) (piece "Counter" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Counter1" (sites {"A1" "C2" "A3"})) (place "Counter2" (sites {"C1" "A2" "C3"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Players move their pieces to an adjacent empty point. The goal is to block the other player from being able to move.
(game "Madelinette" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{7 1}) edges:{{0 1}}) use:Vertex) (piece "Counter" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Counter1" (sites {"A1" "C2" "A3"})) (place "Counter2" (sites {"C1" "A2" "C3"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the pieces on the kewai, each player on half of the circle. Players move by moving one piece to an empty adjacent space. Players can only move to the putahi when the piece being moved is next to an opponent's piece. The player that blocks the other from moving is the winner. The game is played on a wheel board. The game is played with all the rules
(game "Mu Torere" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (piece "Marker" Each (move Step (to if:(and (is Empty (to)) (or (not (= (to) (centrePoint))) (is Related Adjacent (from) (sites Occupied by:Next)))))))}) (rules (start {(place "Marker1" {1 2 3 8}) (place "Marker2" {4 5 6 7})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the pieces on the kewai, each player on half of the circle. Players move by moving one piece to an empty adjacent space. Players can only move to the putahi when the piece being moved is next to an opponent's piece. The player that blocks the other from moving is the winner. The game is played on a 3x3 alquerque board. The game is played with no constraint on the centre site.
(game "Mu Torere" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" {0 1 2 5}) (place "Marker2" {3 6 7 8})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the pieces on the kewai, each player on half of the circle. Players move by moving one piece to an empty adjacent space. Players can only move to the putahi when the piece being moved is next to an opponent's piece. The player that blocks the other from moving is the winner. The game is played on a wheel board. The constraint to move a piece adjacent to an enemy is applied only for the first move.
(game "Mu Torere" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (piece "Marker" Each (if (> (count Moves) 1) (move Step (to if:(is Empty (to)))) (move Step (to if:(and (is Empty (to)) (or (not (= (to) (centrePoint))) (is Related Adjacent (from) (sites Occupied by:Next))))))))}) (rules (start {(place "Marker1" {1 2 3 8}) (place "Marker2" {4 5 6 7})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Overflow is played on a checkered board initially filled with neutral stackable pieces, one per square. The dark squares make up the house of the Dark player, and the light squares make up the house of the Light player. The goal is to empty your opponent's house. There are two types of moves in Overflow, both of which are sowing moves, somewhat akin to what you see in mancalas. All moves are bound by the restriction that there must always be exactly one orthodiagonally connected group of stacks on the board. The one kind of sowing only drops pieces onto already occupied squares and the other kind spills out of both the group of already occupied squares and out of the board itself, hence the names: contained moves and overflow moves. Sowing in general: Sowing in general is picking up a stack from any square and distributing its pieces along one of the 8 directions onto a contiguous line of squares – usually placing one of the N pieces from the chosen stack in each of the N or so squares in the sowing direction. The details are given below. Overflow moves: An overflow move involves sowing into empty squares – possibly in addition to occupied squares – and over the edge of the board. It's important to remember that these two things always go together in this game, namely (1) sowing over the edge and (2) sowing into empty squares. That is to say, if you are to sow into one or more empty squares, the number of squares in the chosen sowing direction must be smaller than the number of stones in the chosen stack. The pieces that end up outside the board are removed from the game. Contained moves: Contained moves only sow onto already occupied squares. A contained move must sow the chosen stack as far as possible. If it's impossible to sow each of the pieces in the stack into an occupied square of its own, you place the remainder of the pieces on the last occupied square you reached. You are not obligated to chose the stack that can be sown the farthest, but whatever stack you chose, if you do not make an overflow move move with it, you must chose a sowing direction that allows you to sow onto as many occupied squares as possible. You may always chose freely between contained moves and overflow moves when both kinds are available. Note that no stack will have both a contained move and an overflow move available in the same direction. All moves are completely determined by the choice of stack and direction. A 6x6 board is currently selected
(game "Overflow" (players 2) (equipment {(board (square 6)) (piece "Disc" P1)}) (rules (start {(place "Disc1" (sites Board)) (set Score P1 (count Sites in:(sites Phase 1))) (set Score P2 (count Sites in:(sites Phase 0)))}) (play (do (or (move Select (from (sites Occupied by:P1)) (to (sites Around (from) NotEmpty) if:(and (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))) (all Sites (sites Around (from) NotEmpty) if:(not (and (< (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) stop:(is Empty (to)) distance:(size Stack at:(from)))) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) stop:(is Empty (to)) distance:(size Stack at:(from))))) (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from)))))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From))) (if (= (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) (count Steps (last From) (site))) (add (piece "Disc1") (to (site)) count:(- (size Stack at:(last From)) (- (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) 1)) stack:True) (add (piece "Disc1") (to (site)) stack:True))))) (move Select (from (sites Occupied by:P1)) (to (sites Around (from)) if:(and (not (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from)))))) (not (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) distance:(size Stack at:(last From))) (add (piece "Disc1") (to (site)) stack:True)))) (then (remove (last From) count:(size Stack at:(last From))))) ifAfterwards:(= 1 (count Groups)) (then (and (set Score P1 (count Sites in:(forEach (sites Phase 1) if:(is Occupied (site))))) (set Score P2 (count Sites in:(forEach (sites Phase 0) if:(is Occupied (site))))))))) (end (if (= 0 (* (score P1) (score P2))) (byScore))))) 
Overflow is played on a checkered board initially filled with neutral stackable pieces, one per square. The dark squares make up the house of the Dark player, and the light squares make up the house of the Light player. The goal is to empty your opponent's house. There are two types of moves in Overflow, both of which are sowing moves, somewhat akin to what you see in mancalas. All moves are bound by the restriction that there must always be exactly one orthodiagonally connected group of stacks on the board. The one kind of sowing only drops pieces onto already occupied squares and the other kind spills out of both the group of already occupied squares and out of the board itself, hence the names: contained moves and overflow moves. Sowing in general: Sowing in general is picking up a stack from any square and distributing its pieces along one of the 8 directions onto a contiguous line of squares – usually placing one of the N pieces from the chosen stack in each of the N or so squares in the sowing direction. The details are given below. Overflow moves: An overflow move involves sowing into empty squares – possibly in addition to occupied squares – and over the edge of the board. It's important to remember that these two things always go together in this game, namely (1) sowing over the edge and (2) sowing into empty squares. That is to say, if you are to sow into one or more empty squares, the number of squares in the chosen sowing direction must be smaller than the number of stones in the chosen stack. The pieces that end up outside the board are removed from the game. Contained moves: Contained moves only sow onto already occupied squares. A contained move must sow the chosen stack as far as possible. If it's impossible to sow each of the pieces in the stack into an occupied square of its own, you place the remainder of the pieces on the last occupied square you reached. You are not obligated to chose the stack that can be sown the farthest, but whatever stack you chose, if you do not make an overflow move move with it, you must chose a sowing direction that allows you to sow onto as many occupied squares as possible. You may always chose freely between contained moves and overflow moves when both kinds are available. Note that no stack will have both a contained move and an overflow move available in the same direction. All moves are completely determined by the choice of stack and direction. A 3x3 board is currently selected
(game "Overflow" (players 2) (equipment {(board (square 3)) (piece "Disc" P1)}) (rules (start {(place "Disc1" (sites Board)) (set Score P1 (count Sites in:(sites Phase 1))) (set Score P2 (count Sites in:(sites Phase 0)))}) (play (do (or (move Select (from (sites Occupied by:P1)) (to (sites Around (from) NotEmpty) if:(and (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))) (all Sites (sites Around (from) NotEmpty) if:(not (and (< (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) stop:(is Empty (to)) distance:(size Stack at:(from)))) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) stop:(is Empty (to)) distance:(size Stack at:(from))))) (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from)))))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From))) (if (= (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) (count Steps (last From) (site))) (add (piece "Disc1") (to (site)) count:(- (size Stack at:(last From)) (- (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) 1)) stack:True) (add (piece "Disc1") (to (site)) stack:True))))) (move Select (from (sites Occupied by:P1)) (to (sites Around (from)) if:(and (not (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from)))))) (not (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) distance:(size Stack at:(last From))) (add (piece "Disc1") (to (site)) stack:True)))) (then (remove (last From) count:(size Stack at:(last From))))) ifAfterwards:(= 1 (count Groups)) (then (and (set Score P1 (count Sites in:(forEach (sites Phase 1) if:(is Occupied (site))))) (set Score P2 (count Sites in:(forEach (sites Phase 0) if:(is Occupied (site))))))))) (end (if (= 0 (* (score P1) (score P2))) (byScore))))) 
Overflow is played on a checkered board initially filled with neutral stackable pieces, one per square. The dark squares make up the house of the Dark player, and the light squares make up the house of the Light player. The goal is to empty your opponent's house. There are two types of moves in Overflow, both of which are sowing moves, somewhat akin to what you see in mancalas. All moves are bound by the restriction that there must always be exactly one orthodiagonally connected group of stacks on the board. The one kind of sowing only drops pieces onto already occupied squares and the other kind spills out of both the group of already occupied squares and out of the board itself, hence the names: contained moves and overflow moves. Sowing in general: Sowing in general is picking up a stack from any square and distributing its pieces along one of the 8 directions onto a contiguous line of squares – usually placing one of the N pieces from the chosen stack in each of the N or so squares in the sowing direction. The details are given below. Overflow moves: An overflow move involves sowing into empty squares – possibly in addition to occupied squares – and over the edge of the board. It's important to remember that these two things always go together in this game, namely (1) sowing over the edge and (2) sowing into empty squares. That is to say, if you are to sow into one or more empty squares, the number of squares in the chosen sowing direction must be smaller than the number of stones in the chosen stack. The pieces that end up outside the board are removed from the game. Contained moves: Contained moves only sow onto already occupied squares. A contained move must sow the chosen stack as far as possible. If it's impossible to sow each of the pieces in the stack into an occupied square of its own, you place the remainder of the pieces on the last occupied square you reached. You are not obligated to chose the stack that can be sown the farthest, but whatever stack you chose, if you do not make an overflow move move with it, you must chose a sowing direction that allows you to sow onto as many occupied squares as possible. You may always chose freely between contained moves and overflow moves when both kinds are available. Note that no stack will have both a contained move and an overflow move available in the same direction. All moves are completely determined by the choice of stack and direction. A 4x4 board is currently selected
(game "Overflow" (players 2) (equipment {(board (square 4)) (piece "Disc" P1)}) (rules (start {(place "Disc1" (sites Board)) (set Score P1 (count Sites in:(sites Phase 1))) (set Score P2 (count Sites in:(sites Phase 0)))}) (play (do (or (move Select (from (sites Occupied by:P1)) (to (sites Around (from) NotEmpty) if:(and (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))) (all Sites (sites Around (from) NotEmpty) if:(not (and (< (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) stop:(is Empty (to)) distance:(size Stack at:(from)))) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) stop:(is Empty (to)) distance:(size Stack at:(from))))) (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from)))))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From))) (if (= (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) (count Steps (last From) (site))) (add (piece "Disc1") (to (site)) count:(- (size Stack at:(last From)) (- (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) 1)) stack:True) (add (piece "Disc1") (to (site)) stack:True))))) (move Select (from (sites Occupied by:P1)) (to (sites Around (from)) if:(and (not (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from)))))) (not (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) distance:(size Stack at:(last From))) (add (piece "Disc1") (to (site)) stack:True)))) (then (remove (last From) count:(size Stack at:(last From))))) ifAfterwards:(= 1 (count Groups)) (then (and (set Score P1 (count Sites in:(forEach (sites Phase 1) if:(is Occupied (site))))) (set Score P2 (count Sites in:(forEach (sites Phase 0) if:(is Occupied (site))))))))) (end (if (= 0 (* (score P1) (score P2))) (byScore))))) 
Pieces begin on opposite sides of the square. Players take turns moving the piece to an empty spot either orthogonally or diagonally, but one orthogonal direction is forbidden. The player who blocks the other player from being able to move wins. The piece are already placed on the board.
(game "Pong Hau K'i" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{1 3 5 7}) edges:{{3 0} {0 1} {1 4}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Disc1" {"A3" "C3"}) (place "Disc2" {"A1" "C1"})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Pieces begin on opposite sides of the square. Players take turns moving the piece to an empty spot either orthogonally or diagonally, but one orthogonal direction is forbidden. The player who blocks the other player from being able to move wins. The pieces have to place before to play.
(game "Pong Hau K'i" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{1 3 5 7}) edges:{{3 0} {0 1} {1 4}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Disc" "Hand" count:2)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
Pieces begin on opposite sides of the square. Players take turns moving the piece to an empty spot either orthogonally or diagonally, but one orthogonal direction is forbidden. The player who blocks the other player from being able to move wins. The piece are already placed on the board.
(game "Pong Hau K'i" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{1 3 5 7}) edges:{{3 0} {0 1} {1 4}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Disc1" {"A3" "C3"}) (place "Disc2" {"A1" "C1"})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the supply of pieces (30 of each colour) randomly distributed on the board, so each cell contains only one stone and there is one free space left. This free space can be anywhere except the centre space. Each player has an allocated colour. Before the game starts, Black can swap the positions of any two stones on the board. White then starts the game. Players alternate turns during the game until one of them cannot make a valid move, thereby losing the game. On a turn, a player must make one capture. A player makes a capture by leaping in a straight line in any of the 6 directions exactly as many spaces as friendly pieces surround its original position, and landing on an enemy piece, which is removed from the game. The player who cannot make a capture loses.
(game "Quantum Leap" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Hop Orthogonal (between (exact (- (count Sites in:(sites Around (from) Orthogonal if:(is Friend (who at:(to))))) 1)) if:True) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Marker2" (centrePoint)) (place Random {"Marker2"} count:29) (place Random {"Marker1"} count:30)}) phases:{(phase "Swap" (play (or (move Pass) (move Select (from (sites Occupied by:Mover)) (to (sites Occupied by:Next)) (then (swap Pieces (last From) (last To)))))) (nextPhase "Play")) (phase "Play" (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the supply of pieces (30 of each colour) randomly distributed on the board, so each cell contains only one stone and there is one free space left. This free space can be anywhere except the centre space. Each player has an allocated colour. Before the game starts, Black can swap the positions of any two stones on the board. White then starts the game. Players alternate turns during the game until one of them cannot make a valid move, thereby losing the game. On a turn, a player must make one capture. A player makes a capture by leaping in a straight line in any of the 6 directions exactly as many spaces as friendly pieces surround its original position, and landing on an enemy piece, which is removed from the game. The player who cannot make a capture loses.
(game "Quantum Leap" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Hop Orthogonal (between (exact (- (count Sites in:(sites Around (from) Orthogonal if:(is Friend (who at:(to))))) 1)) if:True) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Marker2" (centrePoint)) (place Random {"Marker2"} count:29) (place Random {"Marker1"} count:30)}) phases:{(phase "Swap" (play (or (move Pass) (move Select (from (sites Occupied by:Mover)) (to (sites Occupied by:Next)) (then (swap Pieces (last From) (last To)))))) (nextPhase "Play")) (phase "Play" (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the supply of pieces (30 of each colour) randomly distributed on the board, so each cell contains only one stone and there is one free space left. This free space can be anywhere except the centre space. Each player has an allocated colour. Before the game starts, Black can swap the positions of any two stones on the board. White then starts the game. Players alternate turns during the game until one of them cannot make a valid move, thereby losing the game. On a turn, a player must make one capture. A player makes a capture by leaping in a straight line in any of the 6 directions exactly as many spaces as friendly pieces surround its original position, and landing on an enemy piece, which is removed from the game. The player who cannot make a capture loses.
(game "Quantum Leap" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Hop Orthogonal (between (exact (- (count Sites in:(sites Around (from) Orthogonal if:(is Friend (who at:(to))))) 1)) if:True) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Marker2" (centrePoint)) (place Random {"Marker2"} count:29) (place Random {"Marker1"} count:30)}) phases:{(phase "Swap" (play (or (move Pass) (move Select (from (sites Occupied by:Mover)) (to (sites Occupied by:Next)) (then (swap Pieces (last From) (last To)))))) (nextPhase "Play")) (phase "Play" (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
First, the giant takes place on one of the top sites. Centre site in the opening move for the giant is not allowed. In any subsequent moves, the giant is allowed to enter the centre. The Giant piece can step to an empty site, the dwarves can step only forward to the top of the board. The giant wins if it reaches the bottom sites and the dwarves win if they block the giant to move. The rules of the game I.
(game "Ratio" (players {(player S) (player N)}) (equipment {(board (add (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 2 (wedge 2)) (shift 0 -1 (rotate 180 (wedge 2)))}) vertices:{3 5 1}) edges:{{0 3} {1 5} {2 7} {0 1}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(and (if (= 1 (count Turns)) (!= (centrePoint) (to)) True) (is Empty (to)))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" (play (move (from (handSite Mover)) (to (expand (sites Top))) (then (moveAgain)))) (nextPhase "Main")) (phase "Main" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (is In (where "Foot" P1) (sites P2)) (result P1 Win))}))) 
First, the giant takes place on one of the top sites. Centre site in the opening move for the giant is not allowed. In any subsequent moves, the giant is allowed to enter the centre. The Giant piece can step to an empty site, the dwarves can step only forward to the top of the board. The giant wins if it reaches the bottom sites and the dwarves win if they block the giant to move. The rules of the game II.
(game "Ratio" (players {(player S) (player N)}) (equipment {(board (add (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 2 (wedge 2)) (shift 0 -1 (rotate 180 (wedge 2)))}) vertices:{3 5}) edges:{{0 4} {2 6}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(is Empty (to))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" (play (move (from (handSite Mover)) (to (difference (sites Board) (intersection (sites Outer) (expand (sites Bottom))))) (then (moveAgain)))) (nextPhase "Main")) (phase "Main" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (is In (where "Foot" P1) (sites P2)) (result P1 Win))}))) 
First, the giant takes place on one of the top sites. Centre site in the opening move for the giant is not allowed. In any subsequent moves, the giant is allowed to enter the centre. The Giant piece can step to an empty site, the dwarves can step only forward to the top of the board. The giant wins if it reaches the bottom sites and the dwarves win if they block the giant to move. The rules of the game III.
(game "Ratio" (players {(player S) (player N)}) (equipment {(board (add (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 2 (wedge 2)) (shift 0 -1 (rotate 180 (wedge 2)))}) vertices:{1}) edges:{{0 1} {3 9}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(is Empty (to))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" (play (move (from (handSite Mover)) (to (difference (sites Board) (intersection (sites Outer) (expand (sites Bottom))))) (then (moveAgain)))) (nextPhase "Main")) (phase "Main" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (is In (where "Foot" P1) (sites P2)) (result P1 Win))}))) 
Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block to the cell he came from. First player who cannot move loses. The game is played on a 7x7 board.
(game "Snailtrail" (players 2) (equipment {(board (rectangle 7 7)) (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain)))) (piece "Square" Neutral)}) (rules (start {(place "Pawn1" {"A1"}) (place "Pawn2" {"G7"})}) (play (if (is Even (count Moves)) (forEach Piece) (move Add (piece "Square0") (to (last From))))) (end (if (no Moves Next) (result Mover Win))))) 
Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block to the cell he came from. First player who cannot move loses. The game is played on a 7x7 board.
(game "Snailtrail" (players 2) (equipment {(board (rectangle 7 7)) (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain)))) (piece "Square" Neutral)}) (rules (start {(place "Pawn1" {"A1"}) (place "Pawn2" {"G7"})}) (play (if (is Even (count Moves)) (forEach Piece) (move Add (piece "Square0") (to (last From))))) (end (if (no Moves Next) (result Mover Win))))) 
Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block to the cell he came from. First player who cannot move loses. The game is played on a 7x7 board.
(game "Snailtrail" (players 2) (equipment {(board (rectangle 7 7)) (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain)))) (piece "Square" Neutral)}) (rules (start {(place "Pawn1" {"A1"}) (place "Pawn2" {"G7"})}) (play (if (is Even (count Moves)) (forEach Piece) (move Add (piece "Square0") (to (last From))))) (end (if (no Moves Next) (result Mover Win))))) 
Players alternate turns. A player's turn consists on either placing piece on an empty field on board, or sliding one of their pieces into an empty one on the board. Players cannot pass. If each player performs three slides in a row then the game ends immediately as a draw. A player wins when any of the opponent's pieces are surrounded and cannot move. If one of a player's own pieces is surrounded on their turn, they lose even if an opponent's stone is surrounded at the same time.
(game "Susan" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (play (or (move Add (to (sites Empty)) (then (set Counter))) (forEach Piece) (then (priority (surround (from (last To)) Orthogonal (between if:(is Friend (who at:(between))) (apply (trigger "Surrounded" (mover)))) (to if:(is Occupied (to)))) (surround (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (trigger "Surrounded" (next)))) (to if:(is Occupied (to)))))))) (end {(if (= (counter) 5) (result Mover Draw)) (if (= (count Sites in:(sites Around (last To) if:(is Empty (to)))) 0) (result Next Win)) (if (is Triggered "Surrounded" P1) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Players alternate turns. A player's turn consists on either placing piece on an empty field on board, or sliding one of their pieces into an empty one on the board. Players cannot pass. If each player performs three slides in a row then the game ends immediately as a draw. A player wins when any of the opponent's pieces are surrounded and cannot move. If one of a player's own pieces is surrounded on their turn, they lose even if an opponent's stone is surrounded at the same time.
(game "Susan" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (play (or (move Add (to (sites Empty)) (then (set Counter))) (forEach Piece) (then (priority (surround (from (last To)) Orthogonal (between if:(is Friend (who at:(between))) (apply (trigger "Surrounded" (mover)))) (to if:(is Occupied (to)))) (surround (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (trigger "Surrounded" (next)))) (to if:(is Occupied (to)))))))) (end {(if (= (counter) 5) (result Mover Draw)) (if (= (count Sites in:(sites Around (last To) if:(is Empty (to)))) 0) (result Next Win)) (if (is Triggered "Surrounded" P1) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Players alternate turns. A player's turn consists on either placing piece on an empty field on board, or sliding one of their pieces into an empty one on the board. Players cannot pass. If each player performs three slides in a row then the game ends immediately as a draw. A player wins when any of the opponent's pieces are surrounded and cannot move. If one of a player's own pieces is surrounded on their turn, they lose even if an opponent's stone is surrounded at the same time.
(game "Susan" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (play (or (move Add (to (sites Empty)) (then (set Counter))) (forEach Piece) (then (priority (surround (from (last To)) Orthogonal (between if:(is Friend (who at:(between))) (apply (trigger "Surrounded" (mover)))) (to if:(is Occupied (to)))) (surround (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (trigger "Surrounded" (next)))) (to if:(is Occupied (to)))))))) (end {(if (= (counter) 5) (result Mover Draw)) (if (= (count Sites in:(sites Around (last To) if:(is Empty (to)))) 0) (result Next Win)) (if (is Triggered "Surrounded" P1) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
A player may remove one or more adjacent pieces from a row or column. The loser is the person who takes the last piece off the board.
(game "TacTix" (players 2) (equipment {(board (square 4)) (piece "Ball" Shared)}) (rules (start (place "Ball" (sites Board))) (play (if (is Prev Mover) (or (if (= 1 (count MovesThisTurn)) (move Select (from (last To)) (to (intersection (sites Around (last To) Orthogonal) (sites Occupied by:Shared))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain))))) (move Select (from (last To)) (to (ahead (last To) (directions Cell from:(last From) to:(last To)))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain)))))) (move Pass)) (move Remove (sites Board) (then (if (not (all Sites (sites Around (last To) Orthogonal) if:(is Empty (site)))) (moveAgain)))))) (end (if (no Moves Next) (result Next Win))))) 
A player may remove one or more adjacent pieces from a row or column. The loser is the person who takes the last piece off the board.
(game "TacTix" (players 2) (equipment {(board (square 4)) (piece "Ball" Shared)}) (rules (start (place "Ball" (sites Board))) (play (if (is Prev Mover) (or (if (= 1 (count MovesThisTurn)) (move Select (from (last To)) (to (intersection (sites Around (last To) Orthogonal) (sites Occupied by:Shared))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain))))) (move Select (from (last To)) (to (ahead (last To) (directions Cell from:(last From) to:(last To)))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain)))))) (move Pass)) (move Remove (sites Board) (then (if (not (all Sites (sites Around (last To) Orthogonal) if:(is Empty (site)))) (moveAgain)))))) (end (if (no Moves Next) (result Next Win))))) 
A player may remove one or more adjacent pieces from a row or column. The loser is the person who takes the last piece off the board.
(game "TacTix" (players 2) (equipment {(board (square 4)) (piece "Ball" Shared)}) (rules (start (place "Ball" (sites Board))) (play (if (is Prev Mover) (or (if (= 1 (count MovesThisTurn)) (move Select (from (last To)) (to (intersection (sites Around (last To) Orthogonal) (sites Occupied by:Shared))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain))))) (move Select (from (last To)) (to (ahead (last To) (directions Cell from:(last From) to:(last To)))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain)))))) (move Pass)) (move Remove (sites Board) (then (if (not (all Sites (sites Around (last To) Orthogonal) if:(is Empty (site)))) (moveAgain)))))) (end (if (no Moves Next) (result Next Win))))) 
This game is played on an empty 1row x n coloumn board with m stones on each side. At each turn, each player must do one of the following actions. Move a stone forward (i.e., left to one player, right to the other) or jump over one enemy stone, landing on the immediate empty cell. The player who makes the last move wins the game. The game is played on a 1x5 board.
(game "Toads and Frogs" (players 2) (equipment {(board (rectangle 1 5)) (piece "Toad" P1 E (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to)))))) (piece "Frog" P2 W (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to))))))}) (rules (start {(place "Toad1" (expand (sites Left) steps:(- 2 1))) (place "Frog2" (expand (sites Right) steps:(- 2 1)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
This game is played on an empty 1row x n coloumn board with m stones on each side. At each turn, each player must do one of the following actions. Move a stone forward (i.e., left to one player, right to the other) or jump over one enemy stone, landing on the immediate empty cell. The player who makes the last move wins the game. The game is played on a 1x8 board.
(game "Toads and Frogs" (players 2) (equipment {(board (rectangle 1 8)) (piece "Toad" P1 E (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to)))))) (piece "Frog" P2 W (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to))))))}) (rules (start {(place "Toad1" (expand (sites Left) steps:(- 3 1))) (place "Frog2" (expand (sites Right) steps:(- 3 1)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
This game is played on an empty 1row x n coloumn board with m stones on each side. At each turn, each player must do one of the following actions. Move a stone forward (i.e., left to one player, right to the other) or jump over one enemy stone, landing on the immediate empty cell. The player who makes the last move wins the game. The game is played on a 1x5 board.
(game "Toads and Frogs" (players 2) (equipment {(board (rectangle 1 5)) (piece "Toad" P1 E (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to)))))) (piece "Frog" P2 W (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to))))))}) (rules (start {(place "Toad1" (expand (sites Left) steps:(- 2 1))) (place "Frog2" (expand (sites Right) steps:(- 2 1)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
Played on a Hex board. Players may play a piece of any color piece. The goal is to form a line connecting the player's two sides with either color. The game is played on a 11x11 board The first player to connect his two sides wins.
(game "Chameleon" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each) (hand Shared size:2) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (start {(place "Marker1" (handSite Shared)) (place "Marker2" (handSite Shared 1))}) (play (move (from (sites Hand Shared)) (to (sites Empty)) copy:True)) (end {(if (is Connected Mover) (result Mover Win)) (if (is Connected Next) (result Next Win))}))) 
Played on a Hex board. Players may play a piece of any color piece. The goal is to form a line connecting the player's two sides with either color. The game is played on a 10x10 board The first player to connect his two sides loses.
(game "Chameleon" (players 2) (equipment {(board (hex Diamond 10)) (piece "Marker" Each) (hand Shared size:2) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (start {(place "Marker1" (handSite Shared)) (place "Marker2" (handSite Shared 1))}) (play (move (from (sites Hand Shared)) (to (sites Empty)) copy:True)) (end {(if (is Connected Mover) (result Mover Loss)) (if (is Connected Next) (result Next Loss))}))) 
Played on a Hex board. Players may play a piece of any color piece. The goal is to form a line connecting the player's two sides with either color. The game is played on a 14x14 board The first player to connect his two sides wins.
(game "Chameleon" (players 2) (equipment {(board (hex Diamond 14)) (piece "Marker" Each) (hand Shared size:2) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (start {(place "Marker1" (handSite Shared)) (place "Marker2" (handSite Shared 1))}) (play (move (from (sites Hand Shared)) (to (sites Empty)) copy:True)) (end {(if (is Connected Mover) (result Mover Win)) (if (is Connected Next) (result Next Win))}))) 
Crossway is played with a Go set. The board starts out empty. Each player takes possession of all of the stones of one color. Players take turns adding their stones to the board, one stone per turn. A player must never create a crosscut formation. Black makes the first placement of the game. If you have no more available placements, you forfeit your turn and your opponent can continue making placements until completing his goal connection. For White to win, White must form a contiguous sequence of white stones connecting the West edge to the East edge of the board. Each stone in the sequence must be connected to neighboring stones in the sequence by horizontal, vertical, or diagonal adjacencies. Likewise for Black and the North and South edges. A corner is considered to be part of both adjoining edges. Crossway makes use of the pie rule. This means Black makes the first placement, and White has the option of switching colors with Black, and claiming Black's first move as his own. If White chooses to exercise the pie rule, Black then becomes White and now makes the second placement of the game. The pie rule can only be used once and on the second move of the game. The game is played on a 19x19 board
(game "Crossway" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta (swap)) (play (do (move Add (to (sites Empty))) ifAfterwards:(not (is Pattern {F R F R F} whats:{(mover) (next)})))) (end (if (is Connected All Mover) (result Mover Win))))) 
Crossway is played with a Go set. The board starts out empty. Each player takes possession of all of the stones of one color. Players take turns adding their stones to the board, one stone per turn. A player must never create a crosscut formation. Black makes the first placement of the game. If you have no more available placements, you forfeit your turn and your opponent can continue making placements until completing his goal connection. For White to win, White must form a contiguous sequence of white stones connecting the West edge to the East edge of the board. Each stone in the sequence must be connected to neighboring stones in the sequence by horizontal, vertical, or diagonal adjacencies. Likewise for Black and the North and South edges. A corner is considered to be part of both adjoining edges. Crossway makes use of the pie rule. This means Black makes the first placement, and White has the option of switching colors with Black, and claiming Black's first move as his own. If White chooses to exercise the pie rule, Black then becomes White and now makes the second placement of the game. The pie rule can only be used once and on the second move of the game. The game is played on a 9x9 board
(game "Crossway" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta (swap)) (play (do (move Add (to (sites Empty))) ifAfterwards:(not (is Pattern {F R F R F} whats:{(mover) (next)})))) (end (if (is Connected All Mover) (result Mover Win))))) 
Crossway is played with a Go set. The board starts out empty. Each player takes possession of all of the stones of one color. Players take turns adding their stones to the board, one stone per turn. A player must never create a crosscut formation. Black makes the first placement of the game. If you have no more available placements, you forfeit your turn and your opponent can continue making placements until completing his goal connection. For White to win, White must form a contiguous sequence of white stones connecting the West edge to the East edge of the board. Each stone in the sequence must be connected to neighboring stones in the sequence by horizontal, vertical, or diagonal adjacencies. Likewise for Black and the North and South edges. A corner is considered to be part of both adjoining edges. Crossway makes use of the pie rule. This means Black makes the first placement, and White has the option of switching colors with Black, and claiming Black's first move as his own. If White chooses to exercise the pie rule, Black then becomes White and now makes the second placement of the game. The pie rule can only be used once and on the second move of the game. The game is played on a 13x13 board
(game "Crossway" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta (swap)) (play (do (move Add (to (sites Empty))) ifAfterwards:(not (is Pattern {F R F R F} whats:{(mover) (next)})))) (end (if (is Connected All Mover) (result Mover Win))))) 
Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces. The game is played on a 11x11 board. The board is a diamond tiling by hexagon. The game uses the swap rule. The first player to connect their two sides wins. The connection between two stones is using all the diagonal directions.
(game "Diagonal Hex" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Diagonal Mover) (result Mover Win))))) 
Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces. The game is played on a 10x10 board. The board is a diamond tiling by square. The game does not use the swap rule. The first player to connect their two sides loses. The connection between two stones is using all the orthogonal directions.
(game "Diagonal Hex" (players 2) (equipment {(board (square Diamond 10)) (piece "Marker" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (play (move Add (to (sites Empty)))) (end (if (is Connected Orthogonal Mover) (result Mover Loss))))) 
Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces. The game is played on a 14x14 board. The board is a diamond tiling by triangle. The game uses the swap rule. The first player to connect their two sides wins. The connection between two stones is using all the directions.
(game "Diagonal Hex" (players 2) (equipment {(board (tri Diamond 14)) (piece "Marker" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected All Mover) (result Mover Win))))) 
All the rules of Go apply, except that passing is not allowed. A player loses if he has no legal move. A player wins if they successfully connect two opposite sides of the board. The game is played on a 13x13 board
(game "Gonnect" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta {(swap) (no Repeat)}) (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end {(if (is Connected Mover) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
All the rules of Go apply, except that passing is not allowed. A player loses if he has no legal move. A player wins if they successfully connect two opposite sides of the board. The game is played on a 9x9 board
(game "Gonnect" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta {(swap) (no Repeat)}) (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end {(if (is Connected Mover) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
All the rules of Go apply, except that passing is not allowed. A player loses if he has no legal move. A player wins if they successfully connect two opposite sides of the board. The game is played on a 15x15 board
(game "Gonnect" (players 2) (equipment {(board (square 15) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta {(swap) (no Repeat)}) (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end {(if (is Connected Mover) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Resolve is a connection game for two players: a player with Black stones who wins by connecting the East/West sides, and a player with White stones who wins by connecting the North/South sides. Players take turns placing and swapping stones on the intersections of a square grid which is initially empty. Passing is forbidden. Same-colored stones with orthogonal adjacency are connected. The game is over when a player wins by connecting their designated sides of the board with a single group of connected stones of their color, at any time during their turn or their opponent's turn. Cutting stones are any four stones in a generic crosscut configuration. OX XO On your turn you must select the following one of two actions. 1. Place a stone of your color on an empty point. If that stone creates a crosscut, swap it with different adjacent enemy stones that share a crosscut with it, until that stone is no longer part of a crosscut. 2. Choose a stone of your color that is part of a crosscut, and use it to resolve crosscuts as in 1. Then place a stone of your color on an empty point, if possible. Order 9 board
(game "Resolve" (players 2) (equipment {(board (square 9) use:Vertex) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)}) (piece "Ball" P1) (piece "Ball" P2)}) (rules (play (if (not (is Prev Mover)) (or (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1)))) (forEach Site (sites Occupied by:Mover) (do (set Var "LT" (site)) next:(forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1))))))))))) (if (<= 0 (var "LT")) (forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1)))))))) (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1))))))) (end {(if (is Connected Orthogonal Mover) (result Mover Win))}))) 
Resolve is a connection game for two players: a player with Black stones who wins by connecting the East/West sides, and a player with White stones who wins by connecting the North/South sides. Players take turns placing and swapping stones on the intersections of a square grid which is initially empty. Passing is forbidden. Same-colored stones with orthogonal adjacency are connected. The game is over when a player wins by connecting their designated sides of the board with a single group of connected stones of their color, at any time during their turn or their opponent's turn. Cutting stones are any four stones in a generic crosscut configuration. OX XO On your turn you must select the following one of two actions. 1. Place a stone of your color on an empty point. If that stone creates a crosscut, swap it with different adjacent enemy stones that share a crosscut with it, until that stone is no longer part of a crosscut. 2. Choose a stone of your color that is part of a crosscut, and use it to resolve crosscuts as in 1. Then place a stone of your color on an empty point, if possible. Order 5 board
(game "Resolve" (players 2) (equipment {(board (square 5) use:Vertex) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)}) (piece "Ball" P1) (piece "Ball" P2)}) (rules (play (if (not (is Prev Mover)) (or (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1)))) (forEach Site (sites Occupied by:Mover) (do (set Var "LT" (site)) next:(forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1))))))))))) (if (<= 0 (var "LT")) (forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1)))))))) (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1))))))) (end {(if (is Connected Orthogonal Mover) (result Mover Win))}))) 
Resolve is a connection game for two players: a player with Black stones who wins by connecting the East/West sides, and a player with White stones who wins by connecting the North/South sides. Players take turns placing and swapping stones on the intersections of a square grid which is initially empty. Passing is forbidden. Same-colored stones with orthogonal adjacency are connected. The game is over when a player wins by connecting their designated sides of the board with a single group of connected stones of their color, at any time during their turn or their opponent's turn. Cutting stones are any four stones in a generic crosscut configuration. OX XO On your turn you must select the following one of two actions. 1. Place a stone of your color on an empty point. If that stone creates a crosscut, swap it with different adjacent enemy stones that share a crosscut with it, until that stone is no longer part of a crosscut. 2. Choose a stone of your color that is part of a crosscut, and use it to resolve crosscuts as in 1. Then place a stone of your color on an empty point, if possible. Order 13 board
(game "Resolve" (players 2) (equipment {(board (square 13) use:Vertex) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)}) (piece "Ball" P1) (piece "Ball" P2)}) (rules (play (if (not (is Prev Mover)) (or (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1)))) (forEach Site (sites Occupied by:Mover) (do (set Var "LT" (site)) next:(forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1))))))))))) (if (<= 0 (var "LT")) (forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1)))))))) (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1))))))) (end {(if (is Connected Orthogonal Mover) (result Mover Win))}))) 
MOVE - Each player inserts a stone onto the board from an edge. Black inserts from top and pushes from top to bottom, White inserts from left and pushes from left to right. - Black starts with a stone on the top-left corner. - Passing is not allowed - If a stone, when pushed meets another stone, this too is pushed on the same direction, and so on... EDGE - A stone pushed off the edge during a push is returned to the player (there are no captures). If it is an opponent stone, this row/column cannot be used on the next turn (friendly stones do not have such restriction). GOAL - Wins the player which makes a path between the edges (top-bottom for Black, right-left for White). Stones may be connected orthogonal or diagonal.
(game "Tara" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Ball" Each) (regions P1 {(sites Top) (sites Bottom)}) (regions P2 {(sites Left) (sites Right)})}) (rules phases:{(phase "Opening" (play (move Add (to (intersection (sites Top) (sites Left))))) (nextPhase "Main")) (phase "Main" (play (if (is Mover P1) (move Select (from (sites Top) if:(not (is In (column of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:0 column:(column of:(last From))))) (set Pending (row of:(coord row:0 column:(column of:(last From)))))) (push (from (last To)) S) (add (piece (id "Ball" Mover)) (to (last To)))}))) (move Select (from (sites Left) if:(not (is In (row of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:(row of:(last From)) column:(- (count Columns) 1)))) (set Pending (column of:(coord row:(row of:(last From)) column:(- (count Columns) 1))))) (push (from (last To)) E) (add (piece (id "Ball" Mover)) (to (last To)))}))))))} (end {(if (!= 0 (count Sites in:(forEach (sites Occupied by:P1) if:(is Connected at:(site) All P1)))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(is Connected at:(site) All P2)))) (result P2 Win))}))) 
MOVE - Each player inserts a stone onto the board from an edge. Black inserts from top and pushes from top to bottom, White inserts from left and pushes from left to right. - Black starts with a stone on the top-left corner. - Passing is not allowed - If a stone, when pushed meets another stone, this too is pushed on the same direction, and so on... EDGE - A stone pushed off the edge during a push is returned to the player (there are no captures). If it is an opponent stone, this row/column cannot be used on the next turn (friendly stones do not have such restriction). GOAL - Wins the player which makes a path between the edges (top-bottom for Black, right-left for White). Stones may be connected orthogonal or diagonal.
(game "Tara" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Ball" Each) (regions P1 {(sites Top) (sites Bottom)}) (regions P2 {(sites Left) (sites Right)})}) (rules phases:{(phase "Opening" (play (move Add (to (intersection (sites Top) (sites Left))))) (nextPhase "Main")) (phase "Main" (play (if (is Mover P1) (move Select (from (sites Top) if:(not (is In (column of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:0 column:(column of:(last From))))) (set Pending (row of:(coord row:0 column:(column of:(last From)))))) (push (from (last To)) S) (add (piece (id "Ball" Mover)) (to (last To)))}))) (move Select (from (sites Left) if:(not (is In (row of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:(row of:(last From)) column:(- (count Columns) 1)))) (set Pending (column of:(coord row:(row of:(last From)) column:(- (count Columns) 1))))) (push (from (last To)) E) (add (piece (id "Ball" Mover)) (to (last To)))}))))))} (end {(if (!= 0 (count Sites in:(forEach (sites Occupied by:P1) if:(is Connected at:(site) All P1)))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(is Connected at:(site) All P2)))) (result P2 Win))}))) 
MOVE - Each player inserts a stone onto the board from an edge. Black inserts from top and pushes from top to bottom, White inserts from left and pushes from left to right. - Black starts with a stone on the top-left corner. - Passing is not allowed - If a stone, when pushed meets another stone, this too is pushed on the same direction, and so on... EDGE - A stone pushed off the edge during a push is returned to the player (there are no captures). If it is an opponent stone, this row/column cannot be used on the next turn (friendly stones do not have such restriction). GOAL - Wins the player which makes a path between the edges (top-bottom for Black, right-left for White). Stones may be connected orthogonal or diagonal.
(game "Tara" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Ball" Each) (regions P1 {(sites Top) (sites Bottom)}) (regions P2 {(sites Left) (sites Right)})}) (rules phases:{(phase "Opening" (play (move Add (to (intersection (sites Top) (sites Left))))) (nextPhase "Main")) (phase "Main" (play (if (is Mover P1) (move Select (from (sites Top) if:(not (is In (column of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:0 column:(column of:(last From))))) (set Pending (row of:(coord row:0 column:(column of:(last From)))))) (push (from (last To)) S) (add (piece (id "Ball" Mover)) (to (last To)))}))) (move Select (from (sites Left) if:(not (is In (row of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:(row of:(last From)) column:(- (count Columns) 1)))) (set Pending (column of:(coord row:(row of:(last From)) column:(- (count Columns) 1))))) (push (from (last To)) E) (add (piece (id "Ball" Mover)) (to (last To)))}))))))} (end {(if (!= 0 (count Sites in:(forEach (sites Occupied by:P1) if:(is Connected at:(site) All P1)))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(is Connected at:(site) All P2)))) (result P2 Win))}))) 
Pieces move to any adjacent empty square or jumping one of their pieces over an adjacent piece to the empty point immediately beyond. The game is won by the first player to move all six pieces into a single orthogonally connected group
(game "Groups" (players 2) (equipment {(board (square 8)) (piece "Disc" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to))))))}) (rules (start {(place "Disc1" {"D3" "C4" "E4" "D5" "F5" "E6"}) (place "Disc2" {"E3" "D4" "F4" "C5" "E5" "D6"})}) (play (forEach Piece)) (end (if (= 1 (count Groups Orthogonal if:(= (who at:(to)) Mover))) (result Mover Win))))) 
Pieces move to any adjacent empty square or jumping one of their pieces over an adjacent piece to the empty point immediately beyond. The game is won by the first player to move all six pieces into a single orthogonally connected group
(game "Groups" (players 2) (equipment {(board (square 8)) (piece "Disc" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to))))))}) (rules (start {(place "Disc1" {"D3" "C4" "E4" "D5" "F5" "E6"}) (place "Disc2" {"E3" "D4" "F4" "C5" "E5" "D6"})}) (play (forEach Piece)) (end (if (= 1 (count Groups Orthogonal if:(= (who at:(to)) Mover))) (result Mover Win))))) 
Pieces move to any adjacent empty square or jumping one of their pieces over an adjacent piece to the empty point immediately beyond. The game is won by the first player to move all six pieces into a single orthogonally connected group
(game "Groups" (players 2) (equipment {(board (square 8)) (piece "Disc" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to))))))}) (rules (start {(place "Disc1" {"D3" "C4" "E4" "D5" "F5" "E6"}) (place "Disc2" {"E3" "D4" "F4" "C5" "E5" "D6"})}) (play (forEach Piece)) (end (if (= 1 (count Groups Orthogonal if:(= (who at:(to)) Mover))) (result Mover Win))))) 
Players take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites. Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 5x5 board The version of the game played with 2 players.
(game "Omega" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each)}) (rules (play (move Add (piece (+ 1 (% (count Moves) (count Players)))) (to (sites Empty)) (then (if (!= (count MovesThisTurn) (- (count Players) 1)) (moveAgain))))) (end (if (and {(not (is Mover P1)) (is Next P1) (> (^ (count Players) 2) (count Sites in:(sites Empty)))}) (byScore {(score P1 (* (sizes Group P1))) (score P2 (* (sizes Group P2)))}))))) 
Players take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites. Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 4x4 board The version of the game played with 3 players.
(game "Omega" (players 3) (equipment {(board (hex 4)) (piece "Marker" Each)}) (rules (play (move Add (piece (+ 1 (% (count Moves) (count Players)))) (to (sites Empty)) (then (if (!= (count MovesThisTurn) (- (count Players) 1)) (moveAgain))))) (end (if (and {(not (is Mover P1)) (is Next P1) (> (^ (count Players) 2) (count Sites in:(sites Empty)))}) (byScore {(score P1 (* (sizes Group P1))) (score P2 (* (sizes Group P2))) (score P3 (* (sizes Group P3)))}))))) 
Players take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites. Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 6x6 board The version of the game played with 4 players.
(game "Omega" (players 4) (equipment {(board (hex 6)) (piece "Marker" Each)}) (rules (play (move Add (piece (+ 1 (% (count Moves) (count Players)))) (to (sites Empty)) (then (if (!= (count MovesThisTurn) (- (count Players) 1)) (moveAgain))))) (end (if (and {(not (is Mover P1)) (is Next P1) (> (^ (count Players) 2) (count Sites in:(sites Empty)))}) (byScore {(score P1 (* (sizes Group P1))) (score P2 (* (sizes Group P2))) (score P3 (* (sizes Group P3))) (score P4 (* (sizes Group P4)))}))))) 
Omny is played on the cells of any hexagonal grid where some or all of the cells are designated star cells. Players take turns placing a stone of one's own color on an empty cell. A group is a set of connected stones of the same color. A cut of a group X is any set of connected cells (empty or occupied by either player) including no stones in X. You win by making a group such that none of its cuts include more than half the cells of the board. For serious play it is advised to play with a balance rule in force. In Misère Omny you lose if you make a group whose cuts each contain no more than half of the star cells. A hex board is currently selected A size 7 board is currently selected The currently selected star cells are all the cells on the board. The pie rule is currently in force The standard win condition is currently selected.
(game "Omny" (players 2) (equipment {(board (hex 7)) (piece "Disc" Each)}) (rules (play (if (= 1 (var)) (or (move Swap Players P1 P2) (move Add (to (sites Empty)) (then (set Var 0)))) (move Add (to (sites Empty)) (then (if (= 1 (count Moves)) (set Var 1)))))) (end (if (>= (count Sites in:(sites Board)) (max (results from:(difference (sites Board) (sites Group at:(last To))) to:2 (* (to) (count Sites in:(intersection (sites Board) (sites Group at:(from) if:(not (is In (to) (sites Group at:(last To))))))))))) (result Mover Win))))) 
Omny is played on the cells of any hexagonal grid where some or all of the cells are designated star cells. Players take turns placing a stone of one's own color on an empty cell. A group is a set of connected stones of the same color. A cut of a group X is any set of connected cells (empty or occupied by either player) including no stones in X. You win by making a group such that none of its cuts include more than half the cells of the board. For serious play it is advised to play with a balance rule in force. In Misère Omny you lose if you make a group whose cuts each contain no more than half of the star cells. A triangluar board is currently selected A size 3 board is currently selected The currently selected star cells are the perimeter cells cells The 12* placement protocol is currently in force The misère win condition is currently selected
(game "Omny" (players 2) (equipment {(board (hex Triangle 3)) (piece "Disc" Each)}) (rules (play (if (= 1 (var)) (or (move Swap Players P1 P2) (move Add (to (sites Empty)) (then (set Var 0)))) (move Add (to (sites Empty)) (then (if (= 1 (% (+ 1 (count Moves)) 2)) (moveAgain)))))) (end (if (>= (count Sites in:(sites Outer)) (max (results from:(difference (sites Board) (sites Group at:(last To))) to:2 (* (to) (count Sites in:(intersection (sites Outer) (sites Group at:(from) if:(not (is In (to) (sites Group at:(last To))))))))))) (result Mover Loss))))) 
Omny is played on the cells of any hexagonal grid where some or all of the cells are designated star cells. Players take turns placing a stone of one's own color on an empty cell. A group is a set of connected stones of the same color. A cut of a group X is any set of connected cells (empty or occupied by either player) including no stones in X. You win by making a group such that none of its cuts include more than half the cells of the board. For serious play it is advised to play with a balance rule in force. In Misère Omny you lose if you make a group whose cuts each contain no more than half of the star cells. A diamond shaped board is currently selected A size 4 board is currently selected The currently selected star cells are the corner cells No balance rule is currently in force The standard win condition is currently selected.
(game "Omny" (players 2) (equipment {(board (hex Diamond 4)) (piece "Disc" Each)}) (rules (play (if (= 1 (var)) (or (move Swap Players P1 P2) (move Add (to (sites Empty)) (then (set Var 0)))) (move Add (to (sites Empty))))) (end (if (>= (count Sites in:(sites Corners)) (max (results from:(difference (sites Board) (sites Group at:(last To))) to:2 (* (to) (count Sites in:(intersection (sites Corners) (sites Group at:(from) if:(not (is In (to) (sites Group at:(last To))))))))))) (result Mover Win))))) 
Goal: Scoring is based on your largest group (x2), with an extra point given to the first player to create a given size. The player with the largest group at the end of the game thus wins, and ties go to the first player to achieve this goal. Setup: Yellow starts by creating a set-up, then Orange begins actual play - Pass to skip this phase To create a set-up, Yellow first places a black blocking stone on any intersection and then a Yellow stone on an empty edge position. Orange then either begins play, or else exchanges the yellow piece with his own. Play: Players take turns placing their piece on an empty intersection that is either along the edge or next to another fiendly piece, but never adjacent to an enemy position. These placements are subject to 2 possible additional restrictions selected by the players before starting: A) The number range of friendly neighbors the piece being placed may have: (Standard is to play with no restriction.) and/or B) The maximum number of neighbors that are allowed for the pieces against which the piece may be placed, with 2 being standard play. Ending the game. Play continues until both players pass consecutively, and then the final scores are compared. Board & size: Hexhex with edges alternating 4 and 6 Place next to any friendly piece(s), but not next to pieces that already have more than 2 neighbors.
(game "RootZone" (players 2) (equipment {(board (tri {4 6 4 7 4}) use:Vertex) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (if (= -1 (counter)) (or (move Pass) (move Add (piece "Disc0") (to (sites Board)))) (or {(if (= 1 (counter)) (move Select (from (sites Occupied by:Enemy)) (then (remove (last To) (then (add (to (last To)))))))) (move Pass) (move Add (to (difference (union (sites Outer) (sites Around (sites Occupied by:Mover))) (union {(sites Around (sites Occupied by:Enemy)) (sites Around (forEach (sites Occupied by:Mover) if:(<= 3 (count Pieces Mover in:(sites Around (site)))))) (sites Around (sites Occupied by:Neutral))})) if:(and (is Empty (to)) (>= 6 (count Pieces Mover in:(sites Around (to)))))) (then (if (> (* 2 (size Group at:(last To))) (score Mover)) (if (> (* 2 (size Group at:(last To))) (score Next)) (set Score Mover (+ 1 (* 2 (size Group at:(last To))))) (set Score Mover (* 2 (size Group at:(last To))))))))}))) (end (if (all Passed) (byScore))))) 
Goal: Scoring is based on your largest group (x2), with an extra point given to the first player to create a given size. The player with the largest group at the end of the game thus wins, and ties go to the first player to achieve this goal. Setup: Yellow starts by creating a set-up, then Orange begins actual play - Pass to skip this phase To create a set-up, Yellow first places a black blocking stone on any intersection and then a Yellow stone on an empty edge position. Orange then either begins play, or else exchanges the yellow piece with his own. Play: Players take turns placing their piece on an empty intersection that is either along the edge or next to another fiendly piece, but never adjacent to an enemy position. These placements are subject to 2 possible additional restrictions selected by the players before starting: A) The number range of friendly neighbors the piece being placed may have: (Standard is to play with no restriction.) and/or B) The maximum number of neighbors that are allowed for the pieces against which the piece may be placed, with 2 being standard play. Ending the game. Play continues until both players pass consecutively, and then the final scores are compared. Board & size: Hexhex with edges alternating 2 and 4 Must place next to 1-2 friendly pieces, but not next to enemy pieces.
(game "RootZone" (players 2) (equipment {(board (tri {2 4 2 4 2}) use:Vertex) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (if (= -1 (counter)) (or (move Pass) (move Add (piece "Disc0") (to (sites Board)))) (or {(if (= 1 (counter)) (move Select (from (sites Occupied by:Enemy)) (then (remove (last To) (then (add (to (last To)))))))) (move Pass) (move Add (to (difference (union (sites Outer) (sites Around (sites Occupied by:Mover))) (union {(sites Around (sites Occupied by:Enemy)) (sites Around (forEach (sites Occupied by:Mover) if:(<= 6 (count Pieces Mover in:(sites Around (site)))))) (sites Around (sites Occupied by:Neutral))})) if:(and (is Empty (to)) (>= 2 (count Pieces Mover in:(sites Around (to)))))) (then (if (> (* 2 (size Group at:(last To))) (score Mover)) (if (> (* 2 (size Group at:(last To))) (score Next)) (set Score Mover (+ 1 (* 2 (size Group at:(last To))))) (set Score Mover (* 2 (size Group at:(last To))))))))}))) (end (if (all Passed) (byScore))))) 
Goal: Scoring is based on your largest group (x2), with an extra point given to the first player to create a given size. The player with the largest group at the end of the game thus wins, and ties go to the first player to achieve this goal. Setup: Yellow starts by creating a set-up, then Orange begins actual play - Pass to skip this phase To create a set-up, Yellow first places a black blocking stone on any intersection and then a Yellow stone on an empty edge position. Orange then either begins play, or else exchanges the yellow piece with his own. Play: Players take turns placing their piece on an empty intersection that is either along the edge or next to another fiendly piece, but never adjacent to an enemy position. These placements are subject to 2 possible additional restrictions selected by the players before starting: A) The number range of friendly neighbors the piece being placed may have: (Standard is to play with no restriction.) and/or B) The maximum number of neighbors that are allowed for the pieces against which the piece may be placed, with 2 being standard play. Ending the game. Play continues until both players pass consecutively, and then the final scores are compared. Board & size: Hexhex with edges alternating 6 and 8 Must place next to exactly one friendly piece, but not next to pieces that already have more than 1 neighbor.
(game "RootZone" (players 2) (equipment {(board (tri {6 8 6 10 5}) use:Vertex) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (if (= -1 (counter)) (or (move Pass) (move Add (piece "Disc0") (to (sites Board)))) (or {(if (= 1 (counter)) (move Select (from (sites Occupied by:Enemy)) (then (remove (last To) (then (add (to (last To)))))))) (move Pass) (move Add (to (difference (union (sites Outer) (sites Around (sites Occupied by:Mover))) (union {(sites Around (sites Occupied by:Enemy)) (sites Around (forEach (sites Occupied by:Mover) if:(<= 2 (count Pieces Mover in:(sites Around (site)))))) (sites Around (sites Occupied by:Neutral))})) if:(and (is Empty (to)) (>= 1 (count Pieces Mover in:(sites Around (to)))))) (then (if (> (* 2 (size Group at:(last To))) (score Mover)) (if (> (* 2 (size Group at:(last To))) (score Next)) (set Score Mover (+ 1 (* 2 (size Group at:(last To))))) (set Score Mover (* 2 (size Group at:(last To))))))))}))) (end (if (all Passed) (byScore))))) 
MOVE - On each turn, each player move one of his stones into an adjacent orthogonal empty cell. GOAL - Wins the player that makes a (orthogonal or diagonal) 3 in-a-row.
(game "A Simple Game" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "Ball1" (intersection (sites Phase 0) (union (sites Top) (sites Bottom)))) (place "Ball2" (intersection (sites Phase 1) (union (sites Top) (sites Bottom))))}) (play (forEach Piece)) (end (if (is Line 3 All) (result Mover Win))))) 
MOVE - On each turn, each player move one of his stones into an adjacent orthogonal empty cell. GOAL - Wins the player that makes a (orthogonal or diagonal) 3 in-a-row.
(game "A Simple Game" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "Ball1" (intersection (sites Phase 0) (union (sites Top) (sites Bottom)))) (place "Ball2" (intersection (sites Phase 1) (union (sites Top) (sites Bottom))))}) (play (forEach Piece)) (end (if (is Line 3 All) (result Mover Win))))) 
MOVE - On each turn, each player move one of his stones into an adjacent orthogonal empty cell. GOAL - Wins the player that makes a (orthogonal or diagonal) 3 in-a-row.
(game "A Simple Game" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "Ball1" (intersection (sites Phase 0) (union (sites Top) (sites Bottom)))) (place "Ball2" (intersection (sites Phase 1) (union (sites Top) (sites Bottom))))}) (play (forEach Piece)) (end (if (is Line 3 All) (result Mover Win))))) 
Each player has 6 Chess queens. It is played on a 5x5 board. The starting position has the queens arranged on opposite sides, alternating white-black-white-black in each space. The pieces move as queens in Chess. The first player to line up four queens in a row wins.
(game "All Queens Chess" (players 2) (equipment {(board (square 5)) (piece "Queen" Each (move Slide))}) (rules (start {(place "Queen1" (union {(difference (sites Bottom) (sites Phase 1)) (intersection (sites Left) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 0))})) (place "Queen2" (union {(difference (sites Bottom) (sites Phase 0)) (intersection (sites Right) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 1))}))}) (play (forEach Piece)) (end (if (is Line 4) (result Mover Win))))) 
Each player has 6 Chess queens. It is played on a 5x5 board. The starting position has the queens arranged on opposite sides, alternating white-black-white-black in each space. The pieces move as queens in Chess. The first player to line up four queens in a row wins.
(game "All Queens Chess" (players 2) (equipment {(board (square 5)) (piece "Queen" Each (move Slide))}) (rules (start {(place "Queen1" (union {(difference (sites Bottom) (sites Phase 1)) (intersection (sites Left) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 0))})) (place "Queen2" (union {(difference (sites Bottom) (sites Phase 0)) (intersection (sites Right) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 1))}))}) (play (forEach Piece)) (end (if (is Line 4) (result Mover Win))))) 
Each player has 6 Chess queens. It is played on a 5x5 board. The starting position has the queens arranged on opposite sides, alternating white-black-white-black in each space. The pieces move as queens in Chess. The first player to line up four queens in a row wins.
(game "All Queens Chess" (players 2) (equipment {(board (square 5)) (piece "Queen" Each (move Slide))}) (rules (start {(place "Queen1" (union {(difference (sites Bottom) (sites Phase 1)) (intersection (sites Left) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 0))})) (place "Queen2" (union {(difference (sites Bottom) (sites Phase 0)) (intersection (sites Right) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 1))}))}) (play (forEach Piece)) (end (if (is Line 4) (result Mover Win))))) 
The game starts with a tile of each color touching one another. Players take turns placing tiles which must touch at least two other tiles. A player wins by either completely surrounding one or more of the opponent's tiles, or by creating a straight line of five tiles. The game uses hexagonal tiles.
(game "Andantino" (players 2) (equipment {(boardless Hexagonal) (tile "Hex" Each numSides:6)}) (rules (start {(place "Hex1" (centrePoint)) (place "Hex2" (ahead (centrePoint) E))}) (play (move Add (to (sites Playable) if:(<= 2 (count Sites in:(sites Around (to) NotEmpty)))))) (end {(if (or (is Loop surround:Next) (is Line 5)) (result Mover Win)) (if (= (count Moves) (* (count Players) 24)) (result Mover Draw))}))) 
The game starts with a tile of each color touching one another. Players take turns placing tiles which must touch at least two other tiles. A player wins by either completely surrounding one or more of the opponent's tiles, or by creating a straight line of five tiles. The game uses square tiles
(game "Andantino" (players 2) (equipment {(boardless Square) (tile "Square" Each numSides:4)}) (rules (start {(place "Square1" (centrePoint)) (place "Square2" (ahead (centrePoint) E))}) (play (move Add (to (sites Playable) if:(<= 2 (count Sites in:(sites Around (to) NotEmpty)))))) (end {(if (or (is Loop surround:Next) (is Line 5)) (result Mover Win)) (if (= (count Moves) (* (count Players) 24)) (result Mover Draw))}))) 
The game starts with a tile of each color touching one another. Players take turns placing tiles which must touch at least two other tiles. A player wins by either completely surrounding one or more of the opponent's tiles, or by creating a straight line of five tiles. The game uses triangle tiles
(game "Andantino" (players 2) (equipment {(boardless Triangular) (tile "Triangle" Each numSides:3)}) (rules (start {(place "Triangle1" (centrePoint)) (place "Triangle2" (ahead (centrePoint) E))}) (play (move Add (to (sites Playable) if:(<= 2 (count Sites in:(sites Around (to) NotEmpty)))))) (end {(if (or (is Loop surround:Next) (is Line 5)) (result Mover Win)) (if (= (count Moves) (* (count Players) 24)) (result Mover Draw))}))) 
6x6 board. Each player has twelve sticks. One player's sticks are without bark to distinguish them. Players placing their sticks in empty spaces, filling the central four first. Once all of the sticks have been placed, the players may move their sticks orthogonally one space. If a player can bring three of their sticks in a row, they may then remove one of the opponent's sticks during either phase of the game. During the movement phase, if a player has a row of four pieces and moves one away, leaving a row of three spaces, this also allows the player to capture an opponent's piece. The player who can no longer play loses.
(game "Dala" (players 2) (equipment {(board (square 6)) (hand Each) (piece "Stick" Each (if (is Line 4 Orthogonal through:(from) exact:True) (move Step Orthogonal (to if:(is Empty (to))) (then (and {(if (and (!= (last From) (ahead (last From) N)) (= (mover) (who at:(ahead (last From) N)))) (if (is Line 3 Orthogonal through:(ahead (last From) N) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) S)) (= (mover) (who at:(ahead (last From) S)))) (if (is Line 3 Orthogonal through:(ahead (last From) S) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) E)) (= (mover) (who at:(ahead (last From) E)))) (if (is Line 3 Orthogonal through:(ahead (last From) E) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) W)) (= (mover) (who at:(ahead (last From) W)))) (if (is Line 3 Orthogonal through:(ahead (last From) W) exact:True) (and (moveAgain) (addScore Mover 1))))}))) (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1)))))))}) (rules (start (place "Stick" "Hand" count:12)) phases:{(phase "PlacementCenter" (play (move (from (handSite Mover)) (to (forEach (sites Centre) if:(is Empty (site)))))) (nextPhase (= (count Moves) 4) "Placement")) (phase "Placement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1))))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (forEach Piece))) (end (if (<= (count Pieces Next) 2) (result Next Loss))))})) 
6x6 board. Each player has twelve sticks. One player's sticks are without bark to distinguish them. Players placing their sticks in empty spaces, filling the central four first. Once all of the sticks have been placed, the players may move their sticks orthogonally one space. If a player can bring three of their sticks in a row, they may then remove one of the opponent's sticks during either phase of the game. During the movement phase, if a player has a row of four pieces and moves one away, leaving a row of three spaces, this also allows the player to capture an opponent's piece. The player who can no longer play loses.
(game "Dala" (players 2) (equipment {(board (square 6)) (hand Each) (piece "Stick" Each (if (is Line 4 Orthogonal through:(from) exact:True) (move Step Orthogonal (to if:(is Empty (to))) (then (and {(if (and (!= (last From) (ahead (last From) N)) (= (mover) (who at:(ahead (last From) N)))) (if (is Line 3 Orthogonal through:(ahead (last From) N) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) S)) (= (mover) (who at:(ahead (last From) S)))) (if (is Line 3 Orthogonal through:(ahead (last From) S) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) E)) (= (mover) (who at:(ahead (last From) E)))) (if (is Line 3 Orthogonal through:(ahead (last From) E) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) W)) (= (mover) (who at:(ahead (last From) W)))) (if (is Line 3 Orthogonal through:(ahead (last From) W) exact:True) (and (moveAgain) (addScore Mover 1))))}))) (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1)))))))}) (rules (start (place "Stick" "Hand" count:12)) phases:{(phase "PlacementCenter" (play (move (from (handSite Mover)) (to (forEach (sites Centre) if:(is Empty (site)))))) (nextPhase (= (count Moves) 4) "Placement")) (phase "Placement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1))))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (forEach Piece))) (end (if (<= (count Pieces Next) 2) (result Next Loss))))})) 
6x6 board. Each player has twelve sticks. One player's sticks are without bark to distinguish them. Players placing their sticks in empty spaces, filling the central four first. Once all of the sticks have been placed, the players may move their sticks orthogonally one space. If a player can bring three of their sticks in a row, they may then remove one of the opponent's sticks during either phase of the game. During the movement phase, if a player has a row of four pieces and moves one away, leaving a row of three spaces, this also allows the player to capture an opponent's piece. The player who can no longer play loses.
(game "Dala" (players 2) (equipment {(board (square 6)) (hand Each) (piece "Stick" Each (if (is Line 4 Orthogonal through:(from) exact:True) (move Step Orthogonal (to if:(is Empty (to))) (then (and {(if (and (!= (last From) (ahead (last From) N)) (= (mover) (who at:(ahead (last From) N)))) (if (is Line 3 Orthogonal through:(ahead (last From) N) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) S)) (= (mover) (who at:(ahead (last From) S)))) (if (is Line 3 Orthogonal through:(ahead (last From) S) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) E)) (= (mover) (who at:(ahead (last From) E)))) (if (is Line 3 Orthogonal through:(ahead (last From) E) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) W)) (= (mover) (who at:(ahead (last From) W)))) (if (is Line 3 Orthogonal through:(ahead (last From) W) exact:True) (and (moveAgain) (addScore Mover 1))))}))) (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1)))))))}) (rules (start (place "Stick" "Hand" count:12)) phases:{(phase "PlacementCenter" (play (move (from (handSite Mover)) (to (forEach (sites Centre) if:(is Empty (site)))))) (nextPhase (= (count Moves) 4) "Placement")) (phase "Placement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1))))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (forEach Piece))) (end (if (<= (count Pieces Next) 2) (result Next Loss))))})) 
5x6 board. Players have 12 pieces each. They take turns placing pieces on an empty board.Once all pieces are placed, players can move pieces orthogonally to an adjacent space, attempting to make three in a row. When three in a row are made, an opponent's piece is removed from the board that is not in a three in a row pattern. Placing more than three in a row is not allowed. Three in a row during the initial phase of the game does not count. When a player has only two pieces left, they lose. Lines of 4 cannot be made during the drop phase.
(game "Dara" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 4 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (do (forEach Piece) ifAfterwards:(not (is Line 4 Orthogonal))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
5x6 board. Players have 12 pieces each. They take turns placing pieces on an empty board.Once all pieces are placed, players can move pieces orthogonally to an adjacent space, attempting to make three in a row. When three in a row are made, an opponent's piece is removed from the board that is not in a three in a row pattern. Placing more than three in a row is not allowed. Three in a row during the initial phase of the game does not count. When a player has only two pieces left, they lose. Lines of 3 cannot be made during the drop phase.
(game "Dara" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (do (forEach Piece) ifAfterwards:(not (is Line 4 Orthogonal))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
5x6 board. Players have 12 pieces each. They take turns placing pieces on an empty board.Once all pieces are placed, players can move pieces orthogonally to an adjacent space, attempting to make three in a row. When three in a row are made, an opponent's piece is removed from the board that is not in a three in a row pattern. Placing more than three in a row is not allowed. Three in a row during the initial phase of the game does not count. When a player has only two pieces left, they lose. Lines of 4 cannot be made during the drop phase.
(game "Dara" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 4 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (do (forEach Piece) ifAfterwards:(not (is Line 4 Orthogonal))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Two players. Players alternate turns placing one of their pieces on one of the spots on the board. A player may place a piece on top of a piece belonging to their opponent during this phase of the game, and they are both canceled out. When three uncanceled pieces form a row along the lines on the board, the player may capture one of the opponent's pieces. Once all of the spots have been occupied, the canceled pieces are removed. Players alternate turns moving one of their pieces to an empty adjacent spot on the board.The player who captures all of the opponent's pieces wins.
(game "Dig Dig" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))))}) (rules (start {(place Stack "Marker1" (handSite P1)) (place Stack "Marker2" (handSite P2))}) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (move (from (handSite Mover)) (to (union (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site)))) (sites Empty))) copy:True (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))) (then (if (and (not (is Next Mover)) (is Full)) (and {(forEach Site (forEach (sites Occupied by:P1 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (forEach Site (forEach (sites Occupied by:P2 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (set Pending)}))))) (nextPhase (is Pending) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (forEach Piece))) (end (if (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites Board)))) (result Mover Win))))})) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Two players. Players alternate turns placing one of their pieces on one of the spots on the board. A player may place a piece on top of a piece belonging to their opponent during this phase of the game, and they are both canceled out. When three uncanceled pieces form a row along the lines on the board, the player may capture one of the opponent's pieces. Once all of the spots have been occupied, the canceled pieces are removed. Players alternate turns moving one of their pieces to an empty adjacent spot on the board.The player who captures all of the opponent's pieces wins.
(game "Dig Dig" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))))}) (rules (start {(place Stack "Marker1" (handSite P1)) (place Stack "Marker2" (handSite P2))}) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (move (from (handSite Mover)) (to (union (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site)))) (sites Empty))) copy:True (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))) (then (if (and (not (is Next Mover)) (is Full)) (and {(forEach Site (forEach (sites Occupied by:P1 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (forEach Site (forEach (sites Occupied by:P2 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (set Pending)}))))) (nextPhase (is Pending) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (forEach Piece))) (end (if (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites Board)))) (result Mover Win))))})) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Two players. Players alternate turns placing one of their pieces on one of the spots on the board. A player may place a piece on top of a piece belonging to their opponent during this phase of the game, and they are both canceled out. When three uncanceled pieces form a row along the lines on the board, the player may capture one of the opponent's pieces. Once all of the spots have been occupied, the canceled pieces are removed. Players alternate turns moving one of their pieces to an empty adjacent spot on the board.The player who captures all of the opponent's pieces wins.
(game "Dig Dig" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))))}) (rules (start {(place Stack "Marker1" (handSite P1)) (place Stack "Marker2" (handSite P2))}) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (move (from (handSite Mover)) (to (union (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site)))) (sites Empty))) copy:True (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))) (then (if (and (not (is Next Mover)) (is Full)) (and {(forEach Site (forEach (sites Occupied by:P1 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (forEach Site (forEach (sites Occupied by:P2 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (set Pending)}))))) (nextPhase (is Pending) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (forEach Piece))) (end (if (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites Board)))) (result Mover Win))))})) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins.
(game "Driesticken" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins.
(game "Driesticken" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins.
(game "Driesticken" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position.
(game "Epelle" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position.
(game "Epelle" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position.
(game "Epelle" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
Three concentric triangles, with lines connecting their midpoints and corners. Eight pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. When a player places three of their pieces in a row, they remove one of the opponent's pieces from the board. A piece that is in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Gurgaldaj" (players 2) (equipment {(board (concentric Triangle rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:8)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric triangles, with lines connecting their midpoints and corners. Eight pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. When a player places three of their pieces in a row, they remove one of the opponent's pieces from the board. A piece that is in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Gurgaldaj" (players 2) (equipment {(board (concentric Triangle rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:8)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric triangles, with lines connecting their midpoints and corners. Eight pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. When a player places three of their pieces in a row, they remove one of the opponent's pieces from the board. A piece that is in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Gurgaldaj" (players 2) (equipment {(board (concentric Triangle rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:8)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Keryo-Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair or a line of three enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 15 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Keryo-Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) phases:{(phase "Opening" (play (move Add (to (sites "J10")))) (nextPhase "General")) (phase "General" (play (move Add (to (sites Empty)) (then (custodial (from (last To)) All (between if:(is Next (who at:(between))) (apply (remove (between)))) (to if:(and (or (= 3 (count Steps Vertex All (last To) (to))) (= 4 (count Steps Vertex All (last To) (to)))) (is Mover (who at:(to))))) (then (addScore Mover 1)))))))} (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 14) (result Mover Win))}))) 
Keryo-Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair or a line of three enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 15 enemy stones, wins the game. Played on a 19x19 board. Open anywhere.
(game "Keryo-Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) (play (move Add (to (sites Empty)))) (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 14) (result Mover Win))}))) 
Keryo-Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair or a line of three enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 15 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Keryo-Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) phases:{(phase "Opening" (play (move Add (to (sites "J10")))) (nextPhase "General")) (phase "General" (play (move Add (to (sites Empty)) (then (custodial (from (last To)) All (between if:(is Next (who at:(between))) (apply (remove (between)))) (to if:(and (or (= 3 (count Steps Vertex All (last To) (to))) (= 4 (count Steps Vertex All (last To) (to)))) (is Mover (who at:(to))))) (then (addScore Mover 1)))))))} (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 14) (result Mover Win))}))) 
Three concentric squares, with lines connecting the midpoints of the sides. Nine pieces per player. Players alternate turns placing a piece on the board. When a player places three of their pieces in a line of three along one of the lines on the board, they capture one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving one of their pieces to an adjacent empty spot on the board. Players cannot capture one of their opponent's pieces which is in a three-in-a-row alignment. The player who either captures seven of their opponent's pieces or blocks the opponent from being able to move wins.
(game "La Chascona" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (forEach Piece))))} (end (if (or (no Moves Next) (<= (count Pieces Next) 2)) (result Mover Win))))) 
Three concentric squares, with lines connecting the midpoints of the sides. Nine pieces per player. Players alternate turns placing a piece on the board. When a player places three of their pieces in a line of three along one of the lines on the board, they capture one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving one of their pieces to an adjacent empty spot on the board. Players cannot capture one of their opponent's pieces which is in a three-in-a-row alignment. The player who either captures seven of their opponent's pieces or blocks the opponent from being able to move wins.
(game "La Chascona" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (forEach Piece))))} (end (if (or (no Moves Next) (<= (count Pieces Next) 2)) (result Mover Win))))) 
Three concentric squares, with lines connecting the midpoints of the sides. Nine pieces per player. Players alternate turns placing a piece on the board. When a player places three of their pieces in a line of three along one of the lines on the board, they capture one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving one of their pieces to an adjacent empty spot on the board. Players cannot capture one of their opponent's pieces which is in a three-in-a-row alignment. The player who either captures seven of their opponent's pieces or blocks the opponent from being able to move wins.
(game "La Chascona" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (forEach Piece))))} (end (if (or (no Moves Next) (<= (count Pieces Next) 2)) (result Mover Win))))) 
5x5 intersecting lines, with diagonals in the quadrants. Five pieces per player. Players alternate turns placing a piece on the board. Once all of the pieces are placed on the board, players alternate turns moving a piece to an empty adjacent spot on the board. The player who places all five of their pieces in a line wins.
(game "Marelle Quadruple" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:5)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 5) (result Mover Win))))) 
5x5 intersecting lines, with diagonals in the quadrants. Five pieces per player. Players alternate turns placing a piece on the board. Once all of the pieces are placed on the board, players alternate turns moving a piece to an empty adjacent spot on the board. The player who places all five of their pieces in a line wins.
(game "Marelle Quadruple" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:5)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 5) (result Mover Win))))) 
5x5 intersecting lines, with diagonals in the quadrants. Five pieces per player. Players alternate turns placing a piece on the board. Once all of the pieces are placed on the board, players alternate turns moving a piece to an empty adjacent spot on the board. The player who places all five of their pieces in a line wins.
(game "Marelle Quadruple" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:5)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 5) (result Mover Win))))) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one of the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins.
(game "Mlabalaba" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (if (= 3 (count Pieces Mover)) (move (from (from)) (to (sites Empty))) (move Step (to if:(is Empty (to)))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (forEach NonMover if:(= 2 (count Pieces Player)) (result Player Loss))))) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one of the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins.
(game "Mlabalaba" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (if (= 3 (count Pieces Mover)) (move (from (from)) (to (sites Empty))) (move Step (to if:(is Empty (to)))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (forEach NonMover if:(= 2 (count Pieces Player)) (result Player Loss))))) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one of the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins.
(game "Mlabalaba" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (if (= 3 (count Pieces Mover)) (move (from (from)) (to (sites Empty))) (move Step (to if:(is Empty (to)))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (forEach NonMover if:(= 2 (count Pieces Player)) (result Player Loss))))) 
Three concentric squares, with lines connecting the midpoints of the squares with the center of the square and four lines connecting the corners of the outer two squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one fo the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins.
(game "Morabaraba" (players 2) (equipment {(board (remove (add (concentric Square rings:3 joinCorners:True) vertices:{{0 0}} edges:{{11 24} {16 24} {7 24} {12 24}}) edges:{{3 6} {8 5} {17 20} {15 18}}) use:Vertex) (hand Each) (piece "Marker" Each (if (> (count Pieces Mover) 3) (move Step (to if:(is Empty (to)))) (move (from) (to (sites Empty))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric squares, with lines connecting the midpoints of the squares with the center of the square and four lines connecting the corners of the outer two squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one fo the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins.
(game "Morabaraba" (players 2) (equipment {(board (remove (add (concentric Square rings:3 joinCorners:True) vertices:{{0 0}} edges:{{11 24} {16 24} {7 24} {12 24}}) edges:{{3 6} {8 5} {17 20} {15 18}}) use:Vertex) (hand Each) (piece "Marker" Each (if (> (count Pieces Mover) 3) (move Step (to if:(is Empty (to)))) (move (from) (to (sites Empty))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric squares, with lines connecting the midpoints of the squares with the center of the square and four lines connecting the corners of the outer two squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one fo the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins.
(game "Morabaraba" (players 2) (equipment {(board (remove (add (concentric Square rings:3 joinCorners:True) vertices:{{0 0}} edges:{{11 24} {16 24} {7 24} {12 24}}) edges:{{3 6} {8 5} {17 20} {15 18}}) use:Vertex) (hand Each) (piece "Marker" Each (if (> (count Pieces Mover) 3) (move Step (to if:(is Empty (to)))) (move (from) (to (sites Empty))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. A player may also win by blocking their opponent from being able to move.
(game "Mylna" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end {(if (<= (count Pieces Next) 2) (result Next Loss)) (if (no Moves Next) (result Mover Win))}))) 
Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. A player may also win by blocking their opponent from being able to move.
(game "Mylna" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end {(if (<= (count Pieces Next) 2) (result Next Loss)) (if (no Moves Next) (result Mover Win))}))) 
Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. A player may also win by blocking their opponent from being able to move.
(game "Mylna" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end {(if (<= (count Pieces Next) 2) (result Next Loss)) (if (no Moves Next) (result Mover Win))}))) 
Three concentric squares with lines connecting the midpoints of the squares. Nine pieces per player. Players alternate turns placing one of their pieces on an empty space. If a player places three of their pieces along one of the straight lines, they take another turn. Once all of the pieces are on the board, players take turns moving a piece to an empty space on the board. When a player creates a line of three in this phase, the player removes one of the opponent's pieces, and receives another turn. The player who reduces the opponent to two pieces wins.
(game "Nerenchi Keliya" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (if (and (is Line 3) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (moveAgain))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (forEach Piece)) (nextPhase Mover (is Line 3) "Capture")) (phase "Capture" (play (move Remove (sites Occupied by:Enemy container:"Board") (then (moveAgain)))) (nextPhase Mover "Movement"))} (end (forEach Player if:(<= (count Pieces Player) 2) (result Player Loss))))) 
Three concentric squares with lines connecting the midpoints of the squares. Nine pieces per player. Players alternate turns placing one of their pieces on an empty space. If a player places three of their pieces along one of the straight lines, they take another turn. Once all of the pieces are on the board, players take turns moving a piece to an empty space on the board. When a player creates a line of three in this phase, the player removes one of the opponent's pieces, and receives another turn. The player who reduces the opponent to two pieces wins.
(game "Nerenchi Keliya" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (if (and (is Line 3) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (moveAgain))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (forEach Piece)) (nextPhase Mover (is Line 3) "Capture")) (phase "Capture" (play (move Remove (sites Occupied by:Enemy container:"Board") (then (moveAgain)))) (nextPhase Mover "Movement"))} (end (forEach Player if:(<= (count Pieces Player) 2) (result Player Loss))))) 
Three concentric squares with lines connecting the midpoints of the squares. Nine pieces per player. Players alternate turns placing one of their pieces on an empty space. If a player places three of their pieces along one of the straight lines, they take another turn. Once all of the pieces are on the board, players take turns moving a piece to an empty space on the board. When a player creates a line of three in this phase, the player removes one of the opponent's pieces, and receives another turn. The player who reduces the opponent to two pieces wins.
(game "Nerenchi Keliya" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (if (and (is Line 3) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (moveAgain))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (forEach Piece)) (nextPhase Mover (is Line 3) "Capture")) (phase "Capture" (play (move Remove (sites Occupied by:Enemy container:"Board") (then (moveAgain)))) (nextPhase Mover "Movement"))} (end (forEach Player if:(<= (count Pieces Player) 2) (result Player Loss))))) 
3x3 intersecting lines with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player succeeds in making a line of three with their pieces, they win.
(game "Ngre E E" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player succeeds in making a line of three with their pieces, they win.
(game "Ngre E E" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player succeeds in making a line of three with their pieces, they win.
(game "Ngre E E" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). In the Pro Pente variation, White's second move must be at least 3 points away from the centre. After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair of enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 10 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) phases:{(phase "Opening" (play (move Add (to (sites "J10")))) (nextPhase "General")) (phase "General" (play (move Add (to (sites Empty)) (then (custodial (from (last To)) All (between if:(is Next (who at:(between))) (apply (remove (between)))) (to if:(and (= 3 (count Steps Vertex All (last To) (to))) (is Mover (who at:(to))))) (then (addScore Mover 1)))))))} (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 9) (result Mover Win))}))) 
Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). In the Pro Pente variation, White's second move must be at least 3 points away from the centre. After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair of enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 10 enemy stones, wins the game. Played on a 19x19 board. Open anywhere.
(game "Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) (play (move Add (to (sites Empty)))) (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 9) (result Mover Win))}))) 
Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). In the Pro Pente variation, White's second move must be at least 3 points away from the centre. After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair of enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 10 enemy stones, wins the game. Played on a 19x19 board. White's second move must be 3 points away from the centre.
(game "Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) phases:{(phase "First Move" (play (move Add (to (sites "J10")))) (nextPhase "Second Move")) (phase "Second Move" (play (move Add (to (sites Empty)))) (nextPhase "Third Move")) (phase "Third Move" (play (move Add (to (intersection (sites Empty) (sites Distance All from:(coord "J10") (range 3 15)))))) (nextPhase "General")) (phase "General" (play (move Add (to (sites Empty)))))} (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 9) (result Mover Win))}))) 
A circle with eight radii. Three pieces per player. Each player has three pieces, which must start on the outer ring adjacent to each other. Players alternate turns moving a piece to an empty point along the lines of the board. The player who makes a line of three through the center of the circle wins.
(game "Ring" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))))) (nextPhase Mover "PlacementAdjacent")) (phase "PlacementAdjacent" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre)) if:(is In (to) (sites Around (sites Occupied by:Mover)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))))) 
A circle with eight radii. Three pieces per player. Each player has three pieces, which must start on the outer ring adjacent to each other. Players alternate turns moving a piece to an empty point along the lines of the board. The player who makes a line of three through the center of the circle wins.
(game "Ring" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))))) (nextPhase Mover "PlacementAdjacent")) (phase "PlacementAdjacent" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre)) if:(is In (to) (sites Around (sites Occupied by:Mover)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))))) 
A circle with eight radii. Three pieces per player. Each player has three pieces, which must start on the outer ring adjacent to each other. Players alternate turns moving a piece to an empty point along the lines of the board. The player who makes a line of three through the center of the circle wins.
(game "Ring" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))))) (nextPhase Mover "PlacementAdjacent")) (phase "PlacementAdjacent" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre)) if:(is In (to) (sites Around (sites Occupied by:Mover)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))))) 
3x3 intersecting lines with diagonals in the square. Three pieces per player. Players alternate turns placing a piece on the board. The player who places three pieces in a row along one of the lines of the board wins.
(game "Selbia" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines with diagonals in the square. Three pieces per player. Players alternate turns placing a piece on the board. The player who places three pieces in a row along one of the lines of the board wins.
(game "Selbia" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines with diagonals in the square. Three pieces per player. Players alternate turns placing a piece on the board. The player who places three pieces in a row along one of the lines of the board wins.
(game "Selbia" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
4x4 board. Six pieces per player, which begin on opposite rows of the board and in the two outer squares in the row in front of it. Players alternate turns moving a piece orthogonally to an adjacent space on the board. When a player moves a piece such that it creates three in a row: two of their own pieces (which must be adjacent to one another) and one of the opponent's pieces (which must have a vacant space on the opposite side of it), the opponent's piece is captured. However, when the opponent's piece moves in line with two of the player's piece on the opponent's turn, the player does not capture the opponent's piece. The player who captures all of the opponent's pieces wins.
(game "Six Insect Game" (players 2) (equipment {(board (square 4)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 2 Orthogonal) (or {(if (!= (ahead (last To) N) (last To)) (if (= (mover) (who at:(ahead (last To) N))) (or (if (!= (ahead (last To) steps:2 N) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 N))) (if (!= (ahead (last To) steps:3 N) (last To)) (if (is Empty (ahead (last To) steps:3 N)) (remove (ahead (last To) steps:2 N)))))) (if (!= (ahead (last To) S) (last To)) (if (= (next) (who at:(ahead (last To) S))) (if (!= (ahead (last To) steps:2 S) (last To)) (if (is Empty (ahead (last To) steps:2 S)) (remove (ahead (last To) S))))))))) (if (!= (ahead (last To) S) (last To)) (if (= (mover) (who at:(ahead (last To) S))) (or (if (!= (ahead (last To) steps:2 S) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 S))) (if (!= (ahead (last To) steps:3 S) (last To)) (if (is Empty (ahead (last To) steps:3 S)) (remove (ahead (last To) steps:2 S)))))) (if (!= (ahead (last To) N) (last To)) (if (= (next) (who at:(ahead (last To) N))) (if (!= (ahead (last To) steps:2 N) (last To)) (if (is Empty (ahead (last To) steps:2 N)) (remove (ahead (last To) N))))))))) (if (!= (ahead (last To) E) (last To)) (if (= (mover) (who at:(ahead (last To) E))) (or (if (!= (ahead (last To) steps:2 E) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 E))) (if (!= (ahead (last To) steps:3 E) (last To)) (if (is Empty (ahead (last To) steps:3 E)) (remove (ahead (last To) steps:2 E)))))) (if (!= (ahead (last To) W) (last To)) (if (= (next) (who at:(ahead (last To) W))) (if (!= (ahead (last To) steps:2 W) (last To)) (if (is Empty (ahead (last To) steps:2 W)) (remove (ahead (last To) W))))))))) (if (!= (ahead (last To) W) (last To)) (if (= (mover) (who at:(ahead (last To) W))) (or (if (!= (ahead (last To) steps:2 W) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 W))) (if (!= (ahead (last To) steps:3 W) (last To)) (if (is Empty (ahead (last To) steps:3 W)) (remove (ahead (last To) steps:2 W)))))) (if (!= (ahead (last To) E) (last To)) (if (= (next) (who at:(ahead (last To) E))) (if (!= (ahead (last To) steps:2 E) (last To)) (if (is Empty (ahead (last To) steps:2 E)) (remove (ahead (last To) E)))))))))})))))}) (rules (start {(place "Marker1" (union (intersection (union (sites Right) (sites Left)) (sites Row 1)) (sites Bottom))) (place "Marker2" (union (intersection (union (sites Right) (sites Left)) (sites Row 2)) (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
4x4 board. Six pieces per player, which begin on opposite rows of the board and in the two outer squares in the row in front of it. Players alternate turns moving a piece orthogonally to an adjacent space on the board. When a player moves a piece such that it creates three in a row: two of their own pieces (which must be adjacent to one another) and one of the opponent's pieces (which must have a vacant space on the opposite side of it), the opponent's piece is captured. However, when the opponent's piece moves in line with two of the player's piece on the opponent's turn, the player does not capture the opponent's piece. The player who captures all of the opponent's pieces wins.
(game "Six Insect Game" (players 2) (equipment {(board (square 4)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 2 Orthogonal) (or {(if (!= (ahead (last To) N) (last To)) (if (= (mover) (who at:(ahead (last To) N))) (or (if (!= (ahead (last To) steps:2 N) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 N))) (if (!= (ahead (last To) steps:3 N) (last To)) (if (is Empty (ahead (last To) steps:3 N)) (remove (ahead (last To) steps:2 N)))))) (if (!= (ahead (last To) S) (last To)) (if (= (next) (who at:(ahead (last To) S))) (if (!= (ahead (last To) steps:2 S) (last To)) (if (is Empty (ahead (last To) steps:2 S)) (remove (ahead (last To) S))))))))) (if (!= (ahead (last To) S) (last To)) (if (= (mover) (who at:(ahead (last To) S))) (or (if (!= (ahead (last To) steps:2 S) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 S))) (if (!= (ahead (last To) steps:3 S) (last To)) (if (is Empty (ahead (last To) steps:3 S)) (remove (ahead (last To) steps:2 S)))))) (if (!= (ahead (last To) N) (last To)) (if (= (next) (who at:(ahead (last To) N))) (if (!= (ahead (last To) steps:2 N) (last To)) (if (is Empty (ahead (last To) steps:2 N)) (remove (ahead (last To) N))))))))) (if (!= (ahead (last To) E) (last To)) (if (= (mover) (who at:(ahead (last To) E))) (or (if (!= (ahead (last To) steps:2 E) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 E))) (if (!= (ahead (last To) steps:3 E) (last To)) (if (is Empty (ahead (last To) steps:3 E)) (remove (ahead (last To) steps:2 E)))))) (if (!= (ahead (last To) W) (last To)) (if (= (next) (who at:(ahead (last To) W))) (if (!= (ahead (last To) steps:2 W) (last To)) (if (is Empty (ahead (last To) steps:2 W)) (remove (ahead (last To) W))))))))) (if (!= (ahead (last To) W) (last To)) (if (= (mover) (who at:(ahead (last To) W))) (or (if (!= (ahead (last To) steps:2 W) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 W))) (if (!= (ahead (last To) steps:3 W) (last To)) (if (is Empty (ahead (last To) steps:3 W)) (remove (ahead (last To) steps:2 W)))))) (if (!= (ahead (last To) E) (last To)) (if (= (next) (who at:(ahead (last To) E))) (if (!= (ahead (last To) steps:2 E) (last To)) (if (is Empty (ahead (last To) steps:2 E)) (remove (ahead (last To) E)))))))))})))))}) (rules (start {(place "Marker1" (union (intersection (union (sites Right) (sites Left)) (sites Row 1)) (sites Bottom))) (place "Marker2" (union (intersection (union (sites Right) (sites Left)) (sites Row 2)) (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
4x4 board. Six pieces per player, which begin on opposite rows of the board and in the two outer squares in the row in front of it. Players alternate turns moving a piece orthogonally to an adjacent space on the board. When a player moves a piece such that it creates three in a row: two of their own pieces (which must be adjacent to one another) and one of the opponent's pieces (which must have a vacant space on the opposite side of it), the opponent's piece is captured. However, when the opponent's piece moves in line with two of the player's piece on the opponent's turn, the player does not capture the opponent's piece. The player who captures all of the opponent's pieces wins.
(game "Six Insect Game" (players 2) (equipment {(board (square 4)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 2 Orthogonal) (or {(if (!= (ahead (last To) N) (last To)) (if (= (mover) (who at:(ahead (last To) N))) (or (if (!= (ahead (last To) steps:2 N) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 N))) (if (!= (ahead (last To) steps:3 N) (last To)) (if (is Empty (ahead (last To) steps:3 N)) (remove (ahead (last To) steps:2 N)))))) (if (!= (ahead (last To) S) (last To)) (if (= (next) (who at:(ahead (last To) S))) (if (!= (ahead (last To) steps:2 S) (last To)) (if (is Empty (ahead (last To) steps:2 S)) (remove (ahead (last To) S))))))))) (if (!= (ahead (last To) S) (last To)) (if (= (mover) (who at:(ahead (last To) S))) (or (if (!= (ahead (last To) steps:2 S) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 S))) (if (!= (ahead (last To) steps:3 S) (last To)) (if (is Empty (ahead (last To) steps:3 S)) (remove (ahead (last To) steps:2 S)))))) (if (!= (ahead (last To) N) (last To)) (if (= (next) (who at:(ahead (last To) N))) (if (!= (ahead (last To) steps:2 N) (last To)) (if (is Empty (ahead (last To) steps:2 N)) (remove (ahead (last To) N))))))))) (if (!= (ahead (last To) E) (last To)) (if (= (mover) (who at:(ahead (last To) E))) (or (if (!= (ahead (last To) steps:2 E) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 E))) (if (!= (ahead (last To) steps:3 E) (last To)) (if (is Empty (ahead (last To) steps:3 E)) (remove (ahead (last To) steps:2 E)))))) (if (!= (ahead (last To) W) (last To)) (if (= (next) (who at:(ahead (last To) W))) (if (!= (ahead (last To) steps:2 W) (last To)) (if (is Empty (ahead (last To) steps:2 W)) (remove (ahead (last To) W))))))))) (if (!= (ahead (last To) W) (last To)) (if (= (mover) (who at:(ahead (last To) W))) (or (if (!= (ahead (last To) steps:2 W) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 W))) (if (!= (ahead (last To) steps:3 W) (last To)) (if (is Empty (ahead (last To) steps:3 W)) (remove (ahead (last To) steps:2 W)))))) (if (!= (ahead (last To) E) (last To)) (if (= (next) (who at:(ahead (last To) E))) (if (!= (ahead (last To) steps:2 E) (last To)) (if (is Empty (ahead (last To) steps:2 E)) (remove (ahead (last To) E)))))))))})))))}) (rules (start {(place "Marker1" (union (intersection (union (sites Right) (sites Left)) (sites Row 1)) (sites Bottom))) (place "Marker2" (union (intersection (union (sites Right) (sites Left)) (sites Row 2)) (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). A player wins by making a line of L pieces of their colour orthogonally or diagonally (where L is the layer size) but loses by making a line of L-1 of their colour beforehand (without also making a line of L). Two players. 4x4 square pyramidal board.
(game "Spava" (players 2) (equipment {(board (square 4 pyramidal:True) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty) if:(is Flat)))) (end {(if (is Line (- (count Rows) (layer of:(last To))) SameLayer) (result Mover Win)) (if (is Line (- (- (count Rows) (layer of:(last To))) 1) SameLayer) (result Mover Loss))}))) 
Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). A player wins by making a line of L pieces of their colour orthogonally or diagonally (where L is the layer size) but loses by making a line of L-1 of their colour beforehand (without also making a line of L). Three players. 2x2 square pyramidal board.
(game "Spava" (players 3) (equipment {(board (square 2 pyramidal:True) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty) if:(is Flat)))) (end {(if (is Line (- (count Rows) (layer of:(last To))) SameLayer) (result Mover Win)) (if (is Line (- (- (count Rows) (layer of:(last To))) 1) SameLayer) (result Mover Loss))}))) 
Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). A player wins by making a line of L pieces of their colour orthogonally or diagonally (where L is the layer size) but loses by making a line of L-1 of their colour beforehand (without also making a line of L). Four players. 3x3 square pyramidal board.
(game "Spava" (players 4) (equipment {(board (square 3 pyramidal:True) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty) if:(is Flat)))) (end {(if (is Line (- (count Rows) (layer of:(last To))) SameLayer) (result Mover Win)) (if (is Line (- (- (count Rows) (layer of:(last To))) 1) SameLayer) (result Mover Loss))}))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position. An alternate version requires the three in a row to be diagonal.
(game "Tant Fant" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position. An alternate version requires the three in a row to be diagonal.
(game "Tant Fant" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position. An alternate version requires the three in a row to be diagonal.
(game "Tant Fant" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. Once the pieces are all on the board, they may be moved one space orthogonally. In the case that a move creates two lines of three, only one capture is made. The player who makes the last possible capture wins.
(game "Tauru" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. Once the pieces are all on the board, they may be moved one space orthogonally. In the case that a move creates two lines of three, only one capture is made. The player who makes the last possible capture wins.
(game "Tauru" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. Once the pieces are all on the board, they may be moved one space orthogonally. In the case that a move creates two lines of three, only one capture is made. The player who makes the last possible capture wins.
(game "Tauru" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Triangle, with a line from the apex bisecting the base, and a line bisecting this one and the opposite sides. Three pieces per player. Players alternate turns placing a piece on one of the empty points on the board. When all of the pieces have been placed, players alternate turns moving any one of their pieces to the empty point on the board. The first player to make a line of three wins.
(game "Tsoro Yemutatu (Triangle)" (players 2) (equipment {(board (scale 1 2 (wedge 3)) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Triangle, with a line from the apex bisecting the base, and a line bisecting this one and the opposite sides. Three pieces per player. Players alternate turns placing a piece on one of the empty points on the board. When all of the pieces have been placed, players alternate turns moving any one of their pieces to the empty point on the board. The first player to make a line of three wins.
(game "Tsoro Yemutatu (Triangle)" (players 2) (equipment {(board (scale 1 2 (wedge 3)) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Triangle, with a line from the apex bisecting the base, and a line bisecting this one and the opposite sides. Three pieces per player. Players alternate turns placing a piece on one of the empty points on the board. When all of the pieces have been placed, players alternate turns moving any one of their pieces to the empty point on the board. The first player to make a line of three wins.
(game "Tsoro Yemutatu (Triangle)" (players 2) (equipment {(board (scale 1 2 (wedge 3)) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
5x6 board, made in the sand. One player plays with twelve sticks and the other with twelve pebbles. The player with the sticks plays first. Players alternate turns placing one of their pieces on an empty space on the board. Players are not permitted to place more than two of their own pieces in an orthogonal row on the board. When all of the pieces are placed, players alternate turns moving one of their pieces orthogonally one space. When a player successfully places three of their pieces in an orthogonal row of three, the player captures one of the opponent's pieces. The player who captures all of their opponent's pieces wins.
(game "Wali" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Stick" P1 (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start {(place "Stick1" (handSite P1) count:12) (place "Ball2" (handSite P2) count:12)}) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
5x6 board, made in the sand. One player plays with twelve sticks and the other with twelve pebbles. The player with the sticks plays first. Players alternate turns placing one of their pieces on an empty space on the board. Players are not permitted to place more than two of their own pieces in an orthogonal row on the board. When all of the pieces are placed, players alternate turns moving one of their pieces orthogonally one space. When a player successfully places three of their pieces in an orthogonal row of three, the player captures one of the opponent's pieces. The player who captures all of their opponent's pieces wins.
(game "Wali" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Stick" P1 (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start {(place "Stick1" (handSite P1) count:12) (place "Ball2" (handSite P2) count:12)}) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
5x6 board, made in the sand. One player plays with twelve sticks and the other with twelve pebbles. The player with the sticks plays first. Players alternate turns placing one of their pieces on an empty space on the board. Players are not permitted to place more than two of their own pieces in an orthogonal row on the board. When all of the pieces are placed, players alternate turns moving one of their pieces orthogonally one space. When a player successfully places three of their pieces in an orthogonal row of three, the player captures one of the opponent's pieces. The player who captures all of their opponent's pieces wins.
(game "Wali" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Stick" P1 (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start {(place "Stick1" (handSite P1) count:12) (place "Ball2" (handSite P2) count:12)}) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Two diamonds drawn, one connecting the midpoints of the outer square and intersecting the corners of the second square; the second connecting the midpoints of the second square and intersecting the corners of the central square. Twelve pieces per plays. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Complex)" (players 2) (equipment {(board (add (remove (merge {(shift 3 3 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}})) (shift 2 2 (scale 2 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))) (scale 4 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))}) vertices:{4}) edges:{{17 19} {17 20} {20 22} {22 19} {17 9} {19 11} {22 14} {12 20} {21 13} {23 15} {18 10} {16 8} {11 9} {9 12} {12 14} {14 11} {9 1} {11 3} {6 14} {4 12} {0 8} {5 13} {7 15} {10 2}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Two diamonds drawn, one connecting the midpoints of the outer square and intersecting the corners of the second square; the second connecting the midpoints of the second square and intersecting the corners of the central square. Twelve pieces per plays. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Complex)" (players 2) (equipment {(board (add (remove (merge {(shift 3 3 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}})) (shift 2 2 (scale 2 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))) (scale 4 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))}) vertices:{4}) edges:{{17 19} {17 20} {20 22} {22 19} {17 9} {19 11} {22 14} {12 20} {21 13} {23 15} {18 10} {16 8} {11 9} {9 12} {12 14} {14 11} {9 1} {11 3} {6 14} {4 12} {0 8} {5 13} {7 15} {10 2}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Two diamonds drawn, one connecting the midpoints of the outer square and intersecting the corners of the second square; the second connecting the midpoints of the second square and intersecting the corners of the central square. Twelve pieces per plays. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Complex)" (players 2) (equipment {(board (add (remove (merge {(shift 3 3 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}})) (shift 2 2 (scale 2 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))) (scale 4 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))}) vertices:{4}) edges:{{17 19} {17 20} {20 22} {22 19} {17 9} {19 11} {22 14} {12 20} {21 13} {23 15} {18 10} {16 8} {11 9} {9 12} {12 14} {14 11} {9 1} {11 3} {6 14} {4 12} {0 8} {5 13} {7 15} {10 2}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed from the board. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Simple)" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed from the board. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Simple)" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed from the board. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Simple)" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Two players play, with white and black pieces, with neutral red pieces as well. Players take turns placing either a red counters on an empty space or a counter of their color on a space adjacent to a red one. Play continues until one player creates five in a row with only their color and red. The player that does so first wins.
(game "Yavalanchor" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each) (piece "Marker" Shared) (hand Shared)}) (rules (meta (swap)) (start (place "Marker" (handSite Shared))) (play (or (move Add (to (sites Around (sites Occupied by:Shared component:"Marker") if:(is Empty (to))))) (move (from (handSite Shared)) (to (sites Empty)) copy:True))) (end (forEach Player if:(and (or (= (what at:(last To)) (id "Marker" Player)) (= (what at:(last To)) (id "Marker"))) (is Line 5 whats:{(id "Marker" Player) (id "Marker")})) (result Player Win))))) 
Two players play, with white and black pieces, with neutral red pieces as well. Players take turns placing either a red counters on an empty space or a counter of their color on a space adjacent to a red one. Play continues until one player creates five in a row with only their color and red. The player that does so first wins.
(game "Yavalanchor" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each) (piece "Marker" Shared) (hand Shared)}) (rules (meta (swap)) (start (place "Marker" (handSite Shared))) (play (or (move Add (to (sites Around (sites Occupied by:Shared component:"Marker") if:(is Empty (to))))) (move (from (handSite Shared)) (to (sites Empty)) copy:True))) (end (forEach Player if:(and (or (= (what at:(last To)) (id "Marker" Player)) (= (what at:(last To)) (id "Marker"))) (is Line 5 whats:{(id "Marker" Player) (id "Marker")})) (result Player Win))))) 
Two players play, with white and black pieces, with neutral red pieces as well. Players take turns placing either a red counters on an empty space or a counter of their color on a space adjacent to a red one. Play continues until one player creates five in a row with only their color and red. The player that does so first wins.
(game "Yavalanchor" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each) (piece "Marker" Shared) (hand Shared)}) (rules (meta (swap)) (start (place "Marker" (handSite Shared))) (play (or (move Add (to (sites Around (sites Occupied by:Shared component:"Marker") if:(is Empty (to))))) (move (from (handSite Shared)) (to (sites Empty)) copy:True))) (end (forEach Player if:(and (or (= (what at:(last To)) (id "Marker" Player)) (= (what at:(last To)) (id "Marker"))) (is Line 5 whats:{(id "Marker" Player) (id "Marker")})) (result Player Win))))) 
Goal: Simultaneously create two or more rows of exactly four stones of your color. Play: White starts by placing a white stone at an empty cell. Players then take turns placing two stones of their color at empty cells, one stone after another. In each placement, players are not allowed to create a single 4-in-a-row of their color, unless that placement simultaneously creates at least one other 4-in-a-row of their color to win the game. This means that players may NOT make a single 4-in-a-row of their color on the first placement of their turn even if they can make a second 4-in-a-row on their second placement. In no event are players allowed to create 5 (or more) -in-a-row of their color. The first player to make simultaneous 4-in-a-rows of their color wins immediately, whether it was their first or second placement. The game is played on a 13x13 board.
(game "Yavalax" (players 2) (equipment {(board (square 13)) (piece "Marker" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase "General")) (phase "General" (play (do (move Add (to (sites Empty)) (then (if (not (is Prev Mover)) (moveAgain)))) ifAfterwards:(and (not (is Line 5)) (!= 1 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)}))))))} (end (if (<= 2 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)})) (result Mover Win))))) 
Goal: Simultaneously create two or more rows of exactly four stones of your color. Play: White starts by placing a white stone at an empty cell. Players then take turns placing two stones of their color at empty cells, one stone after another. In each placement, players are not allowed to create a single 4-in-a-row of their color, unless that placement simultaneously creates at least one other 4-in-a-row of their color to win the game. This means that players may NOT make a single 4-in-a-row of their color on the first placement of their turn even if they can make a second 4-in-a-row on their second placement. In no event are players allowed to create 5 (or more) -in-a-row of their color. The first player to make simultaneous 4-in-a-rows of their color wins immediately, whether it was their first or second placement. The game is played on a 14x14 board.
(game "Yavalax" (players 2) (equipment {(board (square 14)) (piece "Marker" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase "General")) (phase "General" (play (do (move Add (to (sites Empty)) (then (if (not (is Prev Mover)) (moveAgain)))) ifAfterwards:(and (not (is Line 5)) (!= 1 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)}))))))} (end (if (<= 2 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)})) (result Mover Win))))) 
Goal: Simultaneously create two or more rows of exactly four stones of your color. Play: White starts by placing a white stone at an empty cell. Players then take turns placing two stones of their color at empty cells, one stone after another. In each placement, players are not allowed to create a single 4-in-a-row of their color, unless that placement simultaneously creates at least one other 4-in-a-row of their color to win the game. This means that players may NOT make a single 4-in-a-row of their color on the first placement of their turn even if they can make a second 4-in-a-row on their second placement. In no event are players allowed to create 5 (or more) -in-a-row of their color. The first player to make simultaneous 4-in-a-rows of their color wins immediately, whether it was their first or second placement. The game is played on a 15x15 board.
(game "Yavalax" (players 2) (equipment {(board (square 15)) (piece "Marker" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase "General")) (phase "General" (play (do (move Add (to (sites Empty)) (then (if (not (is Prev Mover)) (moveAgain)))) ifAfterwards:(and (not (is Line 5)) (!= 1 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)}))))))} (end (if (<= 2 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)})) (result Mover Win))))) 
The two players, Red and Blue, alternately place tokens on the intersections of the board until each has placed fifteen. Thereafter they alternate turns sliding a single token along a line to an adjacent vertex. A player who occupies the three vertices of any triangle has formed a mill and may relocate one enemy token. Occupying the four vertices of a square (forming a double mill) allows the player to relocate two enemy tokens. No more than two tokens may be relocated in a single turn, even if a player completes a mill and double mill with the same move. The winner is the first player to occupy all six vertices of either any neutral hexagon or one of his/her own color. A win can be achieved during either the placement or movement phases of the game.
(game "Kensington" (players 2) (equipment {(board (rotate 90 (tiling T3464 2)) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions "HexA" P1 (sites Cell "E4")) (regions "HexB" P1 (sites Cell "I4")) (regions "HexA" P2 (sites Cell "E12")) (regions "HexB" P2 (sites Cell "I12")) (regions "HexNeutral1" (sites Cell "C8")) (regions "HexNeutral2" (sites Cell "G8")) (regions "HexNeutral3" (sites Cell "K8"))}) (rules (start (place "Marker" "Hand" count:15)) (play (if (is Prev Mover) (move (from (sites Occupied by:Next container:"Board")) (to (sites Empty) (apply if:(is Pending) (moveAgain)))) (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Piece) (move (from (handSite Mover)) (to (sites Empty))) (then (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (= (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites Occupied by:Mover))) (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (= 6 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (or {(= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexA")) (= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexB")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral1")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral2")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral3"))}) (trigger "Lose" Next)) (and (if (= 4 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (set Pending)) (moveAgain))))))))) (end (if (is Triggered "Lose" Next) (result Mover Win))))) 
The two players, Red and Blue, alternately place tokens on the intersections of the board until each has placed fifteen. Thereafter they alternate turns sliding a single token along a line to an adjacent vertex. A player who occupies the three vertices of any triangle has formed a mill and may relocate one enemy token. Occupying the four vertices of a square (forming a double mill) allows the player to relocate two enemy tokens. No more than two tokens may be relocated in a single turn, even if a player completes a mill and double mill with the same move. The winner is the first player to occupy all six vertices of either any neutral hexagon or one of his/her own color. A win can be achieved during either the placement or movement phases of the game.
(game "Kensington" (players 2) (equipment {(board (rotate 90 (tiling T3464 2)) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions "HexA" P1 (sites Cell "E4")) (regions "HexB" P1 (sites Cell "I4")) (regions "HexA" P2 (sites Cell "E12")) (regions "HexB" P2 (sites Cell "I12")) (regions "HexNeutral1" (sites Cell "C8")) (regions "HexNeutral2" (sites Cell "G8")) (regions "HexNeutral3" (sites Cell "K8"))}) (rules (start (place "Marker" "Hand" count:15)) (play (if (is Prev Mover) (move (from (sites Occupied by:Next container:"Board")) (to (sites Empty) (apply if:(is Pending) (moveAgain)))) (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Piece) (move (from (handSite Mover)) (to (sites Empty))) (then (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (= (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites Occupied by:Mover))) (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (= 6 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (or {(= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexA")) (= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexB")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral1")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral2")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral3"))}) (trigger "Lose" Next)) (and (if (= 4 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (set Pending)) (moveAgain))))))))) (end (if (is Triggered "Lose" Next) (result Mover Win))))) 
The two players, Red and Blue, alternately place tokens on the intersections of the board until each has placed fifteen. Thereafter they alternate turns sliding a single token along a line to an adjacent vertex. A player who occupies the three vertices of any triangle has formed a mill and may relocate one enemy token. Occupying the four vertices of a square (forming a double mill) allows the player to relocate two enemy tokens. No more than two tokens may be relocated in a single turn, even if a player completes a mill and double mill with the same move. The winner is the first player to occupy all six vertices of either any neutral hexagon or one of his/her own color. A win can be achieved during either the placement or movement phases of the game.
(game "Kensington" (players 2) (equipment {(board (rotate 90 (tiling T3464 2)) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions "HexA" P1 (sites Cell "E4")) (regions "HexB" P1 (sites Cell "I4")) (regions "HexA" P2 (sites Cell "E12")) (regions "HexB" P2 (sites Cell "I12")) (regions "HexNeutral1" (sites Cell "C8")) (regions "HexNeutral2" (sites Cell "G8")) (regions "HexNeutral3" (sites Cell "K8"))}) (rules (start (place "Marker" "Hand" count:15)) (play (if (is Prev Mover) (move (from (sites Occupied by:Next container:"Board")) (to (sites Empty) (apply if:(is Pending) (moveAgain)))) (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Piece) (move (from (handSite Mover)) (to (sites Empty))) (then (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (= (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites Occupied by:Mover))) (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (= 6 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (or {(= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexA")) (= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexB")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral1")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral2")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral3"))}) (trigger "Lose" Next)) (and (if (= 4 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (set Pending)) (moveAgain))))))))) (end (if (is Triggered "Lose" Next) (result Mover Win))))) 
Each player in turn places one of his marbles in an open space on the board, on top of a square (i.e. 4 marbles next to each other). After the placement of each marble, check to see if a square or marbles have been formed. If at least 3 of the 4 marbles that form a square are of the same color, a piece of that color go on top of that square. If as a result other squares are formed, the same rule is applied. The winner is the first player to have at least 27 marbles of his colour on the board.
(game "Upper Hand" (players 2) (equipment {(board (square 5 pyramidal:True) use:Vertex) (piece "Ball" Each) (piece "Ball" Neutral)}) (rules (start (place "Ball0" (centrePoint))) (play (move Add (to (sites Empty) if:(is Flat)) (then (while (not (all Sites (sites Board) if:(not (can Move (or (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))})))))) (forEach Site (sites Board) (and (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))}))))))) (end (if (<= 27 (count Sites in:(sites Occupied by:Mover))) (result Mover Win))))) 
Each player in turn places one of his marbles in an open space on the board, on top of a square (i.e. 4 marbles next to each other). After the placement of each marble, check to see if a square or marbles have been formed. If at least 3 of the 4 marbles that form a square are of the same color, a piece of that color go on top of that square. If as a result other squares are formed, the same rule is applied. The winner is the first player to have at least 27 marbles of his colour on the board.
(game "Upper Hand" (players 2) (equipment {(board (square 5 pyramidal:True) use:Vertex) (piece "Ball" Each) (piece "Ball" Neutral)}) (rules (start (place "Ball0" (centrePoint))) (play (move Add (to (sites Empty) if:(is Flat)) (then (while (not (all Sites (sites Board) if:(not (can Move (or (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))})))))) (forEach Site (sites Board) (and (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))}))))))) (end (if (<= 27 (count Sites in:(sites Occupied by:Mover))) (result Mover Win))))) 
Each player in turn places one of his marbles in an open space on the board, on top of a square (i.e. 4 marbles next to each other). After the placement of each marble, check to see if a square or marbles have been formed. If at least 3 of the 4 marbles that form a square are of the same color, a piece of that color go on top of that square. If as a result other squares are formed, the same rule is applied. The winner is the first player to have at least 27 marbles of his colour on the board.
(game "Upper Hand" (players 2) (equipment {(board (square 5 pyramidal:True) use:Vertex) (piece "Ball" Each) (piece "Ball" Neutral)}) (rules (start (place "Ball0" (centrePoint))) (play (move Add (to (sites Empty) if:(is Flat)) (then (while (not (all Sites (sites Board) if:(not (can Move (or (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))})))))) (forEach Site (sites Board) (and (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))}))))))) (end (if (<= 27 (count Sites in:(sites Occupied by:Mover))) (result Mover Win))))) 
The rules are identical to Go, except the winning condition is to be the first to capture a stone. The game is played on a 19x19 board.
(game "Atari Go" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each)}) (rules (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (trigger "CaptureMade" Next) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (is Triggered "CaptureMade" Next) (result Mover Win))))) 
The rules are identical to Go, except the winning condition is to be the first to capture a stone. The game is played on a 9x9 board.
(game "Atari Go" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each)}) (rules (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (trigger "CaptureMade" Next) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (is Triggered "CaptureMade" Next) (result Mover Win))))) 
The rules are identical to Go, except the winning condition is to be the first to capture a stone. The game is played on a 13x13 board.
(game "Atari Go" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Marker" Each)}) (rules (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (trigger "CaptureMade" Next) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (is Triggered "CaptureMade" Next) (result Mover Win))))) 
Each player begins with two pieces on the four corners of the board, with each player's pieces in opposite corners. Players move one piece one or two spaces in any direction orthogonally or diagonally. If the piece is moved on space, another piece is added on the origin space. All of the opponent's pieces adjacent to the space to which the player moved now belong to the player who moved. Play ends when all spaces have been filled or one of the players has no remaining pieces. The player with the most pieces wins.
(game "Ataxx" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move (from) (to (sites Around (from)) if:(is Empty (to))) copy:True) (move (from) (to (difference (expand origin:(from) steps:2) (expand origin:(from))) if:(is Empty (to)))) (then (forEach Site (intersection (sites Around (last To)) (sites Occupied by:Next)) (and (remove (site)) (add (piece (id "Marker" Mover)) (to (site))))))))}) (rules (start {(set Score Each 2) (place "Marker1" {"A1" "G7"}) (place "Marker2" {"A7" "G1"})}) (play (forEach Piece (then (and (set Score P1 (count Sites in:(sites Occupied by:P1))) (set Score P2 (count Sites in:(sites Occupied by:P2))))))) (end (if (or (= (count Sites in:(sites Occupied by:Next)) 0) (is Full)) (byScore))))) 
Each player begins with two pieces on the four corners of the board, with each player's pieces in opposite corners. Players move one piece one or two spaces in any direction orthogonally or diagonally. If the piece is moved on space, another piece is added on the origin space. All of the opponent's pieces adjacent to the space to which the player moved now belong to the player who moved. Play ends when all spaces have been filled or one of the players has no remaining pieces. The player with the most pieces wins.
(game "Ataxx" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move (from) (to (sites Around (from)) if:(is Empty (to))) copy:True) (move (from) (to (difference (expand origin:(from) steps:2) (expand origin:(from))) if:(is Empty (to)))) (then (forEach Site (intersection (sites Around (last To)) (sites Occupied by:Next)) (and (remove (site)) (add (piece (id "Marker" Mover)) (to (site))))))))}) (rules (start {(set Score Each 2) (place "Marker1" {"A1" "G7"}) (place "Marker2" {"A7" "G1"})}) (play (forEach Piece (then (and (set Score P1 (count Sites in:(sites Occupied by:P1))) (set Score P2 (count Sites in:(sites Occupied by:P2))))))) (end (if (or (= (count Sites in:(sites Occupied by:Next)) 0) (is Full)) (byScore))))) 
Each player begins with two pieces on the four corners of the board, with each player's pieces in opposite corners. Players move one piece one or two spaces in any direction orthogonally or diagonally. If the piece is moved on space, another piece is added on the origin space. All of the opponent's pieces adjacent to the space to which the player moved now belong to the player who moved. Play ends when all spaces have been filled or one of the players has no remaining pieces. The player with the most pieces wins.
(game "Ataxx" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move (from) (to (sites Around (from)) if:(is Empty (to))) copy:True) (move (from) (to (difference (expand origin:(from) steps:2) (expand origin:(from))) if:(is Empty (to)))) (then (forEach Site (intersection (sites Around (last To)) (sites Occupied by:Next)) (and (remove (site)) (add (piece (id "Marker" Mover)) (to (site))))))))}) (rules (start {(set Score Each 2) (place "Marker1" {"A1" "G7"}) (place "Marker2" {"A7" "G1"})}) (play (forEach Piece (then (and (set Score P1 (count Sites in:(sites Occupied by:P1))) (set Score P2 (count Sites in:(sites Occupied by:P2))))))) (end (if (or (= (count Sites in:(sites Occupied by:Next)) 0) (is Full)) (byScore))))) 
The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. For more info on this version please google Hexagonal Go. Hex Grid - Standard Order 6 board
(game "HexGo" (players 2) (equipment {(board (tri Hexagon 6) use:Vertex) (piece "Ball" P1) (piece "Ball" P2)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0)) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. For more info on this version please google Hexagonal Go. Hex Grid - Standard Order 3 board
(game "HexGo" (players 2) (equipment {(board (tri Hexagon 3) use:Vertex) (piece "Ball" P1) (piece "Ball" P2)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0)) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. For more info on this version please google Hexagonal Go. Hex Grid - Standard Order 4 board
(game "HexGo" (players 2) (equipment {(board (tri Hexagon 4) use:Vertex) (piece "Ball" P1) (piece "Ball" P2)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0)) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
Play on a hexagonal grid composed of hexagons. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to the pawn; if the number of adjacent checkers is equal, the checker under the trapped pawn breaks the tie. The person with the highest score wins. Played on a Hexagonal Board. Played on a size 7 board.
(game "HexTrike" (players 2) (equipment {(board (hex Hexagon 7)) (piece "Ball" Each)}) (rules (meta (swap)) phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)) (then (set Var (last To))))) (nextPhase)) (phase "Play" (play (move Add (to (sites LineOfSight Empty at:(var))) (then (set Var (last To))))))} (end {(if (no Moves Next) {(if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (result P1 Win)) (if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1)))) (result P2 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P1)) (result P1 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P2)) (result P2 Win))})}))) 
Play on a hexagonal grid composed of hexagons. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to the pawn; if the number of adjacent checkers is equal, the checker under the trapped pawn breaks the tie. The person with the highest score wins. Played on a Hexagonal (N,N+1 edged) Board. Played on a size 3 board.
(game "HexTrike" (players 2) (equipment {(board (hex Limping 3)) (piece "Ball" Each)}) (rules (meta (swap)) phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)) (then (set Var (last To))))) (nextPhase)) (phase "Play" (play (move Add (to (sites LineOfSight Empty at:(var))) (then (set Var (last To))))))} (end {(if (no Moves Next) {(if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (result P1 Win)) (if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1)))) (result P2 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P1)) (result P1 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P2)) (result P2 Win))})}))) 
Play on a hexagonal grid composed of hexagons. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to the pawn; if the number of adjacent checkers is equal, the checker under the trapped pawn breaks the tie. The person with the highest score wins. Played on a Hexagonal Board, pre-filled corners. Played on a size 4 board.
(game "HexTrike" (players 2) (equipment {(board (hex Hexagon 4)) (piece "Ball" Each)}) (rules (meta (swap)) (start {(place "Ball1" {0 (- (/ (- (* {3 4 4}) 4) 2) 1) (+ 1 (- (* {3 4 4}) (* 4 4)))}) (place "Ball2" {(- 4 1) (+ 1 (/ (- (* {3 4 4}) (* 5 4)) 2)) (- (* {3 4 4}) (* 3 4))})}) phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)) (then (set Var (last To))))) (nextPhase)) (phase "Play" (play (move Add (to (sites LineOfSight Empty at:(var))) (then (set Var (last To))))))} (end {(if (no Moves Next) {(if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (result P1 Win)) (if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1)))) (result P2 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P1)) (result P1 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P2)) (result P2 Win))})}))) 
Start on an empty board. On a turn either enter a piece not in line of sight of your own pieces, or move a piece a number of independant single steps not to exceed the count of that piece's enemy neighbors. If one player passes, to avoid ending the game with a 2nd pass, the opponent must place a piece if possible, or if unable to place, he may move in a way that enables his future placement. Otherwise, he must pass and the game ends. The winner is the player with the most pieces in play. If equal, the last to pass loses. Order 5 board Hex N / N+1 Grid
(game "Infuse" (players 2) (equipment {(board (hex Limping 5) use:Cell) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (was Pass) (or (move Pass) (priority (move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (do (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))}) ifAfterwards:(can Move (add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))))))))) (or {(move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))})) (move Pass)}))) (end {(if (and (all Passed) (> (score Mover) (score Next))) (result Mover Win)) (if (and (all Passed) (<= (score Mover) (score Next))) (result Next Win))}))) 
Start on an empty board. On a turn either enter a piece not in line of sight of your own pieces, or move a piece a number of independant single steps not to exceed the count of that piece's enemy neighbors. If one player passes, to avoid ending the game with a 2nd pass, the opponent must place a piece if possible, or if unable to place, he may move in a way that enables his future placement. Otherwise, he must pass and the game ends. The winner is the player with the most pieces in play. If equal, the last to pass loses. Order 8 board Square Grid
(game "Infuse" (players 2) (equipment {(board (square 8) use:Cell) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (was Pass) (or (move Pass) (priority (move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (do (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))}) ifAfterwards:(can Move (add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))))))))) (or {(move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))})) (move Pass)}))) (end {(if (and (all Passed) (> (score Mover) (score Next))) (result Mover Win)) (if (and (all Passed) (<= (score Mover) (score Next))) (result Next Win))}))) 
Start on an empty board. On a turn either enter a piece not in line of sight of your own pieces, or move a piece a number of independant single steps not to exceed the count of that piece's enemy neighbors. If one player passes, to avoid ending the game with a 2nd pass, the opponent must place a piece if possible, or if unable to place, he may move in a way that enables his future placement. Otherwise, he must pass and the game ends. The winner is the player with the most pieces in play. If equal, the last to pass loses. Order 2 board Hex Grid
(game "Infuse" (players 2) (equipment {(board (hex 2) use:Cell) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (was Pass) (or (move Pass) (priority (move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (do (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))}) ifAfterwards:(can Move (add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))))))))) (or {(move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))})) (move Pass)}))) (end {(if (and (all Passed) (> (score Mover) (score Next))) (result Mover Win)) (if (and (all Passed) (<= (score Mover) (score Next))) (result Next Win))}))) 
DEFINITION: A group is a maximal set of orthogonally adjacent like-colored pieces. GAMEPLAY: On your turn, flip an enemy group. OBJECTIVE: Eliminate the enemy pieces. An 8x8 board is currently selected. No heuristic is used.
(game "Paintbucket" (players 2) (equipment {(board (square 8)) (tile "Square" Each)}) (rules (start {(place "Square1" (sites Phase 0)) (place "Square2" (sites Phase 1))}) (play (move Select (from (sites Occupied by:Next)) (then (add (to (sites Group at:(last From) Orthogonal) (apply (remove (to)))))))) (end (if (no Pieces Next) (result Next Loss))))) 
DEFINITION: A group is a maximal set of orthogonally adjacent like-colored pieces. GAMEPLAY: On your turn, flip an enemy group. OBJECTIVE: Eliminate the enemy pieces. A 6x6 board is currently selected A running count of your number of groups is show as a heuristic.
(game "Paintbucket" (players 2) (equipment {(board (square 6)) (tile "Square" Each)}) (rules (start {(place "Square1" (sites Phase 0)) (place "Square2" (sites Phase 1)) (set Score P1 (count Sites in:(sites Occupied by:P1))) (set Score P2 (count Sites in:(sites Occupied by:P2)))}) (play (move Select (from (sites Occupied by:Next)) (then (do (add (to (sites Group at:(last From) Orthogonal) (apply (remove (to))))) next:(and (set Score P1 (count Groups Orthogonal if:(= (id P1) (who at:(to))))) (set Score P2 (count Groups Orthogonal if:(= (id P2) (who at:(to)))))))))) (end (if (no Pieces Next) (result Next Loss))))) 
DEFINITION: A group is a maximal set of orthogonally adjacent like-colored pieces. GAMEPLAY: On your turn, flip an enemy group. OBJECTIVE: Eliminate the enemy pieces. A 10x10 board is currently selected A running count of (the inverse of) the number of enemy groups is show as a heuristic.
(game "Paintbucket" (players 2) (equipment {(board (square 10)) (tile "Square" Each)}) (rules (start {(place "Square1" (sites Phase 0)) (place "Square2" (sites Phase 1)) (set Score P1 (* -1 (count Sites in:(sites Occupied by:P2)))) (set Score P2 (* -1 (count Sites in:(sites Occupied by:P1))))}) (play (move Select (from (sites Occupied by:Next)) (then (do (add (to (sites Group at:(last From) Orthogonal) (apply (remove (to))))) next:(and (set Score P1 (* -1 (count Groups Orthogonal if:(= (id P2) (who at:(to)))))) (set Score P2 (* -1 (count Groups Orthogonal if:(= (id P1) (who at:(to))))))))))) (end (if (no Pieces Next) (result Next Loss))))) 
19x19 intersecting lines. The central, as well as every third spot, in a square with the corners at the fourth point from the corners of the board, are marked. Players alternate turns placing a piece on the board on one of the marked spaces. When all of the marked spaces have been occupied, players may place a piece on any empty spot on the board. If a player surrounds one or more of the opponent's pieces orthogonally, they capture the opponent's pieces. The edge of the board can be included in such an enclosure. A group of pieces which contain two empty or more enclosures cannot be captured by the opponent. Pieces cannot be placed in an enclosure. When no further pieces can be placed, the players count the number of their pieces on the board and the number of empty spaces they enclose, and the player with the higher score wins.
(game "Patok" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (regions "MarkedSites" (sites {"D4" "D7" "D10" "D13" "D16" "G4" "G16" "J4" "J10" "J16" "M4" "M16" "P4" "P7" "P10" "P13" "P16"}))}) (rules phases:{(phase "MarkedPlacement" (play (move Add (to (intersection (sites Empty) (sites "MarkedSites"))))) (nextPhase (= 0 (count Sites in:(intersection (sites "MarkedSites") (sites Empty)))) "Playing")) (phase "Playing" (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between))))) numException:1))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (no Moves Next) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))})) 
19x19 intersecting lines. The central, as well as every third spot, in a square with the corners at the fourth point from the corners of the board, are marked. Players alternate turns placing a piece on the board on one of the marked spaces. When all of the marked spaces have been occupied, players may place a piece on any empty spot on the board. If a player surrounds one or more of the opponent's pieces orthogonally, they capture the opponent's pieces. The edge of the board can be included in such an enclosure. A group of pieces which contain two empty or more enclosures cannot be captured by the opponent. Pieces cannot be placed in an enclosure. When no further pieces can be placed, the players count the number of their pieces on the board and the number of empty spaces they enclose, and the player with the higher score wins.
(game "Patok" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (regions "MarkedSites" (sites {"D4" "D7" "D10" "D13" "D16" "G4" "G16" "J4" "J10" "J16" "M4" "M16" "P4" "P7" "P10" "P13" "P16"}))}) (rules phases:{(phase "MarkedPlacement" (play (move Add (to (intersection (sites Empty) (sites "MarkedSites"))))) (nextPhase (= 0 (count Sites in:(intersection (sites "MarkedSites") (sites Empty)))) "Playing")) (phase "Playing" (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between))))) numException:1))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (no Moves Next) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))})) 
19x19 intersecting lines. The central, as well as every third spot, in a square with the corners at the fourth point from the corners of the board, are marked. Players alternate turns placing a piece on the board on one of the marked spaces. When all of the marked spaces have been occupied, players may place a piece on any empty spot on the board. If a player surrounds one or more of the opponent's pieces orthogonally, they capture the opponent's pieces. The edge of the board can be included in such an enclosure. A group of pieces which contain two empty or more enclosures cannot be captured by the opponent. Pieces cannot be placed in an enclosure. When no further pieces can be placed, the players count the number of their pieces on the board and the number of empty spaces they enclose, and the player with the higher score wins.
(game "Patok" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (regions "MarkedSites" (sites {"D4" "D7" "D10" "D13" "D16" "G4" "G16" "J4" "J10" "J16" "M4" "M16" "P4" "P7" "P10" "P13" "P16"}))}) (rules phases:{(phase "MarkedPlacement" (play (move Add (to (intersection (sites Empty) (sites "MarkedSites"))))) (nextPhase (= 0 (count Sites in:(intersection (sites "MarkedSites") (sites Empty)))) "Playing")) (phase "Playing" (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between))))) numException:1))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (no Moves Next) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))})) 
On your turn, you place a hexagonal tile of your color that covers three mutually orthogonally adjacent rhombuses. In Ludii this is done by first selecting one of the rhombuses the tile will cover, then another. The third one is determined by these two selections. When no more placements are possible, the game is over and the winner is the player with the higher score. The general idea behind the scoring is simple: You get 1 point per empty rhombus that ends up adjacent to more of your hexagons than your opponent's hexagons. However, two slight complications are necessary to exclude all draws in as fair a manner as possible: 1: You score 1 point every time you make a placement that closes off an odd number of tied rhombuses. (A rhombus is closed off when it is adjacent to no rhombus that can be filled in on a future turn.) This is equivalent to dividing tied cells between you in a "one for me, one for you, one for me"-fashion as they are closed off. 2: You get 1 bonus point if your opponent has made more placements than you at the end of the game. All scoring is automatic in Ludii.
(game "Residuel" (players 2) (equipment {(board (remove (rotate 30 (dual (tiling T3636 5))) cells:{0 4 5 73 81 97 142 143 152})) (tile "Rhombus" Each)}) (rules (play (move Select (from (sites Empty) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))) (to (sites Around (from) Empty Orthogonal) if:(not (all Sites (sites Around (to) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from)))))) (then (do (forEach Site (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) (set State at:(site) 1)) next:(do (add (to (intersection (sites Around (last From) Orthogonal includeSelf:True) (sites Around (last To) Orthogonal includeSelf:True)))) next:(addScore Mover (% (count Sites in:(forEach (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) if:(!= 1 (state at:(site))))) 2))))))) (end (if (no Moves Next) (byScore {(score P1 (+ {(score P1) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P1)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))))))})) (score P2 (+ {(score P2) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P2)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))))))}))}))))) 
On your turn, you place a hexagonal tile of your color that covers three mutually orthogonally adjacent rhombuses. In Ludii this is done by first selecting one of the rhombuses the tile will cover, then another. The third one is determined by these two selections. When no more placements are possible, the game is over and the winner is the player with the higher score. The general idea behind the scoring is simple: You get 1 point per empty rhombus that ends up adjacent to more of your hexagons than your opponent's hexagons. However, two slight complications are necessary to exclude all draws in as fair a manner as possible: 1: You score 1 point every time you make a placement that closes off an odd number of tied rhombuses. (A rhombus is closed off when it is adjacent to no rhombus that can be filled in on a future turn.) This is equivalent to dividing tied cells between you in a "one for me, one for you, one for me"-fashion as they are closed off. 2: You get 1 bonus point if your opponent has made more placements than you at the end of the game. All scoring is automatic in Ludii.
(game "Residuel" (players 2) (equipment {(board (remove (rotate 30 (dual (tiling T3636 5))) cells:{0 4 5 73 81 97 142 143 152})) (tile "Rhombus" Each)}) (rules (play (move Select (from (sites Empty) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))) (to (sites Around (from) Empty Orthogonal) if:(not (all Sites (sites Around (to) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from)))))) (then (do (forEach Site (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) (set State at:(site) 1)) next:(do (add (to (intersection (sites Around (last From) Orthogonal includeSelf:True) (sites Around (last To) Orthogonal includeSelf:True)))) next:(addScore Mover (% (count Sites in:(forEach (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) if:(!= 1 (state at:(site))))) 2))))))) (end (if (no Moves Next) (byScore {(score P1 (+ {(score P1) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P1)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))))))})) (score P2 (+ {(score P2) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P2)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))))))}))}))))) 
On your turn, you place a hexagonal tile of your color that covers three mutually orthogonally adjacent rhombuses. In Ludii this is done by first selecting one of the rhombuses the tile will cover, then another. The third one is determined by these two selections. When no more placements are possible, the game is over and the winner is the player with the higher score. The general idea behind the scoring is simple: You get 1 point per empty rhombus that ends up adjacent to more of your hexagons than your opponent's hexagons. However, two slight complications are necessary to exclude all draws in as fair a manner as possible: 1: You score 1 point every time you make a placement that closes off an odd number of tied rhombuses. (A rhombus is closed off when it is adjacent to no rhombus that can be filled in on a future turn.) This is equivalent to dividing tied cells between you in a "one for me, one for you, one for me"-fashion as they are closed off. 2: You get 1 bonus point if your opponent has made more placements than you at the end of the game. All scoring is automatic in Ludii.
(game "Residuel" (players 2) (equipment {(board (remove (rotate 30 (dual (tiling T3636 5))) cells:{0 4 5 73 81 97 142 143 152})) (tile "Rhombus" Each)}) (rules (play (move Select (from (sites Empty) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))) (to (sites Around (from) Empty Orthogonal) if:(not (all Sites (sites Around (to) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from)))))) (then (do (forEach Site (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) (set State at:(site) 1)) next:(do (add (to (intersection (sites Around (last From) Orthogonal includeSelf:True) (sites Around (last To) Orthogonal includeSelf:True)))) next:(addScore Mover (% (count Sites in:(forEach (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) if:(!= 1 (state at:(site))))) 2))))))) (end (if (no Moves Next) (byScore {(score P1 (+ {(score P1) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P1)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))))))})) (score P2 (+ {(score P2) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P2)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))))))}))}))))) 
Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 8x8.
(game "Reversi" (players 2) (equipment {(board (square 8)) (piece "Disc" Neutral (flips 1 2))}) (rules (start {(place "Disc0" (difference (sites Centre) (sites Phase 1)) state:1) (place "Disc0" (difference (sites Centre) (sites Phase 0)) state:2)}) phases:{(phase "Playing" (play (forEach Site (sites Empty) (append (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece "Disc0" state:(mover)) (to (site))) (flip (between))))) (to if:(is Friend (state at:(to))))) (then (and (set Score P1 (count Sites in:(sites State 1))) (set Score P2 (count Sites in:(sites State 2)))))))))} (end (if (all Passed) (byScore))))) 
Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 4x4.
(game "Reversi" (players 2) (equipment {(board (square 4)) (piece "Disc" Neutral (flips 1 2))}) (rules phases:{(phase "Placement" (play (move Add (piece "Disc0" state:(mover)) (to (intersection (sites Empty) (sites Centre))))) (nextPhase Mover (>= (count Moves) 3) "Playing")) (phase "Playing" (play (forEach Site (sites Empty) (append (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece "Disc0" state:(mover)) (to (site))) (flip (between))))) (to if:(is Friend (state at:(to))))) (then (and (set Score P1 (count Sites in:(sites State 1))) (set Score P2 (count Sites in:(sites State 2)))))))))} (end (if (all Passed) (byScore))))) 
Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 6x6.
(game "Reversi" (players 2) (equipment {(board (square 6)) (piece "Disc" Neutral (flips 1 2))}) (rules (start {(place "Disc0" (difference (sites Centre) (sites Phase 1)) state:1) (place "Disc0" (difference (sites Centre) (sites Phase 0)) state:2)}) phases:{(phase "Playing" (play (forEach Site (sites Empty) (append (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece "Disc0" state:(mover)) (to (site))) (flip (between))))) (to if:(is Friend (state at:(to))))) (then (and (set Score P1 (count Sites in:(sites State 1))) (set Score P2 (count Sites in:(sites State 2)))))))))} (end (if (all Passed) (byScore))))) 
Tumbleweed is played with stackable tokens on a hexhex board. A stack is said to be seen from a hex when they are connected by a straight line, with no stacks in between. The players take turns settling hexes by placing a stack of their tokens on a hex of their choice. The height of a new stack is equal to the number of friendly stacks seen from the settled hex. Removing a stack occupying a hex and re-settling it with a new stack is possible, only as long as the new stack is taller than the previous one. This works with opponent stacks (to capture), or your own stacks (to reinforce). The board is initially empty, except for a central neutral (blue) two-stack. The first player sets up initial one-stacks: White and Red. The second player then chooses which side he wants to play, by clicking on a stone. Red goes first. The game ends when no more moves can be made by either player, or after two successive passes. The player who occupies over half the board wins. The program automatically scores indirectly controlled territory. Played on a size 8 board.
(game "Tumbleweed" (players 2) (equipment {(board (hex 8)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (start (place Stack "Disc0" (centrePoint) count:2)) phases:{(phase "Opening" (play (if (= 0 (count Moves)) (move Add (piece "Disc1") (to (sites Empty)) (then (moveAgain))) (if (= 1 (count Moves)) (move Add (piece "Disc2") (to (sites Empty))) (move Select (from (union (sites Occupied by:P1) (sites Occupied by:P2))) (then (if (= 1 (who at:(last From))) (do (swap Players 1 2) next:(set NextPlayer (player 1))) (pass))))))) (nextPhase (= 3 (count Moves)) "Play")) (phase "Play" (play (or (move Select (from (forEach (sites Board) if:(> (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(site)))) (size Stack at:(site))))) (then (add (to (last From)) count:(- (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(last From)))) (size Stack at:(last From))) stack:True))) (move Pass))))} (end (if (all Passed) (byScore {(score P1 (+ (count Sites in:(sites Occupied by:P1)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site))))))))) (score P2 (+ (count Sites in:(sites Occupied by:P2)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))))))))}))))) 
Tumbleweed is played with stackable tokens on a hexhex board. A stack is said to be seen from a hex when they are connected by a straight line, with no stacks in between. The players take turns settling hexes by placing a stack of their tokens on a hex of their choice. The height of a new stack is equal to the number of friendly stacks seen from the settled hex. Removing a stack occupying a hex and re-settling it with a new stack is possible, only as long as the new stack is taller than the previous one. This works with opponent stacks (to capture), or your own stacks (to reinforce). The board is initially empty, except for a central neutral (blue) two-stack. The first player sets up initial one-stacks: White and Red. The second player then chooses which side he wants to play, by clicking on a stone. Red goes first. The game ends when no more moves can be made by either player, or after two successive passes. The player who occupies over half the board wins. The program automatically scores indirectly controlled territory. Played on a size 5 board.
(game "Tumbleweed" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (start (place Stack "Disc0" (centrePoint) count:2)) phases:{(phase "Opening" (play (if (= 0 (count Moves)) (move Add (piece "Disc1") (to (sites Empty)) (then (moveAgain))) (if (= 1 (count Moves)) (move Add (piece "Disc2") (to (sites Empty))) (move Select (from (union (sites Occupied by:P1) (sites Occupied by:P2))) (then (if (= 1 (who at:(last From))) (do (swap Players 1 2) next:(set NextPlayer (player 1))) (pass))))))) (nextPhase (= 3 (count Moves)) "Play")) (phase "Play" (play (or (move Select (from (forEach (sites Board) if:(> (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(site)))) (size Stack at:(site))))) (then (add (to (last From)) count:(- (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(last From)))) (size Stack at:(last From))) stack:True))) (move Pass))))} (end (if (all Passed) (byScore {(score P1 (+ (count Sites in:(sites Occupied by:P1)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site))))))))) (score P2 (+ (count Sites in:(sites Occupied by:P2)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))))))))}))))) 
Tumbleweed is played with stackable tokens on a hexhex board. A stack is said to be seen from a hex when they are connected by a straight line, with no stacks in between. The players take turns settling hexes by placing a stack of their tokens on a hex of their choice. The height of a new stack is equal to the number of friendly stacks seen from the settled hex. Removing a stack occupying a hex and re-settling it with a new stack is possible, only as long as the new stack is taller than the previous one. This works with opponent stacks (to capture), or your own stacks (to reinforce). The board is initially empty, except for a central neutral (blue) two-stack. The first player sets up initial one-stacks: White and Red. The second player then chooses which side he wants to play, by clicking on a stone. Red goes first. The game ends when no more moves can be made by either player, or after two successive passes. The player who occupies over half the board wins. The program automatically scores indirectly controlled territory. Played on a size 6 board.
(game "Tumbleweed" (players 2) (equipment {(board (hex 6)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (start (place Stack "Disc0" (centrePoint) count:2)) phases:{(phase "Opening" (play (if (= 0 (count Moves)) (move Add (piece "Disc1") (to (sites Empty)) (then (moveAgain))) (if (= 1 (count Moves)) (move Add (piece "Disc2") (to (sites Empty))) (move Select (from (union (sites Occupied by:P1) (sites Occupied by:P2))) (then (if (= 1 (who at:(last From))) (do (swap Players 1 2) next:(set NextPlayer (player 1))) (pass))))))) (nextPhase (= 3 (count Moves)) "Play")) (phase "Play" (play (or (move Select (from (forEach (sites Board) if:(> (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(site)))) (size Stack at:(site))))) (then (add (to (last From)) count:(- (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(last From)))) (size Stack at:(last From))) stack:True))) (move Pass))))} (end (if (all Passed) (byScore {(score P1 (+ (count Sites in:(sites Occupied by:P1)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site))))))))) (score P2 (+ (count Sites in:(sites Occupied by:P2)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))))))))}))))) 
The game begins with the pieces set out as in the diagram. 2. The king's side takes the first move, play then alternating between players. 3. In his turn a player moves one of his pieces along a straight line, horizontally or vertically. 4. No piece may land on another, nor is there any jumping. 5. Only the king can land on the central space, though other pieces can pass through it. 6. Only the king may move to the spaces occupied by the fixed men: see rule 11. 7. The king is captured by surrounding him on all four sides by counts. If he is next to the central square or the edge of the board, he may be captured by surrounding him on the other three sides. 8. Dukes and counts are captured by surrounding them with enemies on two opposite sides, horizontally or vertically. Two or three men may be captured simultaneously if each falls between the moving piece and another enemy. 9. The fixed men in the corners may be used to capture pieces by either player. 10. A piece may come to rest voluntarily between two others, without being captured. 11. If the king moves to one of the squares occupied by the fixed men, he has escaped the board and wins the game. 12. If the king is captured by his opponents, then he has lost the game. The rules are describing with the Cyningstan ruleset.
(game "Alea Evangelii" (players 2) (equipment {(board (square 19)) (regions "Fortresses" (expand (sites Corners))) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(is Friend (who at:(to)))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(!= (to) (centrePoint))))))}) (rules (start {(place "Thrall1" {"C1" "F1" "N1" "Q1" "A3" "F3" "N3" "S3" "H4" "L4" "G5" "I5" "K5" "M5" "A6" "C6" "Q6" "S6" "E7" "O7" "D8" "P8" "E9" "O9" "E11" "O11" "D12" "P12" "E13" "O13" "A14" "C14" "Q14" "S14" "G15" "I15" "K15" "M15" "H16" "L16" "A17" "F17" "N17" "S17" "C19" "F19" "N19" "Q19"}) (place "Thrall2" {"J4" "F6" "N6" "J7" "I8" "K8" "H9" "J9" "L9" "D10" "G10" "I10" "K10" "M10" "P10" "H11" "J11" "L11" "I12" "K12" "J13" "F14" "N14" "J16"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
The game begins with the pieces set out as in the diagram. 2. The king's side takes the first move, play then alternating between players. 3. In his turn a player moves one of his pieces along a straight line, horizontally or vertically. 4. No piece may land on another, nor is there any jumping. 5. Only the king can land on the central space, though other pieces can pass through it. 6. Only the king may move to the spaces occupied by the fixed men: see rule 11. 7. The king is captured by surrounding him on all four sides by counts. If he is next to the central square or the edge of the board, he may be captured by surrounding him on the other three sides. 8. Dukes and counts are captured by surrounding them with enemies on two opposite sides, horizontally or vertically. Two or three men may be captured simultaneously if each falls between the moving piece and another enemy. 9. The fixed men in the corners may be used to capture pieces by either player. 10. A piece may come to rest voluntarily between two others, without being captured. 11. If the king moves to one of the squares occupied by the fixed men, he has escaped the board and wins the game. 12. If the king is captured by his opponents, then he has lost the game. The rules are describing with the Cyningstan ruleset.
(game "Alea Evangelii" (players 2) (equipment {(board (square 19)) (regions "Fortresses" (expand (sites Corners))) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(is Friend (who at:(to)))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(!= (to) (centrePoint))))))}) (rules (start {(place "Thrall1" {"C1" "F1" "N1" "Q1" "A3" "F3" "N3" "S3" "H4" "L4" "G5" "I5" "K5" "M5" "A6" "C6" "Q6" "S6" "E7" "O7" "D8" "P8" "E9" "O9" "E11" "O11" "D12" "P12" "E13" "O13" "A14" "C14" "Q14" "S14" "G15" "I15" "K15" "M15" "H16" "L16" "A17" "F17" "N17" "S17" "C19" "F19" "N19" "Q19"}) (place "Thrall2" {"J4" "F6" "N6" "J7" "I8" "K8" "H9" "J9" "L9" "D10" "G10" "I10" "K10" "M10" "P10" "H11" "J11" "L11" "I12" "K12" "J13" "F14" "N14" "J16"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
The game begins with the pieces set out as in the diagram. 2. The king's side takes the first move, play then alternating between players. 3. In his turn a player moves one of his pieces along a straight line, horizontally or vertically. 4. No piece may land on another, nor is there any jumping. 5. Only the king can land on the central space, though other pieces can pass through it. 6. Only the king may move to the spaces occupied by the fixed men: see rule 11. 7. The king is captured by surrounding him on all four sides by counts. If he is next to the central square or the edge of the board, he may be captured by surrounding him on the other three sides. 8. Dukes and counts are captured by surrounding them with enemies on two opposite sides, horizontally or vertically. Two or three men may be captured simultaneously if each falls between the moving piece and another enemy. 9. The fixed men in the corners may be used to capture pieces by either player. 10. A piece may come to rest voluntarily between two others, without being captured. 11. If the king moves to one of the squares occupied by the fixed men, he has escaped the board and wins the game. 12. If the king is captured by his opponents, then he has lost the game. The rules are describing with the Cyningstan ruleset.
(game "Alea Evangelii" (players 2) (equipment {(board (square 19)) (regions "Fortresses" (expand (sites Corners))) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(is Friend (who at:(to)))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(!= (to) (centrePoint))))))}) (rules (start {(place "Thrall1" {"C1" "F1" "N1" "Q1" "A3" "F3" "N3" "S3" "H4" "L4" "G5" "I5" "K5" "M5" "A6" "C6" "Q6" "S6" "E7" "O7" "D8" "P8" "E9" "O9" "E11" "O11" "D12" "P12" "E13" "O13" "A14" "C14" "Q14" "S14" "G15" "I15" "K15" "M15" "H16" "L16" "A17" "F17" "N17" "S17" "C19" "F19" "N19" "Q19"}) (place "Thrall2" {"J4" "F6" "N6" "J7" "I8" "K8" "H9" "J9" "L9" "D10" "G10" "I10" "K10" "M10" "P10" "H11" "J11" "L11" "I12" "K12" "J13" "F14" "N14" "J16"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Each player has four pieces. Players take turns moving a piece to an empty dot. A player may capture an opponent’s piece by placing a piece on either side of an opponent’s piece. If a player moves their own piece between two of the opponent’s pieces, it is not captured. A player wins by reducing the opponent to one piece. The game is played according to the rules of the source.
(game "Boseog Gonu" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 -1 (rotate 180 (wedge 2))) (shift 0 2 (wedge 2)) (shift -1.5 0.5 (rotate 90 (wedge 2))) (shift 1.5 0.5 (rotate -90 (wedge 2)))}) edges:{{{1 1} {0 0}} {{1 1} {2 2}} {{1 1} {2 0}} {{1 1} {0 2}}}) use:Vertex) (piece "Disc" Each (move Step (to if:(is Empty (to))) (then (custodial (from (last To)) (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(= (what at:(to)) (what at:(last To))))))))}) (rules (start {(place "Disc1" {"A3" "B3" "B4" "B2"}) (place "Disc2" {"D2" "D3" "E3" "D4"})}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
Each player has four pieces. Players take turns moving a piece to an empty dot. A player may capture an opponent’s piece by placing a piece on either side of an opponent’s piece. If a player moves their own piece between two of the opponent’s pieces, it is not captured. A player wins by reducing the opponent to one piece. The game is played according to the rules of the source but the capture is allowed only horizontally and vertically.
(game "Boseog Gonu" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 -1 (rotate 180 (wedge 2))) (shift 0 2 (wedge 2)) (shift -1.5 0.5 (rotate 90 (wedge 2))) (shift 1.5 0.5 (rotate -90 (wedge 2)))}) edges:{{{1 1} {0 0}} {{1 1} {2 2}} {{1 1} {2 0}} {{1 1} {0 2}}}) use:Vertex) (piece "Disc" Each (move Step (to if:(is Empty (to))) (then (custodial (from (last To)) Axial (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(= (what at:(to)) (what at:(last To))))))))}) (rules (start {(place "Disc1" {"A3" "B3" "B4" "B2"}) (place "Disc2" {"D2" "D3" "E3" "D4"})}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
Each player has four pieces. Players take turns moving a piece to an empty dot. A player may capture an opponent’s piece by placing a piece on either side of an opponent’s piece. If a player moves their own piece between two of the opponent’s pieces, it is not captured. A player wins by reducing the opponent to one piece. The game is played according to the rules described in Youtube. The two differences with the source is: Capture possible only horizontally and vertically and the pieces can slide.
(game "Boseog Gonu" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 -1 (rotate 180 (wedge 2))) (shift 0 2 (wedge 2)) (shift -1.5 0.5 (rotate 90 (wedge 2))) (shift 1.5 0.5 (rotate -90 (wedge 2)))}) edges:{{{1 1} {0 0}} {{1 1} {2 2}} {{1 1} {2 0}} {{1 1} {0 2}}}) use:Vertex) (piece "Disc" Each (move Slide (then (custodial (from (last To)) Axial (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(= (what at:(to)) (what at:(last To))))))))}) (rules (start {(place "Disc1" {"A3" "B3" "B4" "B2"}) (place "Disc2" {"D2" "D3" "E3" "D4"})}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
7x7 board. One player plays as the king and four defenders, the other as eight attackers. The king begins in the center piece, with the defenders placed in the adjacent orthogonal squares. The attackers are placed two in each square extending in the orthogonal direction from the defenders' positions. Attackers move first. Pieces move any distance orthogonally. No piece may land on the central square. Only the king may enter the corner squares. A piece is captured when it is surrounded orthogonally on two sides by an opposing piece. Pieces may also be captured between the central square and an opponent or a corner square and the opponent. When in the central square, the king is captured by surrounding it on four orthogonal sides. When adjacent to the central square, the king is captured by surrounding it on the three other orthogonally adjacent sides. Otherwise, the king is captured as any other piece. The king wins by moving to a corner square. The attackers win by capturing the king. The rules are describing with the Nielsen ruleset.
(game "Brandub" (players 2) (equipment {(board (square 7)) (regions "Fortresses" (sites Corners)) (piece "Thrall" P1 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites "Fortresses")))))})))) (piece "Thrall" P2 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(not (= (to) (centrePoint))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))))))}) (rules (start {(place "Thrall1" {"D1" "D2" "A4" "B4" "F4" "G4" "D6" "D7"}) (place "Thrall2" {"D3" "C4" "E4" "D5"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
7x7 board. One player plays as the king and four defenders, the other as eight attackers. The king begins in the center piece, with the defenders placed in the adjacent orthogonal squares. The attackers are placed two in each square extending in the orthogonal direction from the defenders' positions. Attackers move first. Pieces move any distance orthogonally. No piece may land on the central square. Only the king may enter the corner squares. A piece is captured when it is surrounded orthogonally on two sides by an opposing piece. Pieces may also be captured between the central square and an opponent or a corner square and the opponent. When in the central square, the king is captured by surrounding it on four orthogonal sides. When adjacent to the central square, the king is captured by surrounding it on the three other orthogonally adjacent sides. Otherwise, the king is captured as any other piece. The king wins by moving to a corner square. The attackers win by capturing the king. The rules are describing with the Nielsen ruleset.
(game "Brandub" (players 2) (equipment {(board (square 7)) (regions "Fortresses" (sites Corners)) (piece "Thrall" P1 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites "Fortresses")))))})))) (piece "Thrall" P2 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(not (= (to) (centrePoint))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))))))}) (rules (start {(place "Thrall1" {"D1" "D2" "A4" "B4" "F4" "G4" "D6" "D7"}) (place "Thrall2" {"D3" "C4" "E4" "D5"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
7x7 board. One player plays as the king and four defenders, the other as eight attackers. The king begins in the center piece, with the defenders placed in the adjacent orthogonal squares. The attackers are placed two in each square extending in the orthogonal direction from the defenders' positions. Attackers move first. Pieces move any distance orthogonally. No piece may land on the central square. Only the king may enter the corner squares. A piece is captured when it is surrounded orthogonally on two sides by an opposing piece. Pieces may also be captured between the central square and an opponent or a corner square and the opponent. When in the central square, the king is captured by surrounding it on four orthogonal sides. When adjacent to the central square, the king is captured by surrounding it on the three other orthogonally adjacent sides. Otherwise, the king is captured as any other piece. The king wins by moving to a corner square. The attackers win by capturing the king. The rules are describing with the Nielsen ruleset.
(game "Brandub" (players 2) (equipment {(board (square 7)) (regions "Fortresses" (sites Corners)) (piece "Thrall" P1 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites "Fortresses")))))})))) (piece "Thrall" P2 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(not (= (to) (centrePoint))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))))))}) (rules (start {(place "Thrall1" {"D1" "D2" "A4" "B4" "F4" "G4" "D6" "D7"}) (place "Thrall2" {"D3" "C4" "E4" "D5"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Objectives One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship. Setup Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board. Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board. Play Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship). Moves A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece. Captures A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.) This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor. Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins.
(game "Breakthru" (players 2) (equipment {(board (square 11)) (piece "Disc" Each (or (if (not (is Prev Mover)) (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (move Slide Orthogonal (then (if (not (is Prev Mover)) (moveAgain)))))) (piece "Commander" P1 (if (not (is Prev Mover)) (or (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Slide Orthogonal)))) (hand Each) (regions "CentreSites" (expand (sites Centre) steps:2))}) (rules (start {(place "Commander1" (sites Centre)) (place "Disc1" (handSite P1) count:12) (place "Disc2" (handSite P2) count:20)}) phases:{(phase "PlacementP1" (play (move (from (handSite P1)) (to (intersection (sites "CentreSites") (sites Empty))) (then (if (is Occupied (handSite P1)) (moveAgain))))) (nextPhase (is Empty (handSite P1)) "PlacementP2")) (phase "PlacementP2" (play (move (from (handSite P2)) (to (difference (sites Empty) (sites "CentreSites"))) (then (if (is Occupied (handSite P2)) (moveAgain))))) (nextPhase (is Empty (handSite P2)) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (is Within (id "Commander1") in:(sites Outer)) (result P1 Win)) (if (= (where "Commander" P1) -1) (result P2 Win))}))})) 
Objectives One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship. Setup Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board. Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board. Play Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship). Moves A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece. Captures A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.) This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor. Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins.
(game "Breakthru" (players 2) (equipment {(board (square 11)) (piece "Disc" Each (or (if (not (is Prev Mover)) (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (move Slide Orthogonal (then (if (not (is Prev Mover)) (moveAgain)))))) (piece "Commander" P1 (if (not (is Prev Mover)) (or (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Slide Orthogonal)))) (hand Each) (regions "CentreSites" (expand (sites Centre) steps:2))}) (rules (start {(place "Commander1" (sites Centre)) (place "Disc1" (handSite P1) count:12) (place "Disc2" (handSite P2) count:20)}) phases:{(phase "PlacementP1" (play (move (from (handSite P1)) (to (intersection (sites "CentreSites") (sites Empty))) (then (if (is Occupied (handSite P1)) (moveAgain))))) (nextPhase (is Empty (handSite P1)) "PlacementP2")) (phase "PlacementP2" (play (move (from (handSite P2)) (to (difference (sites Empty) (sites "CentreSites"))) (then (if (is Occupied (handSite P2)) (moveAgain))))) (nextPhase (is Empty (handSite P2)) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (is Within (id "Commander1") in:(sites Outer)) (result P1 Win)) (if (= (where "Commander" P1) -1) (result P2 Win))}))})) 
Objectives One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship. Setup Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board. Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board. Play Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship). Moves A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece. Captures A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.) This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor. Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins.
(game "Breakthru" (players 2) (equipment {(board (square 11)) (piece "Disc" Each (or (if (not (is Prev Mover)) (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (move Slide Orthogonal (then (if (not (is Prev Mover)) (moveAgain)))))) (piece "Commander" P1 (if (not (is Prev Mover)) (or (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Slide Orthogonal)))) (hand Each) (regions "CentreSites" (expand (sites Centre) steps:2))}) (rules (start {(place "Commander1" (sites Centre)) (place "Disc1" (handSite P1) count:12) (place "Disc2" (handSite P2) count:20)}) phases:{(phase "PlacementP1" (play (move (from (handSite P1)) (to (intersection (sites "CentreSites") (sites Empty))) (then (if (is Occupied (handSite P1)) (moveAgain))))) (nextPhase (is Empty (handSite P1)) "PlacementP2")) (phase "PlacementP2" (play (move (from (handSite P2)) (to (difference (sites Empty) (sites "CentreSites"))) (then (if (is Occupied (handSite P2)) (moveAgain))))) (nextPhase (is Empty (handSite P2)) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (is Within (id "Commander1") in:(sites Outer)) (result P1 Win)) (if (= (where "Commander" P1) -1) (result P2 Win))}))})) 
There are 30 game-pieces for each player and eleven castles. The gameboard is divided into three sections: homes and center section. Object of the game is to capture four castles (among those of the central section and the other side) or 28 pawns of your opponent. In a turn a player moves one of their pieces, horizontally, vertically. A pawn can step to an adjacent empty cell. Additionally a pawn can jump over another pawn as long as the square behind that pawn is free. Multiple jumps are allowed and all enemy pawns are captured this way and removed from the deck. A pawn can capture a maximum of five enemy pieces, and his movement ends after the fifth piece is captured. A castle is conquered when it is surrounded by three pawns.
(game "Castello" (players 2) (equipment {(board (rectangle 15 21)) (piece "Pawn" Each (or (move Hop Orthogonal (between if:(and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Step Orthogonal (to if:(is Empty (to)))))) (piece "Castle" Neutral) (hand Each size:3) (regions "LeftPart" (expand (sites Left) steps:6)) (regions "RightPart" (expand (sites Right) steps:6)) (regions "Middle" (expand (sites Centre)))}) (rules (start {(place "Pawn1" (expand (sites Left))) (place "Pawn2" (expand (sites Right))) (place "Castle0" (sites {"G2" "F6" "G10" "F14" "K3" "K8" "K13" "P2" "O6" "P10" "O14"}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(if (< (counter) 5) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Pass)) (forEach Piece) (then (and (if (is In (last To) (sites "LeftPart")) (if (< (count Cell at:(handSite Mover)) 3) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover))))) (to if:(is Friend (who at:(to)))) except:1)) (if (is In (last To) (sites "RightPart")) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 2))))) (to if:(is Friend (who at:(to)))) except:1) (if (is In (last To) (sites "Middle")) (if (> (count Cell at:(handSite Mover 2)) 0) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)))) (set Counter))))) (end {(if (<= (count Pieces Next) 3) (result Next Loss)) (if (> (count in:(sites Hand Mover)) 3) (result Mover Win))}))) 
There are 30 game-pieces for each player and eleven castles. The gameboard is divided into three sections: homes and center section. Object of the game is to capture four castles (among those of the central section and the other side) or 28 pawns of your opponent. In a turn a player moves one of their pieces, horizontally, vertically. A pawn can step to an adjacent empty cell. Additionally a pawn can jump over another pawn as long as the square behind that pawn is free. Multiple jumps are allowed and all enemy pawns are captured this way and removed from the deck. A pawn can capture a maximum of five enemy pieces, and his movement ends after the fifth piece is captured. A castle is conquered when it is surrounded by three pawns.
(game "Castello" (players 2) (equipment {(board (rectangle 15 21)) (piece "Pawn" Each (or (move Hop Orthogonal (between if:(and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Step Orthogonal (to if:(is Empty (to)))))) (piece "Castle" Neutral) (hand Each size:3) (regions "LeftPart" (expand (sites Left) steps:6)) (regions "RightPart" (expand (sites Right) steps:6)) (regions "Middle" (expand (sites Centre)))}) (rules (start {(place "Pawn1" (expand (sites Left))) (place "Pawn2" (expand (sites Right))) (place "Castle0" (sites {"G2" "F6" "G10" "F14" "K3" "K8" "K13" "P2" "O6" "P10" "O14"}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(if (< (counter) 5) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Pass)) (forEach Piece) (then (and (if (is In (last To) (sites "LeftPart")) (if (< (count Cell at:(handSite Mover)) 3) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover))))) (to if:(is Friend (who at:(to)))) except:1)) (if (is In (last To) (sites "RightPart")) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 2))))) (to if:(is Friend (who at:(to)))) except:1) (if (is In (last To) (sites "Middle")) (if (> (count Cell at:(handSite Mover 2)) 0) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)))) (set Counter))))) (end {(if (<= (count Pieces Next) 3) (result Next Loss)) (if (> (count in:(sites Hand Mover)) 3) (result Mover Win))}))) 
There are 30 game-pieces for each player and eleven castles. The gameboard is divided into three sections: homes and center section. Object of the game is to capture four castles (among those of the central section and the other side) or 28 pawns of your opponent. In a turn a player moves one of their pieces, horizontally, vertically. A pawn can step to an adjacent empty cell. Additionally a pawn can jump over another pawn as long as the square behind that pawn is free. Multiple jumps are allowed and all enemy pawns are captured this way and removed from the deck. A pawn can capture a maximum of five enemy pieces, and his movement ends after the fifth piece is captured. A castle is conquered when it is surrounded by three pawns.
(game "Castello" (players 2) (equipment {(board (rectangle 15 21)) (piece "Pawn" Each (or (move Hop Orthogonal (between if:(and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Step Orthogonal (to if:(is Empty (to)))))) (piece "Castle" Neutral) (hand Each size:3) (regions "LeftPart" (expand (sites Left) steps:6)) (regions "RightPart" (expand (sites Right) steps:6)) (regions "Middle" (expand (sites Centre)))}) (rules (start {(place "Pawn1" (expand (sites Left))) (place "Pawn2" (expand (sites Right))) (place "Castle0" (sites {"G2" "F6" "G10" "F14" "K3" "K8" "K13" "P2" "O6" "P10" "O14"}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(if (< (counter) 5) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Pass)) (forEach Piece) (then (and (if (is In (last To) (sites "LeftPart")) (if (< (count Cell at:(handSite Mover)) 3) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover))))) (to if:(is Friend (who at:(to)))) except:1)) (if (is In (last To) (sites "RightPart")) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 2))))) (to if:(is Friend (who at:(to)))) except:1) (if (is In (last To) (sites "Middle")) (if (> (count Cell at:(handSite Mover 2)) 0) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)))) (set Counter))))) (end {(if (<= (count Pieces Next) 3) (result Next Loss)) (if (> (count in:(sites Hand Mover)) 3) (result Mover Win))}))) 
17x17 board. 144 pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player in unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins. States can not be repeated. Kharebga rules applied to a 17x17 board.
(game "Poprad Game" (players 2) (equipment {(board (square 17)) (piece "Marker" Each (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (hand Each)}) (rules (meta (no Repeat)) (start (place "Marker" "Hand" count:144)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (not (is Prev Mover))) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (forEach Piece)))} (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
17x17 board. 144 pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player in unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins. States can be repeated. Seega rules applied to a 17x17 board.
(game "Poprad Game" (players 2) (equipment {(board (square 17)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:144)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (not (is Prev Mover))) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (forEach Piece)))} (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
17x17 board. 144 pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player in unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins. States can not be repeated. Kharebga rules applied to a 17x18 board.
(game "Poprad Game" (players 2) (equipment {(board (rectangle 17 18)) (piece "Marker" Each (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (hand Each)}) (rules (meta (no Repeat)) (start (place "Marker" "Hand" count:152)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (not (is Prev Mover))) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (forEach Piece)))} (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so. The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins. In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely.
(game "Sabou'iyya" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (if (= 0 (count Pieces Mover in:(sites Board))) (forEach (sites Around (centrePoint) Orthogonal) if:(is Empty (site))) (difference (sites Board) (centrePoint))) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (if (is Prev Mover) (or (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain)))))) (move Pass)) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so. The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins. In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely.
(game "Sabou'iyya" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (if (= 0 (count Pieces Mover in:(sites Board))) (forEach (sites Around (centrePoint) Orthogonal) if:(is Empty (site))) (difference (sites Board) (centrePoint))) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (if (is Prev Mover) (or (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain)))))) (move Pass)) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so. The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins. In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely.
(game "Sabou'iyya" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (if (= 0 (count Pieces Mover in:(sites Board))) (forEach (sites Around (centrePoint) Orthogonal) if:(is Empty (site))) (difference (sites Board) (centrePoint))) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (if (is Prev Mover) (or (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain)))))) (move Pass)) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required. Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. When a piece does not capture the maximum number of captures and the opponent catches it, the opponent captures the opponent's piece. The first player to capture all of the opponent's pieces wins.
(game "Dama (Italy)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))})) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required. Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. When a piece does not capture the maximum number of captures and the opponent catches it, the opponent captures the opponent's piece. The first player to capture all of the opponent's pieces wins.
(game "Dama (Italy)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))})) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required. Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. When a piece does not capture the maximum number of captures and the opponent catches it, the opponent captures the opponent's piece. The first player to capture all of the opponent's pieces wins.
(game "Dama (Italy)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))})) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
5x5 grid of points, four point in each row, each alternating position with an end point on the left or right edge. Points are connecting with diagonal lines. Twelve pieces per player, positioned on the first three rows closest to the player. Players alternate turns moving a piece forward to an empty adjacent spot along the lines. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins.
(game "Dama (Philippines)" (players 2) (equipment {(board (rotate 45 (merge {(rectangle 5 4) (shift -1 1 (rectangle 3 6)) (shift -2 2 (rectangle 1 8)) (shift 1 -1 (rectangle 7 2))})) use:Vertex) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:(- 3 1))) (place "Counter2" (expand (sites Top) steps:(- 3 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or {(forEach Piece "Counter" (move Hop (from (from)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide))}))) (end (if (no Moves Next) (result Mover Win))))) 
5x5 grid of points, four point in each row, each alternating position with an end point on the left or right edge. Points are connecting with diagonal lines. Twelve pieces per player, positioned on the first three rows closest to the player. Players alternate turns moving a piece forward to an empty adjacent spot along the lines. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins.
(game "Dama (Philippines)" (players 2) (equipment {(board (rotate 45 (merge {(rectangle 5 4) (shift -1 1 (rectangle 3 6)) (shift -2 2 (rectangle 1 8)) (shift 1 -1 (rectangle 7 2))})) use:Vertex) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:(- 3 1))) (place "Counter2" (expand (sites Top) steps:(- 3 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or {(forEach Piece "Counter" (move Hop (from (from)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide))}))) (end (if (no Moves Next) (result Mover Win))))) 
5x5 grid of points, four point in each row, each alternating position with an end point on the left or right edge. Points are connecting with diagonal lines. Twelve pieces per player, positioned on the first three rows closest to the player. Players alternate turns moving a piece forward to an empty adjacent spot along the lines. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins.
(game "Dama (Philippines)" (players 2) (equipment {(board (rotate 45 (merge {(rectangle 5 4) (shift -1 1 (rectangle 3 6)) (shift -2 2 (rectangle 1 8)) (shift 1 -1 (rectangle 7 2))})) use:Vertex) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:(- 3 1))) (place "Counter2" (expand (sites Top) steps:(- 3 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or {(forEach Piece "Counter" (move Hop (from (from)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 checkered board. twelve pieces per player, placed on the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is required, and failure to do so is penalized by the huff, where the piece that should have made the capture is itself captured. When a piece reaches the opposite edge of the board from where it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damas" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (do (set Pending (sites From (max Moves (or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))) next:(or {(forEach Piece "Counter" (max Moves (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))))) (forEach Piece "DoubleCounter" (max Moves (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal))}) (then (and (if (and (!= (value Player Mover) (last To)) (not (is In (last To) (sites Pending)))) (remove (sites Pending))) (if (and (!= (value Player Mover) (last To)) (is In (last From) (sites Pending))) (remove (last To)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
8x8 checkered board. twelve pieces per player, placed on the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is required, and failure to do so is penalized by the huff, where the piece that should have made the capture is itself captured. When a piece reaches the opposite edge of the board from where it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damas" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (do (set Pending (sites From (max Moves (or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))) next:(or {(forEach Piece "Counter" (max Moves (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))))) (forEach Piece "DoubleCounter" (max Moves (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal))}) (then (and (if (and (!= (value Player Mover) (last To)) (not (is In (last To) (sites Pending)))) (remove (sites Pending))) (if (and (!= (value Player Mover) (last To)) (is In (last From) (sites Pending))) (remove (last To)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
8x8 checkered board. twelve pieces per player, placed on the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is required, and failure to do so is penalized by the huff, where the piece that should have made the capture is itself captured. When a piece reaches the opposite edge of the board from where it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damas" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (do (set Pending (sites From (max Moves (or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))) next:(or {(forEach Piece "Counter" (max Moves (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))))) (forEach Piece "DoubleCounter" (max Moves (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal))}) (then (and (if (and (!= (value Player Mover) (last To)) (not (is In (last To) (sites Pending)))) (remove (sites Pending))) (if (and (!= (value Player Mover) (last To)) (is In (last From) (sites Pending))) (remove (last To)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started, it stops moving (if in a capture sequence), becomes a king, and the turn ends. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damenspiel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started, it stops moving (if in a capture sequence), becomes a king, and the turn ends. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damenspiel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started, it stops moving (if in a capture sequence), becomes a king, and the turn ends. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damenspiel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Pieces Next) (result Next Loss))))) 
10x10 board, with red and white checkeres squares. Twenty pieces per player, which are arranged on the first four ranks closest to the player. Pieces move diagonally one space forward. Pieces may capture an opponent's piece by hopping over it diagonally to an empty adjacent square immediately on the other side of it. Pieces cannot capture in a backwards direction. The maximum number of pieces must be captured. If a player does not capture the maximum number of pieces, the other player may huff this piece, removing it from play. When a piece reaches the opposite edge of the board from where it started, it is promoted to king. Kings may move any distance diagonally, in a forward or backward direction. The player who captures all of their opponent's pieces wins.
(game "Dum Blas" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
10x10 board, with red and white checkeres squares. Twenty pieces per player, which are arranged on the first four ranks closest to the player. Pieces move diagonally one space forward. Pieces may capture an opponent's piece by hopping over it diagonally to an empty adjacent square immediately on the other side of it. Pieces cannot capture in a backwards direction. The maximum number of pieces must be captured. If a player does not capture the maximum number of pieces, the other player may huff this piece, removing it from play. When a piece reaches the opposite edge of the board from where it started, it is promoted to king. Kings may move any distance diagonally, in a forward or backward direction. The player who captures all of their opponent's pieces wins.
(game "Dum Blas" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
10x10 board, with red and white checkeres squares. Twenty pieces per player, which are arranged on the first four ranks closest to the player. Pieces move diagonally one space forward. Pieces may capture an opponent's piece by hopping over it diagonally to an empty adjacent square immediately on the other side of it. Pieces cannot capture in a backwards direction. The maximum number of pieces must be captured. If a player does not capture the maximum number of pieces, the other player may huff this piece, removing it from play. When a piece reaches the opposite edge of the board from where it started, it is promoted to king. Kings may move any distance diagonally, in a forward or backward direction. The player who captures all of their opponent's pieces wins.
(game "Dum Blas" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces.
(game "English Draughts" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces.
(game "English Draughts" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces.
(game "English Draughts" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
This game is played on an empty 8x8 square chess board. Use 6 checkers and 66 Go stones. The Counterinsurgent (COIN) player places his checkers on black squares in the middle of the board. The Guerrilla player starts with no pieces on the board, but begins by placing one stone anywhere on the board, then a second stone orthogonally adjacent to the first. The Guerrilla player does not move his pieces. Instead, he places two and only two stones per turn on the board, on the intersections of the squares. The first stone must be orthogonally adjacent to any stone on the board; the second stone must be orthogonally adjacent to the first stone placed. He may not place stones on the board edge points. He captures an enemy checker by surrounding it. COIN player moves one checker per turn, one square diagonally as a King in regular checkers, or makes captures by jumping over the point between two squares. He is not forced to capture if he does not want to, but if he does he must take all possible captures. Captured stones are removed from the board. GOAL - The player who clears the board of all enemy pieces at the end of his turn wins. The Guerrilla player loses if he runs out of stones
(game "Guerrilla Checkers" (players 2) (equipment {(board (square 9) use:Vertex) (hand P1) (piece "Marker" P1) (piece "Counter" P2 (move Step (from Cell) Diagonal (to Cell if:(is Empty Cell (to))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))))}) (rules (start {(place "Counter2" Cell {"E3" "D4" "C5" "D6" "E5" "F4"}) (place "Marker1" "Hand1" count:66)}) phases:{(phase "InitGuerrilla" P1 (play (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer))) (then (moveAgain)))) (nextPhase (is Next Mover) "GuerrillaMove")) (phase "GuerrillaMove" P1 (play (if (is Prev Mover) (move (from (handSite Mover)) (to Vertex (difference (sites Around (last To) Orthogonal if:(is Empty (to))) (sites Outer))) (then (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))))) (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer)) if:(not (= (count Sites in:(sites Around (to) Own Orthogonal)) 0))) (then (and (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))) (moveAgain))))))) (phase "CoinMove" P2 (play (if (is Prev Mover) (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
This game is played on an empty 8x8 square chess board. Use 6 checkers and 66 Go stones. The Counterinsurgent (COIN) player places his checkers on black squares in the middle of the board. The Guerrilla player starts with no pieces on the board, but begins by placing one stone anywhere on the board, then a second stone orthogonally adjacent to the first. The Guerrilla player does not move his pieces. Instead, he places two and only two stones per turn on the board, on the intersections of the squares. The first stone must be orthogonally adjacent to any stone on the board; the second stone must be orthogonally adjacent to the first stone placed. He may not place stones on the board edge points. He captures an enemy checker by surrounding it. COIN player moves one checker per turn, one square diagonally as a King in regular checkers, or makes captures by jumping over the point between two squares. He is not forced to capture if he does not want to, but if he does he must take all possible captures. Captured stones are removed from the board. GOAL - The player who clears the board of all enemy pieces at the end of his turn wins. The Guerrilla player loses if he runs out of stones
(game "Guerrilla Checkers" (players 2) (equipment {(board (square 9) use:Vertex) (hand P1) (piece "Marker" P1) (piece "Counter" P2 (move Step (from Cell) Diagonal (to Cell if:(is Empty Cell (to))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))))}) (rules (start {(place "Counter2" Cell {"E3" "D4" "C5" "D6" "E5" "F4"}) (place "Marker1" "Hand1" count:66)}) phases:{(phase "InitGuerrilla" P1 (play (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer))) (then (moveAgain)))) (nextPhase (is Next Mover) "GuerrillaMove")) (phase "GuerrillaMove" P1 (play (if (is Prev Mover) (move (from (handSite Mover)) (to Vertex (difference (sites Around (last To) Orthogonal if:(is Empty (to))) (sites Outer))) (then (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))))) (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer)) if:(not (= (count Sites in:(sites Around (to) Own Orthogonal)) 0))) (then (and (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))) (moveAgain))))))) (phase "CoinMove" P2 (play (if (is Prev Mover) (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
This game is played on an empty 8x8 square chess board. Use 6 checkers and 66 Go stones. The Counterinsurgent (COIN) player places his checkers on black squares in the middle of the board. The Guerrilla player starts with no pieces on the board, but begins by placing one stone anywhere on the board, then a second stone orthogonally adjacent to the first. The Guerrilla player does not move his pieces. Instead, he places two and only two stones per turn on the board, on the intersections of the squares. The first stone must be orthogonally adjacent to any stone on the board; the second stone must be orthogonally adjacent to the first stone placed. He may not place stones on the board edge points. He captures an enemy checker by surrounding it. COIN player moves one checker per turn, one square diagonally as a King in regular checkers, or makes captures by jumping over the point between two squares. He is not forced to capture if he does not want to, but if he does he must take all possible captures. Captured stones are removed from the board. GOAL - The player who clears the board of all enemy pieces at the end of his turn wins. The Guerrilla player loses if he runs out of stones
(game "Guerrilla Checkers" (players 2) (equipment {(board (square 9) use:Vertex) (hand P1) (piece "Marker" P1) (piece "Counter" P2 (move Step (from Cell) Diagonal (to Cell if:(is Empty Cell (to))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))))}) (rules (start {(place "Counter2" Cell {"E3" "D4" "C5" "D6" "E5" "F4"}) (place "Marker1" "Hand1" count:66)}) phases:{(phase "InitGuerrilla" P1 (play (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer))) (then (moveAgain)))) (nextPhase (is Next Mover) "GuerrillaMove")) (phase "GuerrillaMove" P1 (play (if (is Prev Mover) (move (from (handSite Mover)) (to Vertex (difference (sites Around (last To) Orthogonal if:(is Empty (to))) (sites Outer))) (then (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))))) (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer)) if:(not (= (count Sites in:(sites Around (to) Own Orthogonal)) 0))) (then (and (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))) (moveAgain))))))) (phase "CoinMove" P2 (play (if (is Prev Mover) (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. Twelve pieces per player. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards, and can capture by jumping over any number of pieces, any distance. The goal is to capture all of the opponent's pieces.
(game "Main Dam" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. Twelve pieces per player. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards, and can capture by jumping over any number of pieces, any distance. The goal is to capture all of the opponent's pieces.
(game "Main Dam" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. Twelve pieces per player. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards, and can capture by jumping over any number of pieces, any distance. The goal is to capture all of the opponent's pieces.
(game "Main Dam" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
In Seesaw Draughts, when a man reaches the rank farthest away in its stepping direction, its capture range is increased and it changes the direction it steps in. It can thereby promote again if it reaches the opposite rank. The mechanism is implemented like this: All men are stacks. Single pieces are stacks of size 1. Every time a man promotes a piece is added to it, so it's stack size increases by 1. The following two-fold meaning of stack size is the key idea: 1) Odd stacks step forwards and even stacks step backwards. 2) A stack of size n can capture a piece up to n steps away in a straight line provided that there are no pieces between the capturing piece and its target, and that the square immediately behind the target in the capture direction is empty. The capturing piece must land there. Thus, the men gradually acquire the capturing power of a king in Thai Checkers as they seesaw up and down the board. There is no obligation to choose the capture sequence that maximizes the number of pieces captured. We deem this calculation a bit too demanding when a stack's range is a function of its size. Other than this, the rules are as in Brazillian Draughts/Checkers, which is like International Draughts, but on 8x8.
(game "Seesaw Draughts" (players 2) (equipment {(board (square 8)) (piece "Disc" P1 N) (piece "Disc" P2 S) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Disc1" (difference (expand (sites Bottom) steps:2) (sites Phase 1))) (place "Disc2" (difference (expand (sites Top) steps:2) (sites Phase 1)))}) (play (priority (forEach Piece "Disc" (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) Diagonal distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))}) (apply (remember Value (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to)))))))) count:(size Stack at:(from)) stack:True (then (if (can Move (move (from (last To)) (to (sites Direction from:(from) (difference Diagonal (directions Cell from:(last To) to:(last From))) distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))})))) (moveAgain) (do (forEach Site (sites (values Remembered)) (remove (site) count:(size Stack at:(site)))) next:(and (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)) (forget Value All)))))) top:True) (forEach Piece "Disc" (move Step (from) (if (is Odd (size Stack at:(from))) (directions {FL FR}) (directions {BL BR})) (to if:(is Empty (to))) stack:True (then (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)))) top:True))) (end (if (no Moves Next) (result Next Loss))))) 
In Seesaw Draughts, when a man reaches the rank farthest away in its stepping direction, its capture range is increased and it changes the direction it steps in. It can thereby promote again if it reaches the opposite rank. The mechanism is implemented like this: All men are stacks. Single pieces are stacks of size 1. Every time a man promotes a piece is added to it, so it's stack size increases by 1. The following two-fold meaning of stack size is the key idea: 1) Odd stacks step forwards and even stacks step backwards. 2) A stack of size n can capture a piece up to n steps away in a straight line provided that there are no pieces between the capturing piece and its target, and that the square immediately behind the target in the capture direction is empty. The capturing piece must land there. Thus, the men gradually acquire the capturing power of a king in Thai Checkers as they seesaw up and down the board. There is no obligation to choose the capture sequence that maximizes the number of pieces captured. We deem this calculation a bit too demanding when a stack's range is a function of its size. Other than this, the rules are as in Brazillian Draughts/Checkers, which is like International Draughts, but on 8x8.
(game "Seesaw Draughts" (players 2) (equipment {(board (square 8)) (piece "Disc" P1 N) (piece "Disc" P2 S) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Disc1" (difference (expand (sites Bottom) steps:2) (sites Phase 1))) (place "Disc2" (difference (expand (sites Top) steps:2) (sites Phase 1)))}) (play (priority (forEach Piece "Disc" (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) Diagonal distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))}) (apply (remember Value (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to)))))))) count:(size Stack at:(from)) stack:True (then (if (can Move (move (from (last To)) (to (sites Direction from:(from) (difference Diagonal (directions Cell from:(last To) to:(last From))) distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))})))) (moveAgain) (do (forEach Site (sites (values Remembered)) (remove (site) count:(size Stack at:(site)))) next:(and (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)) (forget Value All)))))) top:True) (forEach Piece "Disc" (move Step (from) (if (is Odd (size Stack at:(from))) (directions {FL FR}) (directions {BL BR})) (to if:(is Empty (to))) stack:True (then (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)))) top:True))) (end (if (no Moves Next) (result Next Loss))))) 
In Seesaw Draughts, when a man reaches the rank farthest away in its stepping direction, its capture range is increased and it changes the direction it steps in. It can thereby promote again if it reaches the opposite rank. The mechanism is implemented like this: All men are stacks. Single pieces are stacks of size 1. Every time a man promotes a piece is added to it, so it's stack size increases by 1. The following two-fold meaning of stack size is the key idea: 1) Odd stacks step forwards and even stacks step backwards. 2) A stack of size n can capture a piece up to n steps away in a straight line provided that there are no pieces between the capturing piece and its target, and that the square immediately behind the target in the capture direction is empty. The capturing piece must land there. Thus, the men gradually acquire the capturing power of a king in Thai Checkers as they seesaw up and down the board. There is no obligation to choose the capture sequence that maximizes the number of pieces captured. We deem this calculation a bit too demanding when a stack's range is a function of its size. Other than this, the rules are as in Brazillian Draughts/Checkers, which is like International Draughts, but on 8x8.
(game "Seesaw Draughts" (players 2) (equipment {(board (square 8)) (piece "Disc" P1 N) (piece "Disc" P2 S) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Disc1" (difference (expand (sites Bottom) steps:2) (sites Phase 1))) (place "Disc2" (difference (expand (sites Top) steps:2) (sites Phase 1)))}) (play (priority (forEach Piece "Disc" (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) Diagonal distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))}) (apply (remember Value (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to)))))))) count:(size Stack at:(from)) stack:True (then (if (can Move (move (from (last To)) (to (sites Direction from:(from) (difference Diagonal (directions Cell from:(last To) to:(last From))) distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))})))) (moveAgain) (do (forEach Site (sites (values Remembered)) (remove (site) count:(size Stack at:(site)))) next:(and (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)) (forget Value All)))))) top:True) (forEach Piece "Disc" (move Step (from) (if (is Odd (size Stack at:(from))) (directions {FL FR}) (directions {BL BR})) (to if:(is Empty (to))) stack:True (then (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)))) top:True))) (end (if (no Moves Next) (result Next Loss))))) 
The board consists of 5x5 intersecting lines with diagonals. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces. No force capture, no sequence.
(game "Alquerque" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each)}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece "Counter" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))) (end (if (no Moves Next) (result Next Loss))))) 
The board consists of 5x5 intersecting lines with diagonals. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces. No force capture, sequence allowed.
(game "Alquerque" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each)}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Counter" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))))) (end (if (no Moves Next) (result Next Loss))))) 
The board consists of 5x5 intersecting lines with diagonals. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces. Force capture in sequence and huff rule.
(game "Alquerque" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each)}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (and (not (is Prev Mover)) (= (value Player Prev) 1)) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (if (is Prev Mover) (if (= (last To) (last From)) (do (set Pending (sites From (forEach Piece "Counter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)) (set Value Mover 0))))))) next:(forEach Piece "Counter" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)) (set Value Mover 0)))) (move Step (to if:(is Empty (to))) (then (set Value Mover 1)))))) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0)))) (do (set Pending (sites From (forEach Piece "Counter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)) (set Value Mover 0))))))) next:(forEach Piece "Counter" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)) (set Value Mover 0)))) (move Step (to if:(is Empty (to))) (then (set Value Mover 1))))))))) (end (if (no Moves Next) (result Next Loss))))) 
Three concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins.
(game "Bara Guti (Bihar)" (players 2) (equipment {(board (concentric {1 8 8 8}) use:Vertex) (piece "Counter" Each (or (move Hop Rotational (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Rotational (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (sites {2 3 4 5 10 11 12 13 18 19 20 21})) (place "Counter2" (sites {1 9 17 6 7 8 14 15 16 22 23 24}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins.
(game "Bara Guti (Bihar)" (players 2) (equipment {(board (concentric {1 8 8 8}) use:Vertex) (piece "Counter" Each (or (move Hop Rotational (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Rotational (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (sites {2 3 4 5 10 11 12 13 18 19 20 21})) (place "Counter2" (sites {1 9 17 6 7 8 14 15 16 22 23 24}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins.
(game "Bara Guti (Bihar)" (players 2) (equipment {(board (concentric {1 8 8 8}) use:Vertex) (piece "Counter" Each (or (move Hop Rotational (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Rotational (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (sites {2 3 4 5 10 11 12 13 18 19 20 21})) (place "Counter2" (sites {1 9 17 6 7 8 14 15 16 22 23 24}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Claim Jumpers is a 2-player strategy game It may be played: -- on a hex grid -- on a square grid -- on a square plus diagonal grid The goal is to maximize your pieces when the board is full. A new piece is placed at the beginning of each turn. Followed, if possible, by a chain of forced jumps made by a different piece, that capture by 'flipping' the jumped opponent to your own color. The board starts empty. Turns alternate starting with White. Game ends when the board is full. No passing. Maximum captures are not required, but the piece choen to capture must capture at least one, and maynot stop capturing as long as it is able to capture the next adjacent opponent's piece. Board & size: Equiversi Hexhex with edges alternating 3 and 5
(game "Claim Jumpers" (players 2) (equipment {(board (tri {3 5 3 5 3}) use:Vertex) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (is Prev Mover) (if (= 0 (size Array (values Remembered))) (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))})))))) (forEach Piece (move Hop (from if:(= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (do (forget Value All) next:(move Add (piece (id "Disc" Mover)) (to (sites Empty)) (then (if (can Move (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (moveAgain))))) (then (and (set Score Mover (count Pieces Mover)) (set Score Next (count Pieces Next)))))) (end {(if (and (or {(no Moves Next) (all Passed)}) (= (score Mover) (score Next))) (result Mover Win)) (if (and (or {(no Moves Next) (all Passed)}) (!= (score Mover) (score Next))) (byScore))}))) 
Claim Jumpers is a 2-player strategy game It may be played: -- on a hex grid -- on a square grid -- on a square plus diagonal grid The goal is to maximize your pieces when the board is full. A new piece is placed at the beginning of each turn. Followed, if possible, by a chain of forced jumps made by a different piece, that capture by 'flipping' the jumped opponent to your own color. The board starts empty. Turns alternate starting with White. Game ends when the board is full. No passing. Maximum captures are not required, but the piece choen to capture must capture at least one, and maynot stop capturing as long as it is able to capture the next adjacent opponent's piece. Board & size: Hexhex with edges alternating 4 and 5
(game "Claim Jumpers" (players 2) (equipment {(board (tri {4 5 4 5 4}) use:Vertex) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (is Prev Mover) (if (= 0 (size Array (values Remembered))) (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))})))))) (forEach Piece (move Hop (from if:(= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (do (forget Value All) next:(move Add (piece (id "Disc" Mover)) (to (sites Empty)) (then (if (can Move (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (moveAgain))))) (then (and (set Score Mover (count Pieces Mover)) (set Score Next (count Pieces Next)))))) (end {(if (and (or {(no Moves Next) (all Passed)}) (= (score Mover) (score Next))) (result Mover Win)) (if (and (or {(no Moves Next) (all Passed)}) (!= (score Mover) (score Next))) (byScore))}))) 
Claim Jumpers is a 2-player strategy game It may be played: -- on a hex grid -- on a square grid -- on a square plus diagonal grid The goal is to maximize your pieces when the board is full. A new piece is placed at the beginning of each turn. Followed, if possible, by a chain of forced jumps made by a different piece, that capture by 'flipping' the jumped opponent to your own color. The board starts empty. Turns alternate starting with White. Game ends when the board is full. No passing. Maximum captures are not required, but the piece choen to capture must capture at least one, and maynot stop capturing as long as it is able to capture the next adjacent opponent's piece. Board & size: Equiversi Hexhex with edges alternating 5 and 7
(game "Claim Jumpers" (players 2) (equipment {(board (tri {5 7 5 8 5}) use:Vertex) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (is Prev Mover) (if (= 0 (size Array (values Remembered))) (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))})))))) (forEach Piece (move Hop (from if:(= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (do (forget Value All) next:(move Add (piece (id "Disc" Mover)) (to (sites Empty)) (then (if (can Move (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (moveAgain))))) (then (and (set Score Mover (count Pieces Mover)) (set Score Next (count Pieces Next)))))) (end {(if (and (or {(no Moves Next) (all Passed)}) (= (score Mover) (score Next))) (result Mover Win)) (if (and (or {(no Moves Next) (all Passed)}) (!= (score Mover) (score Next))) (byScore))}))) 
5x5 intersecting lines with diagonals drawn in the four quadrants. Twelve pieces per player. which begin on two rows closest to the player and the two spaces in the central row on the player's right. Players alternate turns moving a piece to an empty adjacent point on the board, along the lines in a forward or sideways direction. A player may capture an opponent's piece by hopping over it to an empty space on immediately on the opposite side of it along the lines on the board. Captures are compulsory, and if the opponent realizes that the player did not make a possible capture, the opponent immediately captures the player's piece that could have captured but didn't. Regular pieces cannot capture backwards. When a piece reaches the farthest row on the opposite side of the board from where they started, it is promoted to a king, which can move and capture any distance along the lines of the board. The player who captures all of their opponent's pieces wins.
(game "Dama (Alquerque)" (players {(player N) (player S)}) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each (or (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))) (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0))) (move Slide (then (set Value Mover 1))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0))))) (forEach Piece "DoubleCounter" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))))) next:(forEach Piece)))) (end (if (no Pieces Mover) (result Mover Loss))))) 
5x5 intersecting lines with diagonals drawn in the four quadrants. Twelve pieces per player. which begin on two rows closest to the player and the two spaces in the central row on the player's right. Players alternate turns moving a piece to an empty adjacent point on the board, along the lines in a forward or sideways direction. A player may capture an opponent's piece by hopping over it to an empty space on immediately on the opposite side of it along the lines on the board. Captures are compulsory, and if the opponent realizes that the player did not make a possible capture, the opponent immediately captures the player's piece that could have captured but didn't. Regular pieces cannot capture backwards. When a piece reaches the farthest row on the opposite side of the board from where they started, it is promoted to a king, which can move and capture any distance along the lines of the board. The player who captures all of their opponent's pieces wins.
(game "Dama (Alquerque)" (players {(player N) (player S)}) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each (or (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))) (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0))) (move Slide (then (set Value Mover 1))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0))))) (forEach Piece "DoubleCounter" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))))) next:(forEach Piece)))) (end (if (no Pieces Mover) (result Mover Loss))))) 
5x5 intersecting lines with diagonals drawn in the four quadrants. Twelve pieces per player. which begin on two rows closest to the player and the two spaces in the central row on the player's right. Players alternate turns moving a piece to an empty adjacent point on the board, along the lines in a forward or sideways direction. A player may capture an opponent's piece by hopping over it to an empty space on immediately on the opposite side of it along the lines on the board. Captures are compulsory, and if the opponent realizes that the player did not make a possible capture, the opponent immediately captures the player's piece that could have captured but didn't. Regular pieces cannot capture backwards. When a piece reaches the farthest row on the opposite side of the board from where they started, it is promoted to a king, which can move and capture any distance along the lines of the board. The player who captures all of their opponent's pieces wins.
(game "Dama (Alquerque)" (players {(player N) (player S)}) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each (or (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))) (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0))) (move Slide (then (set Value Mover 1))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0))))) (forEach Piece "DoubleCounter" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))))) next:(forEach Piece)))) (end (if (no Pieces Mover) (result Mover Loss))))) 
5x5 intersecting lines, with diagonals in the four quadrants. Twelve pieces per player, arranged on the two rows closest to the player and the two spots in the central row to the player's right, leaving the central space empty. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece belonging to the opponent may be captured when a piece hops over it to an empty adjacent spot immediately on the opposite side of the piece, along the lines of the board. The player who reduces the opponent to five pieces wins.
(game "Ethiopian Capture Game" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 5) (result Next Loss))))) 
5x5 intersecting lines, with diagonals in the four quadrants. Twelve pieces per player, arranged on the two rows closest to the player and the two spots in the central row to the player's right, leaving the central space empty. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece belonging to the opponent may be captured when a piece hops over it to an empty adjacent spot immediately on the opposite side of the piece, along the lines of the board. The player who reduces the opponent to five pieces wins.
(game "Ethiopian Capture Game" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 5) (result Next Loss))))) 
5x5 intersecting lines, with diagonals in the four quadrants. Twelve pieces per player, arranged on the two rows closest to the player and the two spots in the central row to the player's right, leaving the central space empty. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece belonging to the opponent may be captured when a piece hops over it to an empty adjacent spot immediately on the opposite side of the piece, along the lines of the board. The player who reduces the opponent to five pieces wins.
(game "Ethiopian Capture Game" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 5) (result Next Loss))))) 
Players take turns moving one of their pieces to an adjacent empty point, forwards or sideways. A piece can hop over an adjacent enemy piece to an empty point immeidately beyond it, forwards or sideways, and must do so if possible. Only one hope per turn is allowed. If a piece reaches the far point of the board, it is promoted to a king which can also move and hop backwards. Win by eliminating all enemy pieces. The game is drawn if both players are reduced to a single king.
(game "Game of Solomon" (players {(player N) (player S)}) (equipment {(board (renumber (splitCrossings (add (regular Star 6) edges:{{0 5} {1 4} {2 3}}))) use:Vertex) (piece "Counter" Each) (piece "DoubleCounter" Each) (regions "Palace1" P1 (sites {"E7"})) (regions "Palace2" P2 (sites {"E1"}))}) (rules (start {(place "Counter1" (sites {"E1" "A2" "D2" "E2" "F2" "I2"})) (place "Counter2" (sites {"E7" "A6" "D6" "E6" "F6" "I6"}))}) (play (priority {(or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward} bySite:True) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (or (forEach Piece "Counter" (move Step (directions {Forwards Rightward Leftward} bySite:True) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step (to if:(is Empty (to))))))})) (end {(if (no Moves Next) (result Mover Win)) (if (and {(= 1 (count Pieces P1)) (= 1 (count Pieces P2)) (= 1 (count Pieces P1 "DoubleCounter")) (= 1 (count Pieces P2 "DoubleCounter"))}) (result Mover Draw))}))) 
Players take turns moving one of their pieces to an adjacent empty point, forwards or sideways. A piece can hop over an adjacent enemy piece to an empty point immeidately beyond it, forwards or sideways, and must do so if possible. Only one hope per turn is allowed. If a piece reaches the far point of the board, it is promoted to a king which can also move and hop backwards. Win by eliminating all enemy pieces. The game is drawn if both players are reduced to a single king.
(game "Game of Solomon" (players {(player N) (player S)}) (equipment {(board (renumber (splitCrossings (add (regular Star 6) edges:{{0 5} {1 4} {2 3}}))) use:Vertex) (piece "Counter" Each) (piece "DoubleCounter" Each) (regions "Palace1" P1 (sites {"E7"})) (regions "Palace2" P2 (sites {"E1"}))}) (rules (start {(place "Counter1" (sites {"E1" "A2" "D2" "E2" "F2" "I2"})) (place "Counter2" (sites {"E7" "A6" "D6" "E6" "F6" "I6"}))}) (play (priority {(or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward} bySite:True) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (or (forEach Piece "Counter" (move Step (directions {Forwards Rightward Leftward} bySite:True) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step (to if:(is Empty (to))))))})) (end {(if (no Moves Next) (result Mover Win)) (if (and {(= 1 (count Pieces P1)) (= 1 (count Pieces P2)) (= 1 (count Pieces P1 "DoubleCounter")) (= 1 (count Pieces P2 "DoubleCounter"))}) (result Mover Draw))}))) 
Players take turns moving one of their pieces to an adjacent empty point, forwards or sideways. A piece can hop over an adjacent enemy piece to an empty point immeidately beyond it, forwards or sideways, and must do so if possible. Only one hope per turn is allowed. If a piece reaches the far point of the board, it is promoted to a king which can also move and hop backwards. Win by eliminating all enemy pieces. The game is drawn if both players are reduced to a single king.
(game "Game of Solomon" (players {(player N) (player S)}) (equipment {(board (renumber (splitCrossings (add (regular Star 6) edges:{{0 5} {1 4} {2 3}}))) use:Vertex) (piece "Counter" Each) (piece "DoubleCounter" Each) (regions "Palace1" P1 (sites {"E7"})) (regions "Palace2" P2 (sites {"E1"}))}) (rules (start {(place "Counter1" (sites {"E1" "A2" "D2" "E2" "F2" "I2"})) (place "Counter2" (sites {"E7" "A6" "D6" "E6" "F6" "I6"}))}) (play (priority {(or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward} bySite:True) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (or (forEach Piece "Counter" (move Step (directions {Forwards Rightward Leftward} bySite:True) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step (to if:(is Empty (to))))))})) (end {(if (no Moves Next) (result Mover Win)) (if (and {(= 1 (count Pieces P1)) (= 1 (count Pieces P2)) (= 1 (count Pieces P1 "DoubleCounter")) (= 1 (count Pieces P2 "DoubleCounter"))}) (result Mover Draw))}))) 
Play begins with each player's pieces on the pieces occupying the points of one of the triangles, leaving the shared apex empty. Pieces move to the next adjacent point connected by a line. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins. The player loses when he has no piece.
(game "Lau Kata Kati" (players 2) (equipment {(board (merge (wedge 4) (shift 0 3 (rotate 180 (wedge 4)))) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:2)) (place "Counter2" (expand (sites Top) steps:2))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Play begins with each player's pieces on the pieces occupying the points of one of the triangles, leaving the shared apex empty. Pieces move to the next adjacent point connected by a line. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins. A player loses when he can not move.
(game "Lau Kata Kati" (players 2) (equipment {(board (merge (wedge 4) (shift 0 3 (rotate 180 (wedge 4)))) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:2)) (place "Counter2" (expand (sites Top) steps:2))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with each player's pieces on the pieces occupying the points of one of the triangles, leaving the shared apex empty. Pieces move to the next adjacent point connected by a line. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins. The player loses when he has no piece.
(game "Lau Kata Kati" (players 2) (equipment {(board (merge (wedge 4) (shift 0 3 (rotate 180 (wedge 4)))) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:2)) (place "Counter2" (expand (sites Top) steps:2))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Game is played on an Alquerque board with 5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move. The game is played with sixteen pieces.
(game "Mogul Putt'han" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Next Loss))))) 
Game is played on an Alquerque board with 5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move. The game is played with nineteen pieces.
(game "Mogul Putt'han" (players 2) (equipment {(board (merge {(shift 0 2 (square 5 diagonals:Alternating)) (shift -1 -1 (wedge 4)) (shift -1 6 (rotate 180 (wedge 4)))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3) (sites Row 4)})) (place "Marker2" (union {(sites Row 6) (sites Row 7) (sites Row 8) (sites Row 9) (sites Row 10)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Next Loss))))) 
Game is played on an Alquerque board with 5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move. The game is played with sixteen pieces.
(game "Mogul Putt'han" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Next Loss))))) 
Each player has 24 pieces, which are placed on the intersections of the lines and move along the lines to an adjacent intersection. Players may capture opponents' pieces by jumping them. Captures are not obligatory. Multiple captures can be made. A player wins by capturing all of the opponent's pieces.
(game "Peralikatuma" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "F4" "F6" "F7" "G7"})})) (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "D7" "C7"})}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))))) (end (if (no Moves Next) (result Next Loss))))) 
Each player has 24 pieces, which are placed on the intersections of the lines and move along the lines to an adjacent intersection. Players may capture opponents' pieces by jumping them. Captures are not obligatory. Multiple captures can be made. A player wins by capturing all of the opponent's pieces.
(game "Peralikatuma" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "F4" "F6" "F7" "G7"})})) (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "D7" "C7"})}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))))) (end (if (no Moves Next) (result Next Loss))))) 
Each player has 24 pieces, which are placed on the intersections of the lines and move along the lines to an adjacent intersection. Players may capture opponents' pieces by jumping them. Captures are not obligatory. Multiple captures can be made. A player wins by capturing all of the opponent's pieces.
(game "Peralikatuma" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "F4" "F6" "F7" "G7"})})) (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "D7" "C7"})}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))))) (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. Ten pieces per player, which begin on the two rows closes to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it along the lines of the board to an empty spot immediately on the opposite side of the opponent's piece. The player who captures all of the opponent's pieces wins. Each player has 10 pieces.
(game "Terhuchu (Small)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. Ten pieces per player, which begin on the two rows closes to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it along the lines of the board to an empty spot immediately on the opposite side of the opponent's piece. The player who captures all of the opponent's pieces wins. Each player has 8 pieces.
(game "Terhuchu (Small)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (sites Bottom) (sites {"B2" "C2" "D2"}))) (place "Marker2" (union (sites Top) (sites {"B4" "C4" "D4"})))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. Ten pieces per player, which begin on the two rows closes to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it along the lines of the board to an empty spot immediately on the opposite side of the opponent's piece. The player who captures all of the opponent's pieces wins. Each player has 10 pieces.
(game "Terhuchu (Small)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Played on a board similar to Perali Kotuma, with the addition of triangular extensions on the four corners. Play begins with nine pieces for each player. Pieces move along the lines to the next open space. Opponent's pieces can be captured by hopping over them. Within the triangular extensions, pieces may move two places at a time, in a straight line. The player to capture all of the opponent's pieces wins.
(game "Terhuchu" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3))) (shift 0.65 1.15 (scale 0.5 (rotate -45 (wedge 3)))) (shift 5.35 1.15 (scale 0.5 (rotate 45 (wedge 3)))) (shift 5.35 5.85 (scale 0.5 (rotate 135 (wedge 3)))) (shift 0.65 5.85 (scale 0.5 (rotate -135 (wedge 3))))}) use:Vertex) (piece "Marker" Each (or {(move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))) (if (not (is In (from) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"})))) (move Slide (between (exact 2) if:(and (is Empty (between)) (not (is In (between) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"}))))))))}))}) (rules (start {(place "Marker1" (sites {"H3" "F6" "G6" "H6" "I6" "J6" "L6" "H8" "I8" "J8"})) (place "Marker2" (sites {"H10" "I10" "J10" "F12" "H12" "I12" "J12" "L12" "J15"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Played on a board similar to Perali Kotuma, with the addition of triangular extensions on the four corners. Play begins with nine pieces for each player. Pieces move along the lines to the next open space. Opponent's pieces can be captured by hopping over them. Within the triangular extensions, pieces may move two places at a time, in a straight line. The player to capture all of the opponent's pieces wins.
(game "Terhuchu" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3))) (shift 0.65 1.15 (scale 0.5 (rotate -45 (wedge 3)))) (shift 5.35 1.15 (scale 0.5 (rotate 45 (wedge 3)))) (shift 5.35 5.85 (scale 0.5 (rotate 135 (wedge 3)))) (shift 0.65 5.85 (scale 0.5 (rotate -135 (wedge 3))))}) use:Vertex) (piece "Marker" Each (or {(move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))) (if (not (is In (from) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"})))) (move Slide (between (exact 2) if:(and (is Empty (between)) (not (is In (between) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"}))))))))}))}) (rules (start {(place "Marker1" (sites {"H3" "F6" "G6" "H6" "I6" "J6" "L6" "H8" "I8" "J8"})) (place "Marker2" (sites {"H10" "I10" "J10" "F12" "H12" "I12" "J12" "L12" "J15"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Played on a board similar to Perali Kotuma, with the addition of triangular extensions on the four corners. Play begins with nine pieces for each player. Pieces move along the lines to the next open space. Opponent's pieces can be captured by hopping over them. Within the triangular extensions, pieces may move two places at a time, in a straight line. The player to capture all of the opponent's pieces wins.
(game "Terhuchu" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3))) (shift 0.65 1.15 (scale 0.5 (rotate -45 (wedge 3)))) (shift 5.35 1.15 (scale 0.5 (rotate 45 (wedge 3)))) (shift 5.35 5.85 (scale 0.5 (rotate 135 (wedge 3)))) (shift 0.65 5.85 (scale 0.5 (rotate -135 (wedge 3))))}) use:Vertex) (piece "Marker" Each (or {(move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))) (if (not (is In (from) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"})))) (move Slide (between (exact 2) if:(and (is Empty (between)) (not (is In (between) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"}))))))))}))}) (rules (start {(place "Marker1" (sites {"H3" "F6" "G6" "H6" "I6" "J6" "L6" "H8" "I8" "J8"})) (place "Marker2" (sites {"H10" "I10" "J10" "F12" "H12" "I12" "J12" "L12" "J15"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines, forming a grid. Diagonals in each of the quadrants. Twelve pieces per player, which begin on the points closest to the player, and the two points to the right of the center point. Players alternate turns moving a piece to an empty adjacent point along the lines of the board. A player may hop over an adjacent opponent's pieces to an empty space immediately on the opposite side of it along the lines of the board to capture it. Multiple captures are allowed. A player wins if they capture all of their opponent's pieces, or reduces the opponent to one piece and blocks them from being able to move.
(game "Tsukkalavde" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (and (no Moves Next) (>= 1 (count Pieces Next))) (result Mover Win))))) 
5x5 intersecting lines, forming a grid. Diagonals in each of the quadrants. Twelve pieces per player, which begin on the points closest to the player, and the two points to the right of the center point. Players alternate turns moving a piece to an empty adjacent point along the lines of the board. A player may hop over an adjacent opponent's pieces to an empty space immediately on the opposite side of it along the lines of the board to capture it. Multiple captures are allowed. A player wins if they capture all of their opponent's pieces, or reduces the opponent to one piece and blocks them from being able to move.
(game "Tsukkalavde" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (and (no Moves Next) (>= 1 (count Pieces Next))) (result Mover Win))))) 
5x5 intersecting lines, forming a grid. Diagonals in each of the quadrants. Twelve pieces per player, which begin on the points closest to the player, and the two points to the right of the center point. Players alternate turns moving a piece to an empty adjacent point along the lines of the board. A player may hop over an adjacent opponent's pieces to an empty space immediately on the opposite side of it along the lines of the board to capture it. Multiple captures are allowed. A player wins if they capture all of their opponent's pieces, or reduces the opponent to one piece and blocks them from being able to move.
(game "Tsukkalavde" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (and (no Moves Next) (>= 1 (count Pieces Next))) (result Mover Win))))) 
3x8 board. The second space from the left and from the right in the center row are marked with an X. Eight pieces per player, which begin in the row closest to the player. Players alternate turns moving a piece to an empty adjacent space in an orthogonal direction. On the first move of a piece, that piece may move two spaces in one direction. A player may capture an opponent's piece in the central row by hopping over it to an empty space on the opposite side of it. The player who reduces their opponent to fewer than four pieces wins.
(game "Caturvimsatikosthakatmiki Krida" (players 2) (equipment {(board (rectangle 3 8)) (piece "Marker" Each (or {(move Hop Orthogonal (between if:(and (is Enemy (who at:(between))) (not (is In (between) (union (sites Bottom) (sites Top))))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to)))) (if (= 1 (state at:(from))) (move Slide Orthogonal (between (exact 2) if:(is Empty (between))) (then (set State at:(last To) 0))))}))}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 3) (result Next Loss))))) 
3x8 board. The second space from the left and from the right in the center row are marked with an X. Eight pieces per player, which begin in the row closest to the player. Players alternate turns moving a piece to an empty adjacent space in an orthogonal direction. On the first move of a piece, that piece may move two spaces in one direction. A player may capture an opponent's piece in the central row by hopping over it to an empty space on the opposite side of it. The player who reduces their opponent to fewer than four pieces wins.
(game "Caturvimsatikosthakatmiki Krida" (players 2) (equipment {(board (rectangle 3 8)) (piece "Marker" Each (or {(move Hop Orthogonal (between if:(and (is Enemy (who at:(between))) (not (is In (between) (union (sites Bottom) (sites Top))))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to)))) (if (= 1 (state at:(from))) (move Slide Orthogonal (between (exact 2) if:(is Empty (between))) (then (set State at:(last To) 0))))}))}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 3) (result Next Loss))))) 
3x8 board. The second space from the left and from the right in the center row are marked with an X. Eight pieces per player, which begin in the row closest to the player. Players alternate turns moving a piece to an empty adjacent space in an orthogonal direction. On the first move of a piece, that piece may move two spaces in one direction. A player may capture an opponent's piece in the central row by hopping over it to an empty space on the opposite side of it. The player who reduces their opponent to fewer than four pieces wins.
(game "Caturvimsatikosthakatmiki Krida" (players 2) (equipment {(board (rectangle 3 8)) (piece "Marker" Each (or {(move Hop Orthogonal (between if:(and (is Enemy (who at:(between))) (not (is In (between) (union (sites Bottom) (sites Top))))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to)))) (if (= 1 (state at:(from))) (move Slide Orthogonal (between (exact 2) if:(is Empty (between))) (then (set State at:(last To) 0))))}))}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 3) (result Next Loss))))) 
9x9 intersecting lines forming a square. Forty pieces per player, lined up on the intersections on the rows closest to them, and the right half of the central line. Players alternate turns moving pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to the empty spot immediately on the opposite side of it, following the lines of the board. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Challis Ghutia" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:3) (sites {"F5" "G5" "H5" "I5"}))) (place "Marker2" (union (expand (sites Top) steps:3) (sites {"A5" "B5" "C5" "D5"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
9x9 intersecting lines forming a square. Forty pieces per player, lined up on the intersections on the rows closest to them, and the right half of the central line. Players alternate turns moving pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to the empty spot immediately on the opposite side of it, following the lines of the board. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Challis Ghutia" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:3) (sites {"F5" "G5" "H5" "I5"}))) (place "Marker2" (union (expand (sites Top) steps:3) (sites {"A5" "B5" "C5" "D5"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
9x9 intersecting lines forming a square. Forty pieces per player, lined up on the intersections on the rows closest to them, and the right half of the central line. Players alternate turns moving pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to the empty spot immediately on the opposite side of it, following the lines of the board. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Challis Ghutia" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:3) (sites {"F5" "G5" "H5" "I5"}))) (place "Marker2" (union (expand (sites Top) steps:3) (sites {"A5" "B5" "C5" "D5"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Five rows of five holes. Each player has twelve sticks; one player's sticks are longer than the other player's. Players alternate turns placing one of their sticks in an empty hole on the board. A player may, on their turn, move a stick to an empty adjacent hole in an orthogonal direction instead of placing a stick. Players do not have to place all of their sticks before moving, but if they wish to place a stick after they have already moved, the opponent must also place a stick on their following turn. A player captures an opponent's stick by hopping over it in an orthogonal direction to an empty hole immediately on the opposite side of the opponent's stick. The player who captures all of the opponent's pieces wins.
(game "Choko" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each) (regions "AllSites" (sites Board))}) (rules (start (place "Stick" "Hand" count:12)) (play (if (is Pending) (move (from (handSite Mover)) (to (sites Empty))) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (set Pending)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
Five rows of five holes. Each player has twelve sticks; one player's sticks are longer than the other player's. Players alternate turns placing one of their sticks in an empty hole on the board. A player may, on their turn, move a stick to an empty adjacent hole in an orthogonal direction instead of placing a stick. Players do not have to place all of their sticks before moving, but if they wish to place a stick after they have already moved, the opponent must also place a stick on their following turn. A player captures an opponent's stick by hopping over it in an orthogonal direction to an empty hole immediately on the opposite side of the opponent's stick. The player who captures all of the opponent's pieces wins.
(game "Choko" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each) (regions "AllSites" (sites Board))}) (rules (start (place "Stick" "Hand" count:12)) (play (if (is Pending) (move (from (handSite Mover)) (to (sites Empty))) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (set Pending)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
Five rows of five holes. Each player has twelve sticks; one player's sticks are longer than the other player's. Players alternate turns placing one of their sticks in an empty hole on the board. A player may, on their turn, move a stick to an empty adjacent hole in an orthogonal direction instead of placing a stick. Players do not have to place all of their sticks before moving, but if they wish to place a stick after they have already moved, the opponent must also place a stick on their following turn. A player captures an opponent's stick by hopping over it in an orthogonal direction to an empty hole immediately on the opposite side of the opponent's stick. The player who captures all of the opponent's pieces wins.
(game "Choko" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each) (regions "AllSites" (sites Board))}) (rules (start (place "Stick" "Hand" count:12)) (play (if (is Pending) (move (from (handSite Mover)) (to (sites Empty))) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (set Pending)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. In a situation where two pieces are able to make the maximum number of captures and one of them is a king, the king must make the captures. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move.
(game "Dama (Kenya)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))))})) (or (forEach Piece "Counter" (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Orthogonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. In a situation where two pieces are able to make the maximum number of captures and one of them is a king, the king must make the captures. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move.
(game "Dama (Kenya)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))))})) (or (forEach Piece "Counter" (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Orthogonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. In a situation where two pieces are able to make the maximum number of captures and one of them is a king, the king must make the captures. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move.
(game "Dama (Kenya)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))))})) (or (forEach Piece "Counter" (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Orthogonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Each player, on their first five turns, uses some of their own pieces to create one King and three Generals, in any preferred order. A General is made by placing any single piece on top of an orthogonally adjacent piece, and a King is made by placing any single piece on top of an orthogonally adjacent General. - Soldiers move orthogonally one step to an adjacent square. - Generals move any distance in a straight line orthogonally, like a Chess Rook. - The King moves one step to any adjacent square, like a Chess King Capture is compulsory if possible. - A Soldier or King captures by jumping over an enemy piece occupying a square to which it can legally move and landing on the square immediately beyond it in the same direction, provided that the landing square is vacant. - A General captures in the same way, but may move any number of vacant squares before the captured piece, and may land on any successive vacant square in line of travel beyond the captured piece. If the capturing piece can then make another capture, it must, and it must continue doing so until all possible consecutive captures have been made. An enemy piece can only be jumped once in a single turn. If it is reached a second time it forms a block and ends the turn. At the end of a capturing turn all captured pieces must be removed from the board before the next player moves. If more than one capture is possible you must choose that which captures the greatest number of pieces, counting a King as three, a General as two, and a Soldier as one. If two possible capturing moves offer an equal number of pieces, you may freely choose between them. If one or more of your Generals is captured in one turn, you may create just one General (not more) from two orthogonally adjacent Soldiers anywhere on the board. If your King is captured you must, if possible, use your next turn to create another King by placing a Soldier on top of an adjacent General. If you are unable to create another King, when your King is captured, you lose the game. The game is played on a 9x9 square board.
(game "Fenix" (players 2) (equipment {(board (square 9)) (piece "Fenix" Each)}) (rules (start {(place "Fenix1" (expand (intersection (sites Bottom) (sites Right)) steps:6 Orthogonal) value:1) (place "Fenix2" (expand (intersection (sites Top) (sites Left)) steps:6 Orthogonal) value:1)}) phases:{(phase "Setup" (play (move (from (sites Occupied by:Mover) if:(= 1 (size Stack at:(from)))) (to (sites Around (from) Own Orthogonal) if:(and {(!= (from) (to)) (< (size Stack at:(to)) 3) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) True (< (size Stack at:(to)) 2)) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) True (not (= 1 (size Stack at:(to)))))})))) (nextPhase Mover (and (not (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site))))) (not (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))))) "Play")) (phase "Play" (play (if (is Prev Mover) (max Moves withValue:True (if (= 1 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(last To))) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))))) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (forEach Piece (if (= 1 (size Stack at:(from))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 2 (size Stack at:(to))))) stack:True))) (priority {(max Moves withValue:True (forEach Piece (if (= 1 (size Stack at:(from))) (move Hop (from (from)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(from))) (move Hop (from (from)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(from))) (move Hop (from) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))))) (forEach Piece (if (= 1 (size Stack at:(from))) (or (move Step Orthogonal (to if:(is Empty (to))) stack:True) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 1 (size Stack at:(to))))) stack:True))) (if (= 2 (size Stack at:(from))) (move Slide Orthogonal stack:True) (if (= 3 (size Stack at:(from))) (move Step (to if:(is Empty (to))) stack:True)))))})))) (end (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (result Mover Loss))))})) 
Each player, on their first five turns, uses some of their own pieces to create one King and three Generals, in any preferred order. A General is made by placing any single piece on top of an orthogonally adjacent piece, and a King is made by placing any single piece on top of an orthogonally adjacent General. - Soldiers move orthogonally one step to an adjacent square. - Generals move any distance in a straight line orthogonally, like a Chess Rook. - The King moves one step to any adjacent square, like a Chess King Capture is compulsory if possible. - A Soldier or King captures by jumping over an enemy piece occupying a square to which it can legally move and landing on the square immediately beyond it in the same direction, provided that the landing square is vacant. - A General captures in the same way, but may move any number of vacant squares before the captured piece, and may land on any successive vacant square in line of travel beyond the captured piece. If the capturing piece can then make another capture, it must, and it must continue doing so until all possible consecutive captures have been made. An enemy piece can only be jumped once in a single turn. If it is reached a second time it forms a block and ends the turn. At the end of a capturing turn all captured pieces must be removed from the board before the next player moves. If more than one capture is possible you must choose that which captures the greatest number of pieces, counting a King as three, a General as two, and a Soldier as one. If two possible capturing moves offer an equal number of pieces, you may freely choose between them. If one or more of your Generals is captured in one turn, you may create just one General (not more) from two orthogonally adjacent Soldiers anywhere on the board. If your King is captured you must, if possible, use your next turn to create another King by placing a Soldier on top of an adjacent General. If you are unable to create another King, when your King is captured, you lose the game. The game is played on a 7x8 square board.
(game "Fenix" (players 2) (equipment {(board (rectangle 7 8)) (piece "Fenix" Each)}) (rules (start {(place "Fenix1" (expand (intersection (sites Bottom) (sites Right)) steps:5 Orthogonal) value:1) (place "Fenix2" (expand (intersection (sites Top) (sites Left)) steps:5 Orthogonal) value:1)}) phases:{(phase "Setup" (play (move (from (sites Occupied by:Mover) if:(= 1 (size Stack at:(from)))) (to (sites Around (from) Own Orthogonal) if:(and {(!= (from) (to)) (< (size Stack at:(to)) 3) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) True (< (size Stack at:(to)) 2)) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) True (not (= 1 (size Stack at:(to)))))})))) (nextPhase Mover (and (not (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site))))) (not (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))))) "Play")) (phase "Play" (play (if (is Prev Mover) (max Moves withValue:True (if (= 1 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(last To))) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))))) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (forEach Piece (if (= 1 (size Stack at:(from))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 2 (size Stack at:(to))))) stack:True))) (priority {(max Moves withValue:True (forEach Piece (if (= 1 (size Stack at:(from))) (move Hop (from (from)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(from))) (move Hop (from (from)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(from))) (move Hop (from) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))))) (forEach Piece (if (= 1 (size Stack at:(from))) (or (move Step Orthogonal (to if:(is Empty (to))) stack:True) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 1 (size Stack at:(to))))) stack:True))) (if (= 2 (size Stack at:(from))) (move Slide Orthogonal stack:True) (if (= 3 (size Stack at:(from))) (move Step (to if:(is Empty (to))) stack:True)))))})))) (end (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (result Mover Loss))))})) 
Each player, on their first five turns, uses some of their own pieces to create one King and three Generals, in any preferred order. A General is made by placing any single piece on top of an orthogonally adjacent piece, and a King is made by placing any single piece on top of an orthogonally adjacent General. - Soldiers move orthogonally one step to an adjacent square. - Generals move any distance in a straight line orthogonally, like a Chess Rook. - The King moves one step to any adjacent square, like a Chess King Capture is compulsory if possible. - A Soldier or King captures by jumping over an enemy piece occupying a square to which it can legally move and landing on the square immediately beyond it in the same direction, provided that the landing square is vacant. - A General captures in the same way, but may move any number of vacant squares before the captured piece, and may land on any successive vacant square in line of travel beyond the captured piece. If the capturing piece can then make another capture, it must, and it must continue doing so until all possible consecutive captures have been made. An enemy piece can only be jumped once in a single turn. If it is reached a second time it forms a block and ends the turn. At the end of a capturing turn all captured pieces must be removed from the board before the next player moves. If more than one capture is possible you must choose that which captures the greatest number of pieces, counting a King as three, a General as two, and a Soldier as one. If two possible capturing moves offer an equal number of pieces, you may freely choose between them. If one or more of your Generals is captured in one turn, you may create just one General (not more) from two orthogonally adjacent Soldiers anywhere on the board. If your King is captured you must, if possible, use your next turn to create another King by placing a Soldier on top of an adjacent General. If you are unable to create another King, when your King is captured, you lose the game. The game is played on a 9x9 square board.
(game "Fenix" (players 2) (equipment {(board (square 9)) (piece "Fenix" Each)}) (rules (start {(place "Fenix1" (expand (intersection (sites Bottom) (sites Right)) steps:6 Orthogonal) value:1) (place "Fenix2" (expand (intersection (sites Top) (sites Left)) steps:6 Orthogonal) value:1)}) phases:{(phase "Setup" (play (move (from (sites Occupied by:Mover) if:(= 1 (size Stack at:(from)))) (to (sites Around (from) Own Orthogonal) if:(and {(!= (from) (to)) (< (size Stack at:(to)) 3) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) True (< (size Stack at:(to)) 2)) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) True (not (= 1 (size Stack at:(to)))))})))) (nextPhase Mover (and (not (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site))))) (not (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))))) "Play")) (phase "Play" (play (if (is Prev Mover) (max Moves withValue:True (if (= 1 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(last To))) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))))) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (forEach Piece (if (= 1 (size Stack at:(from))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 2 (size Stack at:(to))))) stack:True))) (priority {(max Moves withValue:True (forEach Piece (if (= 1 (size Stack at:(from))) (move Hop (from (from)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(from))) (move Hop (from (from)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(from))) (move Hop (from) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))))) (forEach Piece (if (= 1 (size Stack at:(from))) (or (move Step Orthogonal (to if:(is Empty (to))) stack:True) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 1 (size Stack at:(to))))) stack:True))) (if (= 2 (size Stack at:(from))) (move Slide Orthogonal stack:True) (if (= 3 (size Stack at:(from))) (move Step (to if:(is Empty (to))) stack:True)))))})))) (end (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (result Mover Loss))))})) 
TURNS - At each turn, each player must move one of his stones (called Kangaroos): - A stone must jump over one (orthogonal or diagonal) adjacent stone landing on the immediate next empty cell. - If the jumped enemy stones are captured and removed from the board. - Jumps can be multiple but are not mandatory. GOAL - The game ends when one player cannot move. The winner is the one with more stones.
(game "Kanguruh" (players 2) (equipment {(board (square 8)) (piece "Kangaroo" Each (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to)) (apply (and {(if (is Enemy (who at:(between))) (remove (between))) (remember Value (from)) (remember Value (to))}))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All)))))}) (rules (start {(place "Kangaroo1" (expand (sites Bottom))) (place "Kangaroo2" (expand (sites Top)))}) (play (if (is Prev Mover) (or (move Pass (then (forget Value All))) (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered)))) (apply (and (if (is Enemy (who at:(between))) (remove (between))) (remember Value (to))))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All))))) (forEach Piece))) (end (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
TURNS - At each turn, each player must move one of his stones (called Kangaroos): - A stone must jump over one (orthogonal or diagonal) adjacent stone landing on the immediate next empty cell. - If the jumped enemy stones are captured and removed from the board. - Jumps can be multiple but are not mandatory. GOAL - The game ends when one player cannot move. The winner is the one with more stones.
(game "Kanguruh" (players 2) (equipment {(board (square 8)) (piece "Kangaroo" Each (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to)) (apply (and {(if (is Enemy (who at:(between))) (remove (between))) (remember Value (from)) (remember Value (to))}))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All)))))}) (rules (start {(place "Kangaroo1" (expand (sites Bottom))) (place "Kangaroo2" (expand (sites Top)))}) (play (if (is Prev Mover) (or (move Pass (then (forget Value All))) (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered)))) (apply (and (if (is Enemy (who at:(between))) (remove (between))) (remember Value (to))))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All))))) (forEach Piece))) (end (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
TURNS - At each turn, each player must move one of his stones (called Kangaroos): - A stone must jump over one (orthogonal or diagonal) adjacent stone landing on the immediate next empty cell. - If the jumped enemy stones are captured and removed from the board. - Jumps can be multiple but are not mandatory. GOAL - The game ends when one player cannot move. The winner is the one with more stones.
(game "Kanguruh" (players 2) (equipment {(board (square 8)) (piece "Kangaroo" Each (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to)) (apply (and {(if (is Enemy (who at:(between))) (remove (between))) (remember Value (from)) (remember Value (to))}))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All)))))}) (rules (start {(place "Kangaroo1" (expand (sites Bottom))) (place "Kangaroo2" (expand (sites Top)))}) (play (if (is Prev Mover) (or (move Pass (then (forget Value All))) (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered)))) (apply (and (if (is Enemy (who at:(between))) (remove (between))) (remember Value (to))))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All))))) (forEach Piece))) (end (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 10x10 board.
(game "Konane" (players 2) (equipment {(board (square 10)) (piece "Marker" Each)}) (rules (start {(place "Marker1" (sites Phase 1)) (place "Marker2" (sites Phase 0))}) phases:{(phase "OpeningP1" P1 (play (move Remove (intersection (union (sites Corners) (sites Centre)) (sites Phase 1)))) (nextPhase Mover "Movement")) (phase "OpeningP2" P2 (play (move Remove (sites Around (last To) Own))) (nextPhase Mover "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (move Hop (from (from)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))} (end (if (no Moves Next) (result Next Loss))))) 
10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 6x6 board.
(game "Konane" (players 2) (equipment {(board (square 6)) (piece "Marker" Each)}) (rules (start {(place "Marker1" (sites Phase 1)) (place "Marker2" (sites Phase 0))}) phases:{(phase "OpeningP1" P1 (play (move Remove (intersection (union (sites Corners) (sites Centre)) (sites Phase 1)))) (nextPhase Mover "Movement")) (phase "OpeningP2" P2 (play (move Remove (sites Around (last To) Own))) (nextPhase Mover "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (move Hop (from (from)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))} (end (if (no Moves Next) (result Next Loss))))) 
10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 8x8 board.
(game "Konane" (players 2) (equipment {(board (square 8)) (piece "Marker" Each)}) (rules (start {(place "Marker1" (sites Phase 1)) (place "Marker2" (sites Phase 0))}) phases:{(phase "OpeningP1" P1 (play (move Remove (intersection (union (sites Corners) (sites Centre)) (sites Phase 1)))) (nextPhase Mover "Movement")) (phase "OpeningP2" P2 (play (move Remove (sites Around (last To) Own))) (nextPhase Mover "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (move Hop (from (from)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))} (end (if (no Moves Next) (result Next Loss))))) 
Played on a board with two rows of five spaces forming an "X," with an extra space diagonally adjacent to the central space. Ten sticks per player. Each player begins with one stick in each of the rightmost four spaces on the edge of the board closest to them. Players alternate turns moving a stick to an adjacent space. A player may capture one of the opponent's sticks by jumping over it to an empty space beyond it. The opponent replaces the captured stick with one of those remaining in their reserve, until there are no sticks remaining. The player who captures all of the opponent's sticks wins.
(game "Queah Game" (players 2) (equipment {(board (rotate 45 (merge (shift 1 -1 (rectangle 5 1)) (merge (shift -1 1 (rectangle 1 5)) (square 3))))) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each)}) (rules (start {(place "Stick1" {"A1" "B2" "A3" "B4"}) (place "Stick2" {"E5" "D4" "E3" "D2"}) (place "Stick" "Hand" count:6)}) (play (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (< (count Sites in:(sites Occupied by:Mover container:"Board")) 4)) (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain))) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Played on a board with two rows of five spaces forming an "X," with an extra space diagonally adjacent to the central space. Ten sticks per player. Each player begins with one stick in each of the rightmost four spaces on the edge of the board closest to them. Players alternate turns moving a stick to an adjacent space. A player may capture one of the opponent's sticks by jumping over it to an empty space beyond it. The opponent replaces the captured stick with one of those remaining in their reserve, until there are no sticks remaining. The player who captures all of the opponent's sticks wins.
(game "Queah Game" (players 2) (equipment {(board (rotate 45 (merge (shift 1 -1 (rectangle 5 1)) (merge (shift -1 1 (rectangle 1 5)) (square 3))))) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each)}) (rules (start {(place "Stick1" {"A1" "B2" "A3" "B4"}) (place "Stick2" {"E5" "D4" "E3" "D2"}) (place "Stick" "Hand" count:6)}) (play (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (< (count Sites in:(sites Occupied by:Mover container:"Board")) 4)) (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain))) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Played on a board with two rows of five spaces forming an "X," with an extra space diagonally adjacent to the central space. Ten sticks per player. Each player begins with one stick in each of the rightmost four spaces on the edge of the board closest to them. Players alternate turns moving a stick to an adjacent space. A player may capture one of the opponent's sticks by jumping over it to an empty space beyond it. The opponent replaces the captured stick with one of those remaining in their reserve, until there are no sticks remaining. The player who captures all of the opponent's sticks wins.
(game "Queah Game" (players 2) (equipment {(board (rotate 45 (merge (shift 1 -1 (rectangle 5 1)) (merge (shift -1 1 (rectangle 1 5)) (square 3))))) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each)}) (rules (start {(place "Stick1" {"A1" "B2" "A3" "B4"}) (place "Stick2" {"E5" "D4" "E3" "D2"}) (place "Stick" "Hand" count:6)}) (play (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (< (count Sites in:(sites Occupied by:Mover container:"Board")) 4)) (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain))) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Overview: In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on. The central idea of Seesaw is the 2-fold significance of stack-size: (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size. This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other. How to play: On your turn, you must either make a stack-move, or place a new stack. 1. Placing a new stack: A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color. 2. Stackmoves: You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size. The number of steps a stack may take is the number of pieces in it, i.e. its size. 2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions. 2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again. 3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn. The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game. A base 4 board is currently selected
(game "Seesaw" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex 4))) (piece "Disc" Each) (tile "Hex" Each)}) (rules (start {(place Stack "Hex1" 0) (place Stack "Disc1" 0) (place Stack "Hex2" (* 4 (* 3 (- 4 1)))) (place Stack "Disc2" (* 4 (* 3 (- 4 1))))}) (play (if (can Move (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True)) (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (set Var (- (var) (count Steps (step (to if:(or (= (last To) (to)) (= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))))) (last From) (last To))) (then (if (< 0 (var)) (moveAgain) (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (if (< 0 (count MovesThisTurn)) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True) (move Pass) (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (move Add (piece (id "Hex" Mover)) (to (sites Around (sites Occupied by:Mover component:"Hex" top:False)) if:(is Empty (to))) (then (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (end (if (= 0 (count Sites in:(sites Occupied by:Next component:"Disc"))) (result Next Loss))))) 
Overview: In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on. The central idea of Seesaw is the 2-fold significance of stack-size: (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size. This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other. How to play: On your turn, you must either make a stack-move, or place a new stack. 1. Placing a new stack: A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color. 2. Stackmoves: You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size. The number of steps a stack may take is the number of pieces in it, i.e. its size. 2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions. 2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again. 3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn. The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game. A base 5 board is currently selected
(game "Seesaw" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex 5))) (piece "Disc" Each) (tile "Hex" Each)}) (rules (start {(place Stack "Hex1" 0) (place Stack "Disc1" 0) (place Stack "Hex2" (* 5 (* 3 (- 5 1)))) (place Stack "Disc2" (* 5 (* 3 (- 5 1))))}) (play (if (can Move (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True)) (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (set Var (- (var) (count Steps (step (to if:(or (= (last To) (to)) (= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))))) (last From) (last To))) (then (if (< 0 (var)) (moveAgain) (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (if (< 0 (count MovesThisTurn)) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True) (move Pass) (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (move Add (piece (id "Hex" Mover)) (to (sites Around (sites Occupied by:Mover component:"Hex" top:False)) if:(is Empty (to))) (then (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (end (if (= 0 (count Sites in:(sites Occupied by:Next component:"Disc"))) (result Next Loss))))) 
Overview: In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on. The central idea of Seesaw is the 2-fold significance of stack-size: (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size. This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other. How to play: On your turn, you must either make a stack-move, or place a new stack. 1. Placing a new stack: A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color. 2. Stackmoves: You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size. The number of steps a stack may take is the number of pieces in it, i.e. its size. 2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions. 2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again. 3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn. The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game. A base 4 board is currently selected
(game "Seesaw" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex 4))) (piece "Disc" Each) (tile "Hex" Each)}) (rules (start {(place Stack "Hex1" 0) (place Stack "Disc1" 0) (place Stack "Hex2" (* 4 (* 3 (- 4 1)))) (place Stack "Disc2" (* 4 (* 3 (- 4 1))))}) (play (if (can Move (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True)) (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (set Var (- (var) (count Steps (step (to if:(or (= (last To) (to)) (= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))))) (last From) (last To))) (then (if (< 0 (var)) (moveAgain) (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (if (< 0 (count MovesThisTurn)) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True) (move Pass) (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (move Add (piece (id "Hex" Mover)) (to (sites Around (sites Occupied by:Mover component:"Hex" top:False)) if:(is Empty (to))) (then (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (end (if (= 0 (count Sites in:(sites Occupied by:Next component:"Disc"))) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board, leaving the central space empty. Once all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent space in an orthogonal or diagonal direction. A player may capture an opponent's piece adjacent to one of their own by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of their opponent's pieces wins.
(game "Tides" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))))) (nextPhase Mover (is Empty (handSite Mover)) "Move")) (phase "Move" (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))})) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board, leaving the central space empty. Once all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent space in an orthogonal or diagonal direction. A player may capture an opponent's piece adjacent to one of their own by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of their opponent's pieces wins.
(game "Tides" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))))) (nextPhase Mover (is Empty (handSite Mover)) "Move")) (phase "Move" (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))})) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board, leaving the central space empty. Once all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent space in an orthogonal or diagonal direction. A player may capture an opponent's piece adjacent to one of their own by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of their opponent's pieces wins.
(game "Tides" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))))) (nextPhase Mover (is Empty (handSite Mover)) "Move")) (phase "Move" (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))})) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board or moving a piece already on the board. Pieces move one space in any orthogonal direction. A player may capture an opponent's piece by hopping over it to an empty space on the other side of it. When a capture is made in this fashion, the player chooses another piece belonging to the opponent to capture in addition. The player who captures all of the opponent's pieces wins.
(game "Yote" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) (play (if (is Prev Mover) (move Remove (sites Occupied by:Next container:"Board")) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board or moving a piece already on the board. Pieces move one space in any orthogonal direction. A player may capture an opponent's piece by hopping over it to an empty space on the other side of it. When a capture is made in this fashion, the player chooses another piece belonging to the opponent to capture in addition. The player who captures all of the opponent's pieces wins.
(game "Yote" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) (play (if (is Prev Mover) (move Remove (sites Occupied by:Next container:"Board")) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board or moving a piece already on the board. Pieces move one space in any orthogonal direction. A player may capture an opponent's piece by hopping over it to an empty space on the other side of it. When a capture is made in this fashion, the player chooses another piece belonging to the opponent to capture in addition. The player who captures all of the opponent's pieces wins.
(game "Yote" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) (play (if (is Prev Mover) (move Remove (sites Occupied by:Next container:"Board")) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Pieces begin in the rows closest to the player, and the two spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (5x5)" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Pieces begin in the rows closest to the player, and the two spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (5x5)" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Pieces begin in the rows closest to the player, and the two spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (5x5)" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
7x7 board. 24 pieces per player. Pieces begin in the rows closest to the player, and the three spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (7x7)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:2) (sites {"F4" "G4" "E4"}))) (place "Marker2" (union (expand (sites Top) steps:2) (sites {"A4" "B4" "C4"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
7x7 board. 24 pieces per player. Pieces begin in the rows closest to the player, and the three spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (7x7)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:2) (sites {"F4" "G4" "E4"}))) (place "Marker2" (union (expand (sites Top) steps:2) (sites {"A4" "B4" "C4"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
7x7 board. 24 pieces per player. Pieces begin in the rows closest to the player, and the three spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (7x7)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:2) (sites {"F4" "G4" "E4"}))) (place "Marker2" (union (expand (sites Top) steps:2) (sites {"A4" "B4" "C4"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 board. Pieces have special moves, as follows: Rátu (king), moves one square in any direction, but on the first move, if it has not been checked, may move two spaces in any direction or like a Járan; Pateh (minister), moves orthogonally or diagonally any number of spaces; Mántri (x2); move diagonally any distance; Járan (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Práhu (vessel) x2, moves orthogonally any distance; Bídak (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídak must move backward diagonally three spaces before being promoted to Pateh, unless it is in one of the corner spaces, in which case it is promoted immediately. There is no limit to the number of Patehs on the board. To castle, the Práhu moves next to the Rátu, and then at any turn in the future the Rátu may move to the space on the other side of it, provided the Rátu has not yet been checked and that the space to which it moves remains available. The Rátu cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. If the Rátu is the only piece belonging to the player on the board, that player wins.
(game "Chatur" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1)))) (if (not (= 1 (state at:(from)))) (or {(move Slide (between (exact 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E1" "D8"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))} (then (set State at:(last To) 1)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"D1" "F1" "C8" "E8"})))) (set State at:(last To) 1))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (is In (from) (sites Mover "Promotion")) (move Slide (directions {BR BL}) (between (exact 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (promote (last To) (piece "Queen") Mover))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (is In (last To) (intersection (sites Corners) (sites Mover "Promotion"))) (promote (last To) (piece "Queen") Mover)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (if (not (= 1 (state at:(where "King_noCross" Next)))) (set State at:(where "King_noCross" Next) 1)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
8x8 board. Pieces have special moves, as follows: Rátu (king), moves one square in any direction, but on the first move, if it has not been checked, may move two spaces in any direction or like a Járan; Pateh (minister), moves orthogonally or diagonally any number of spaces; Mántri (x2); move diagonally any distance; Járan (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Práhu (vessel) x2, moves orthogonally any distance; Bídak (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídak must move backward diagonally three spaces before being promoted to Pateh, unless it is in one of the corner spaces, in which case it is promoted immediately. There is no limit to the number of Patehs on the board. To castle, the Práhu moves next to the Rátu, and then at any turn in the future the Rátu may move to the space on the other side of it, provided the Rátu has not yet been checked and that the space to which it moves remains available. The Rátu cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. If the Rátu is the only piece belonging to the player on the board, that player wins.
(game "Chatur" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1)))) (if (not (= 1 (state at:(from)))) (or {(move Slide (between (exact 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E1" "D8"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))} (then (set State at:(last To) 1)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"D1" "F1" "C8" "E8"})))) (set State at:(last To) 1))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (is In (from) (sites Mover "Promotion")) (move Slide (directions {BR BL}) (between (exact 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (promote (last To) (piece "Queen") Mover))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (is In (last To) (intersection (sites Corners) (sites Mover "Promotion"))) (promote (last To) (piece "Queen") Mover)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (if (not (= 1 (state at:(where "King_noCross" Next)))) (set State at:(where "King_noCross" Next) 1)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
8x8 board. Pieces have special moves, as follows: Rátu (king), moves one square in any direction, but on the first move, if it has not been checked, may move two spaces in any direction or like a Járan; Pateh (minister), moves orthogonally or diagonally any number of spaces; Mántri (x2); move diagonally any distance; Járan (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Práhu (vessel) x2, moves orthogonally any distance; Bídak (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídak must move backward diagonally three spaces before being promoted to Pateh, unless it is in one of the corner spaces, in which case it is promoted immediately. There is no limit to the number of Patehs on the board. To castle, the Práhu moves next to the Rátu, and then at any turn in the future the Rátu may move to the space on the other side of it, provided the Rátu has not yet been checked and that the space to which it moves remains available. The Rátu cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. If the Rátu is the only piece belonging to the player on the board, that player wins.
(game "Chatur" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1)))) (if (not (= 1 (state at:(from)))) (or {(move Slide (between (exact 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E1" "D8"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))} (then (set State at:(last To) 1)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"D1" "F1" "C8" "E8"})))) (set State at:(last To) 1))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (is In (from) (sites Mover "Promotion")) (move Slide (directions {BR BL}) (between (exact 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (promote (last To) (piece "Queen") Mover))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (is In (last To) (intersection (sites Corners) (sites Mover "Promotion"))) (promote (last To) (piece "Queen") Mover)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (if (not (= 1 (state at:(where "King_noCross" Next)))) (set State at:(where "King_noCross" Next) 1)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
14x14 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Queen (x1, placed to the right of the Raja); moves orthogonally one space; Prince (placed to the left of the Minister, x1), moves orthogonally or diagonally any distance; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x14): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Chaturanga (Kridakausalya 14x14)" (players {(player N) (player S)}) (equipment {(board (square 14)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Camel" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Commoner" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Elephant1" {"A1" "N1"}) (place "Knight1" {"B1" "M1"}) (place "Bishop_noCross1" {"C1" "L1"}) (place "Rook1" {"D1" "K1"}) (place "Camel1" {"E1" "J1"}) (place "Commoner1" coord:"F1") (place "Ferz_noCross1" coord:"G1") (place "King_noCross1" coord:"H1") (place "Queen1" coord:"I1") (place "Pawn2" (sites Row 12)) (place "Elephant2" {"A14" "N14"}) (place "Knight2" {"B14" "M14"}) (place "Bishop_noCross2" {"C14" "L14"}) (place "Rook2" {"D14" "K14"}) (place "Camel2" {"E14" "J14"}) (place "Commoner2" coord:"I14") (place "Ferz_noCross2" coord:"H14") (place "King_noCross2" coord:"G14") (place "Queen2" coord:"F14")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Camel") (no Pieces Next "Commoner") (no Pieces Next "Queen")}) (result Mover Win))}))) 
14x14 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Queen (x1, placed to the right of the Raja); moves orthogonally one space; Prince (placed to the left of the Minister, x1), moves orthogonally or diagonally any distance; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x14): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Chaturanga (Kridakausalya 14x14)" (players {(player N) (player S)}) (equipment {(board (square 14)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Camel" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Commoner" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Elephant1" {"A1" "N1"}) (place "Knight1" {"B1" "M1"}) (place "Bishop_noCross1" {"C1" "L1"}) (place "Rook1" {"D1" "K1"}) (place "Camel1" {"E1" "J1"}) (place "Commoner1" coord:"F1") (place "Ferz_noCross1" coord:"G1") (place "King_noCross1" coord:"H1") (place "Queen1" coord:"I1") (place "Pawn2" (sites Row 12)) (place "Elephant2" {"A14" "N14"}) (place "Knight2" {"B14" "M14"}) (place "Bishop_noCross2" {"C14" "L14"}) (place "Rook2" {"D14" "K14"}) (place "Camel2" {"E14" "J14"}) (place "Commoner2" coord:"I14") (place "Ferz_noCross2" coord:"H14") (place "King_noCross2" coord:"G14") (place "Queen2" coord:"F14")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Camel") (no Pieces Next "Commoner") (no Pieces Next "Queen")}) (result Mover Win))}))) 
14x14 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Queen (x1, placed to the right of the Raja); moves orthogonally one space; Prince (placed to the left of the Minister, x1), moves orthogonally or diagonally any distance; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x14): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Chaturanga (Kridakausalya 14x14)" (players {(player N) (player S)}) (equipment {(board (square 14)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Camel" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Commoner" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Elephant1" {"A1" "N1"}) (place "Knight1" {"B1" "M1"}) (place "Bishop_noCross1" {"C1" "L1"}) (place "Rook1" {"D1" "K1"}) (place "Camel1" {"E1" "J1"}) (place "Commoner1" coord:"F1") (place "Ferz_noCross1" coord:"G1") (place "King_noCross1" coord:"H1") (place "Queen1" coord:"I1") (place "Pawn2" (sites Row 12)) (place "Elephant2" {"A14" "N14"}) (place "Knight2" {"B14" "M14"}) (place "Bishop_noCross2" {"C14" "L14"}) (place "Rook2" {"D14" "K14"}) (place "Camel2" {"E14" "J14"}) (place "Commoner2" coord:"I14") (place "Ferz_noCross2" coord:"H14") (place "King_noCross2" coord:"G14") (place "Queen2" coord:"F14")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Camel") (no Pieces Next "Commoner") (no Pieces Next "Queen")}) (result Mover Win))}))) 
8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Gaja-Ratha-Ashva-Mantri-Raja-Ashva-Ratha-Gaja, with the eight Bhata lined up in the row in front of these. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. When a Raja can be captured by an opponent's piece on the next turn, it is in check. The Raja must not be in check at the end of the player's turn. When this is unavoidable, it is checkmate and the opponent wins. A Raja that is stalemated wins. A player who reduces their opponent to only the Raja wins.
(game "Chaturanga (al-Adli)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" (move Hop Orthogonal (between (exact 1) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Queen" (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Elephant1" {"A1" "H1"}) (place "Rook1" {"B1" "G1"}) (place "Knight1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Elephant2" {"A8" "H8"}) (place "Rook2" {"B8" "G8"}) (place "Knight2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Gaja-Ratha-Ashva-Mantri-Raja-Ashva-Ratha-Gaja, with the eight Bhata lined up in the row in front of these. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. When a Raja can be captured by an opponent's piece on the next turn, it is in check. The Raja must not be in check at the end of the player's turn. When this is unavoidable, it is checkmate and the opponent wins. A Raja that is stalemated wins. A player who reduces their opponent to only the Raja wins.
(game "Chaturanga (al-Adli)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" (move Hop Orthogonal (between (exact 1) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Queen" (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Elephant1" {"A1" "H1"}) (place "Rook1" {"B1" "G1"}) (place "Knight1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Elephant2" {"A8" "H8"}) (place "Rook2" {"B8" "G8"}) (place "Knight2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Gaja-Ratha-Ashva-Mantri-Raja-Ashva-Ratha-Gaja, with the eight Bhata lined up in the row in front of these. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. When a Raja can be captured by an opponent's piece on the next turn, it is in check. The Raja must not be in check at the end of the player's turn. When this is unavoidable, it is checkmate and the opponent wins. A Raja that is stalemated wins. A player who reduces their opponent to only the Raja wins.
(game "Chaturanga (al-Adli)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" (move Hop Orthogonal (between (exact 1) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Queen" (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Elephant1" {"A1" "H1"}) (place "Rook1" {"B1" "G1"}) (place "Knight1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Elephant2" {"A8" "H8"}) (place "Rook2" {"B8" "G8"}) (place "Knight2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward and capture one space forward diagonally; Elephant (or Chariot or Boat) (x2): can move any number of spaces orthogonally; Elephant (or Camel) (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from check. If the opponent cannot, it is checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja and pawns, it is declared a half-win, or Burd. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. If check is given 70 times in succession, the game is a draw.
(game "Hindustani Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Horse")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (= (column of:(to)) 3) (= (column of:(to)) 4)) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (not (is Friend (who at:(to))))) (apply (remove (to)))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Corners)) (promote (last To) (piece (id "Boat" Mover))) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (promote (last To) (piece (id "Horse" Mover))) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (promote (last To) (piece (id "Elephant" Mover))) (if (or (= (column of:(last To)) 3) (= (column of:(last To)) 4)) (promote (last To) (piece (id "Queen" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (and (not (is Threatened (id "King_noCross" Mover))) (= (state at:(from)) 1)) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Horse" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"}) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"}) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (not (no Moves Next)) (not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Draw)) (if (= (count Pieces Next) (+ 1 (count Sites in:(sites Occupied by:Next component:"Pawn")))) (result Mover Draw))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward and capture one space forward diagonally; Elephant (or Chariot or Boat) (x2): can move any number of spaces orthogonally; Elephant (or Camel) (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from check. If the opponent cannot, it is checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja and pawns, it is declared a half-win, or Burd. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. If check is given 70 times in succession, the game is a draw.
(game "Hindustani Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Horse")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (= (column of:(to)) 3) (= (column of:(to)) 4)) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (not (is Friend (who at:(to))))) (apply (remove (to)))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Corners)) (promote (last To) (piece (id "Boat" Mover))) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (promote (last To) (piece (id "Horse" Mover))) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (promote (last To) (piece (id "Elephant" Mover))) (if (or (= (column of:(last To)) 3) (= (column of:(last To)) 4)) (promote (last To) (piece (id "Queen" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (and (not (is Threatened (id "King_noCross" Mover))) (= (state at:(from)) 1)) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Horse" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"}) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"}) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (not (no Moves Next)) (not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Draw)) (if (= (count Pieces Next) (+ 1 (count Sites in:(sites Occupied by:Next component:"Pawn")))) (result Mover Draw))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward and capture one space forward diagonally; Elephant (or Chariot or Boat) (x2): can move any number of spaces orthogonally; Elephant (or Camel) (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from check. If the opponent cannot, it is checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja and pawns, it is declared a half-win, or Burd. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. If check is given 70 times in succession, the game is a draw.
(game "Hindustani Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Horse")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (= (column of:(to)) 3) (= (column of:(to)) 4)) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (not (is Friend (who at:(to))))) (apply (remove (to)))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Corners)) (promote (last To) (piece (id "Boat" Mover))) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (promote (last To) (piece (id "Horse" Mover))) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (promote (last To) (piece (id "Elephant" Mover))) (if (or (= (column of:(last To)) 3) (= (column of:(last To)) 4)) (promote (last To) (piece (id "Queen" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (and (not (is Threatened (id "King_noCross" Mover))) (= (state at:(from)) 1)) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Horse" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"}) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"}) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (not (no Moves Next)) (not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Draw)) (if (= (count Pieces Next) (+ 1 (count Sites in:(sites Occupied by:Next component:"Pawn")))) (result Mover Draw))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward, or one space diagonally to capture. The pawns in front of the Raja, Vizier, or Chariot may move two spaces on their first move, but only if the piece which began on the space behind them remains on that spot. Chariot (or Boat): any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse once in the game, if it has not yet been checked. It cannot take a piece with this move. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a Pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When promoted to a Horse, the piece may immediately make a Horse's move. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from Check. If the opponent cannot, it is Checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja, it is a draw, or Boorj. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. Perpetual check is not allowed, a player must make another move if such a state is entered.
(game "Parsi Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (if (= 1 (state at:(ahead (from) Backward))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))) (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Empty (to))))) (move Step (directions {FR FL}) (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Enemy (who at:(to)))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (if (is In (last To) (sites Corners)) (id "Boat" Mover) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (id "Knight" Mover) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (id "Elephant" Mover) (if (or (and (is Mover P2) (= (column of:(last To)) 4)) (and (is Mover P1) (= (column of:(last To)) 3))) (id "Ferz_noCross" Mover) (id "King_noCross" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8" state:1) (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (can Move (forEach Piece Next)) (not (is Threatened (id "King_noCross" Mover)))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= 1 (count Pieces Next)) (result Mover Draw))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward, or one space diagonally to capture. The pawns in front of the Raja, Vizier, or Chariot may move two spaces on their first move, but only if the piece which began on the space behind them remains on that spot. Chariot (or Boat): any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse once in the game, if it has not yet been checked. It cannot take a piece with this move. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a Pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When promoted to a Horse, the piece may immediately make a Horse's move. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from Check. If the opponent cannot, it is Checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja, it is a draw, or Boorj. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. Perpetual check is not allowed, a player must make another move if such a state is entered.
(game "Parsi Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (if (= 1 (state at:(ahead (from) Backward))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))) (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Empty (to))))) (move Step (directions {FR FL}) (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Enemy (who at:(to)))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (if (is In (last To) (sites Corners)) (id "Boat" Mover) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (id "Knight" Mover) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (id "Elephant" Mover) (if (or (and (is Mover P2) (= (column of:(last To)) 4)) (and (is Mover P1) (= (column of:(last To)) 3))) (id "Ferz_noCross" Mover) (id "King_noCross" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8" state:1) (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (can Move (forEach Piece Next)) (not (is Threatened (id "King_noCross" Mover)))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= 1 (count Pieces Next)) (result Mover Draw))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward, or one space diagonally to capture. The pawns in front of the Raja, Vizier, or Chariot may move two spaces on their first move, but only if the piece which began on the space behind them remains on that spot. Chariot (or Boat): any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse once in the game, if it has not yet been checked. It cannot take a piece with this move. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a Pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When promoted to a Horse, the piece may immediately make a Horse's move. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from Check. If the opponent cannot, it is Checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja, it is a draw, or Boorj. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. Perpetual check is not allowed, a player must make another move if such a state is entered.
(game "Parsi Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (if (= 1 (state at:(ahead (from) Backward))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))) (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Empty (to))))) (move Step (directions {FR FL}) (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Enemy (who at:(to)))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (if (is In (last To) (sites Corners)) (id "Boat" Mover) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (id "Knight" Mover) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (id "Elephant" Mover) (if (or (and (is Mover P2) (= (column of:(last To)) 4)) (and (is Mover P1) (= (column of:(last To)) 3))) (id "Ferz_noCross" Mover) (id "King_noCross" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8" state:1) (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (can Move (forEach Piece Next)) (not (is Threatened (id "King_noCross" Mover)))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= 1 (count Pieces Next)) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Negus (king): moves one space orthogonally or diagonally. 1 x Ferz (counselor): One square diagonally. 2 x Der (castle): Any number of spaces orthogonally. 2 x Säbä (man): Three squares diagonally, jumping over the first two. 2 x Färäs (horse): Moves as a chess knight. 8 x Médéq: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Ferz when reaching the eighth rank. No castling, except in the opening phase. In the opening phase, players play simultaneously at will, with no turn structure, until the first piece is captured, at which point turns alternate for the main phase of the game. Castling is allowed during the opening phase, and pawns may move any distance forward. If only a player's Negus remains, the opponent must checkmate it in ten moves or less, or the game is a stalemate. The player who checkmates the king wins.
(game "Santaraj" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Castle" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ferz_noCross" Each (move Hop Diagonal (between (exact 2) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Castle1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Castle2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (and (> (count Pieces P1) 1) (> (count Pieces P2) 1)) (set Counter))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and (or (= (count Pieces P1) 1) (= (count Pieces P2) 1)) (= (counter) 20)) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Negus (king): moves one space orthogonally or diagonally. 1 x Ferz (counselor): One square diagonally. 2 x Der (castle): Any number of spaces orthogonally. 2 x Säbä (man): Three squares diagonally, jumping over the first two. 2 x Färäs (horse): Moves as a chess knight. 8 x Médéq: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Ferz when reaching the eighth rank. No castling, except in the opening phase. In the opening phase, players play simultaneously at will, with no turn structure, until the first piece is captured, at which point turns alternate for the main phase of the game. Castling is allowed during the opening phase, and pawns may move any distance forward. If only a player's Negus remains, the opponent must checkmate it in ten moves or less, or the game is a stalemate. The player who checkmates the king wins.
(game "Santaraj" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Castle" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ferz_noCross" Each (move Hop Diagonal (between (exact 2) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Castle1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Castle2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (and (> (count Pieces P1) 1) (> (count Pieces P2) 1)) (set Counter))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and (or (= (count Pieces P1) 1) (= (count Pieces P2) 1)) (= (counter) 20)) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Negus (king): moves one space orthogonally or diagonally. 1 x Ferz (counselor): One square diagonally. 2 x Der (castle): Any number of spaces orthogonally. 2 x Säbä (man): Three squares diagonally, jumping over the first two. 2 x Färäs (horse): Moves as a chess knight. 8 x Médéq: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Ferz when reaching the eighth rank. No castling, except in the opening phase. In the opening phase, players play simultaneously at will, with no turn structure, until the first piece is captured, at which point turns alternate for the main phase of the game. Castling is allowed during the opening phase, and pawns may move any distance forward. If only a player's Negus remains, the opponent must checkmate it in ten moves or less, or the game is a stalemate. The player who checkmates the king wins.
(game "Santaraj" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Castle" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ferz_noCross" Each (move Hop Diagonal (between (exact 2) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Castle1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Castle2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (and (> (count Pieces P1) 1) (> (count Pieces P2) 1)) (set Counter))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and (or (= (count Pieces P1) 1) (= (count Pieces P2) 1)) (= (counter) 20)) (result Mover Draw))}))) 
8x8 checkered board. The pieces move as follows: Álix' ("old man"), x1: moves one space orthogonally or diagonally; Férsix' ("fers"), x1: moves any number of spaces orthogonally or diagonally; Lúdkax' ("boat"), x2: moves orthogonally any number of spaces; Slúnax' ("elephant"), x2: moves diagonally any number of spaces; Kúnax' ("horse"), x2: moves like a Chess knight; Layakúcan ("little boys"), x8: move forward one space, capture diagonally forward. Captures are made when a piece moves onto a space occupied by an opponent's piece. A player's Álix' is checked when it can be taken by the opponent on their next turn, and this possibility must be removed before the opponent plays. If a player's Álix' is checkmated, the opponent wins.
(game "Saxun" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" {"F4" "G4" "H4" "B3" "C3" "D3" "E3" "A2"}) (place "Pawn2" {"H7" "H6" "G6" "F6" "E6" "A5" "B5" "C5"}) (place "Rook1" {"C2" "D1"}) (place "Knight1" {"B1" "H2"}) (place "Bishop_noCross1" {"E1" "F1"}) (place "Queen1" coord:"D2") (place "King_noCross1" coord:"C1") (place "Rook2" {"C7" "B8"}) (place "Knight2" {"A7" "H8"}) (place "Bishop_noCross2" {"F7" "G7"}) (place "Queen2" coord:"B7") (place "King_noCross2" coord:"C8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 checkered board. The pieces move as follows: Álix' ("old man"), x1: moves one space orthogonally or diagonally; Férsix' ("fers"), x1: moves any number of spaces orthogonally or diagonally; Lúdkax' ("boat"), x2: moves orthogonally any number of spaces; Slúnax' ("elephant"), x2: moves diagonally any number of spaces; Kúnax' ("horse"), x2: moves like a Chess knight; Layakúcan ("little boys"), x8: move forward one space, capture diagonally forward. Captures are made when a piece moves onto a space occupied by an opponent's piece. A player's Álix' is checked when it can be taken by the opponent on their next turn, and this possibility must be removed before the opponent plays. If a player's Álix' is checkmated, the opponent wins.
(game "Saxun" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" {"F4" "G4" "H4" "B3" "C3" "D3" "E3" "A2"}) (place "Pawn2" {"H7" "H6" "G6" "F6" "E6" "A5" "B5" "C5"}) (place "Rook1" {"C2" "D1"}) (place "Knight1" {"B1" "H2"}) (place "Bishop_noCross1" {"E1" "F1"}) (place "Queen1" coord:"D2") (place "King_noCross1" coord:"C1") (place "Rook2" {"C7" "B8"}) (place "Knight2" {"A7" "H8"}) (place "Bishop_noCross2" {"F7" "G7"}) (place "Queen2" coord:"B7") (place "King_noCross2" coord:"C8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 checkered board. The pieces move as follows: Álix' ("old man"), x1: moves one space orthogonally or diagonally; Férsix' ("fers"), x1: moves any number of spaces orthogonally or diagonally; Lúdkax' ("boat"), x2: moves orthogonally any number of spaces; Slúnax' ("elephant"), x2: moves diagonally any number of spaces; Kúnax' ("horse"), x2: moves like a Chess knight; Layakúcan ("little boys"), x8: move forward one space, capture diagonally forward. Captures are made when a piece moves onto a space occupied by an opponent's piece. A player's Álix' is checked when it can be taken by the opponent on their next turn, and this possibility must be removed before the opponent plays. If a player's Álix' is checkmated, the opponent wins.
(game "Saxun" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" {"F4" "G4" "H4" "B3" "C3" "D3" "E3" "A2"}) (place "Pawn2" {"H7" "H6" "G6" "F6" "E6" "A5" "B5" "C5"}) (place "Rook1" {"C2" "D1"}) (place "Knight1" {"B1" "H2"}) (place "Bishop_noCross1" {"E1" "F1"}) (place "Queen1" coord:"D2") (place "King_noCross1" coord:"C1") (place "Rook2" {"C7" "B8"}) (place "Knight2" {"A7" "H8"}) (place "Bishop_noCross2" {"F7" "G7"}) (place "Queen2" coord:"B7") (place "King_noCross2" coord:"C8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
10x10 board. Pieces move as follows: Raja (x1): moves one space in any direction; Crown Prince (placed to the left of the Raja, x1): moves like any of the other pieces; Kotwal (Police Chief, placed to the right of the Raja, x1): Moves like the Elephant and the Vaha; Mantri (x1): moves any distance orthogonally or diagonally; Elephant (x2): moves diagonally any distance; Vaha (two placed in front of the Queens, x4): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Chariot (x2): moves orthogonally any distance; Queen (placed in front of the Raja and Crown Prince, x2): move one square orthogonally or diagonally; Padati (placed in the second row, except for the central two squares, x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Shataranja" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Bishop_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Bishop_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"}))) (place "Pawn2" (difference (sites Row 8) (sites {"E2" "F2"}))) (place "Queen1" {"E2" "F2"}) (place "Queen2" {"E9" "F9"}) (place "Rook1" {"A1" "J1"}) (place "Knight1" {"B1" "I1" "E3" "F3"}) (place "Elephant1" {"C1" "H1"}) (place "Ferz_noCross1" coord:"E1") (place "Commoner1" coord:"G1") (place "Bishop_noCross1" coord:"D1") (place "King_noCross1" coord:"F1") (place "Rook2" {"A10" "J10"}) (place "Knight2" {"B10" "I10" "E8" "F8"}) (place "Elephant2" {"C10" "H10"}) (place "Ferz_noCross2" coord:"F10") (place "Commoner2" coord:"D10") (place "Bishop_noCross2" coord:"G10") (place "King_noCross2" coord:"E10")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Queen") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Commoner")}) (result Mover Win))}))) 
10x10 board. Pieces move as follows: Raja (x1): moves one space in any direction; Crown Prince (placed to the left of the Raja, x1): moves like any of the other pieces; Kotwal (Police Chief, placed to the right of the Raja, x1): Moves like the Elephant and the Vaha; Mantri (x1): moves any distance orthogonally or diagonally; Elephant (x2): moves diagonally any distance; Vaha (two placed in front of the Queens, x4): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Chariot (x2): moves orthogonally any distance; Queen (placed in front of the Raja and Crown Prince, x2): move one square orthogonally or diagonally; Padati (placed in the second row, except for the central two squares, x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Shataranja" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Bishop_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Bishop_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"}))) (place "Pawn2" (difference (sites Row 8) (sites {"E2" "F2"}))) (place "Queen1" {"E2" "F2"}) (place "Queen2" {"E9" "F9"}) (place "Rook1" {"A1" "J1"}) (place "Knight1" {"B1" "I1" "E3" "F3"}) (place "Elephant1" {"C1" "H1"}) (place "Ferz_noCross1" coord:"E1") (place "Commoner1" coord:"G1") (place "Bishop_noCross1" coord:"D1") (place "King_noCross1" coord:"F1") (place "Rook2" {"A10" "J10"}) (place "Knight2" {"B10" "I10" "E8" "F8"}) (place "Elephant2" {"C10" "H10"}) (place "Ferz_noCross2" coord:"F10") (place "Commoner2" coord:"D10") (place "Bishop_noCross2" coord:"G10") (place "King_noCross2" coord:"E10")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Queen") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Commoner")}) (result Mover Win))}))) 
10x10 board. Pieces move as follows: Raja (x1): moves one space in any direction; Crown Prince (placed to the left of the Raja, x1): moves like any of the other pieces; Kotwal (Police Chief, placed to the right of the Raja, x1): Moves like the Elephant and the Vaha; Mantri (x1): moves any distance orthogonally or diagonally; Elephant (x2): moves diagonally any distance; Vaha (two placed in front of the Queens, x4): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Chariot (x2): moves orthogonally any distance; Queen (placed in front of the Raja and Crown Prince, x2): move one square orthogonally or diagonally; Padati (placed in the second row, except for the central two squares, x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Shataranja" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Bishop_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Bishop_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"}))) (place "Pawn2" (difference (sites Row 8) (sites {"E2" "F2"}))) (place "Queen1" {"E2" "F2"}) (place "Queen2" {"E9" "F9"}) (place "Rook1" {"A1" "J1"}) (place "Knight1" {"B1" "I1" "E3" "F3"}) (place "Elephant1" {"C1" "H1"}) (place "Ferz_noCross1" coord:"E1") (place "Commoner1" coord:"G1") (place "Bishop_noCross1" coord:"D1") (place "King_noCross1" coord:"F1") (place "Rook2" {"A10" "J10"}) (place "Knight2" {"B10" "I10" "E8" "F8"}) (place "Elephant2" {"C10" "H10"}) (place "Ferz_noCross2" coord:"F10") (place "Commoner2" coord:"D10") (place "Bishop_noCross2" coord:"G10") (place "King_noCross2" coord:"E10")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Queen") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Commoner")}) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. May move like an Asb if it is not in check and has never been in check. Place to a player's square right of center. 1 x Fers (counselor): Any distance orthogonally or diagonally; 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. Promoted to Fers when reaching the eighth rank. No en passant. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. The game ends in a draw only when a player's final piece, being a Sarbaz, is lost, that player's Shah captures the opponent's only remaining piece, a Sarbaz.
(game "Shatranj (Algeria)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. May move like an Asb if it is not in check and has never been in check. Place to a player's square right of center. 1 x Fers (counselor): Any distance orthogonally or diagonally; 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. Promoted to Fers when reaching the eighth rank. No en passant. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. The game ends in a draw only when a player's final piece, being a Sarbaz, is lost, that player's Shah captures the opponent's only remaining piece, a Sarbaz.
(game "Shatranj (Algeria)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. May move like an Asb if it is not in check and has never been in check. Place to a player's square right of center. 1 x Fers (counselor): Any distance orthogonally or diagonally; 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. Promoted to Fers when reaching the eighth rank. No en passant. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. The game ends in a draw only when a player's final piece, being a Sarbaz, is lost, that player's Shah captures the opponent's only remaining piece, a Sarbaz.
(game "Shatranj (Algeria)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
10x10 board, with an extra square placed diagonally behind each Rukh. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2x Dabbaba: any number of squares diagonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a Chess knight. 12 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the tenth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. If a player moves their king into one of the extra squares on the opposite side of the board, the game is a draw.
(game "Shatranj al-Husun" (players {(player N) (player S)}) (equipment {(board (merge {(square 10) (shift -1 -1 (square 1)) (shift 10 -1 (square 1)) (shift -1 10 (square 1)) (shift 10 10 (square 1))})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (regions "Promotion" P1 (sites Row 10)) (regions "Promotion" P2 (sites Row 1)) (regions "OppositeExtraSquares" P1 (sites Top)) (regions "OppositeExtraSquares" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 9)) (place "Rook1" (sites {"B2" "K2"})) (place "Knight1" (sites {"C2" "J2"})) (place "Elephant1" (sites {"D2" "I2"})) (place "Bishop1" (sites {"E2" "H2"})) (place "King1" coord:"F2") (place "Queen1" coord:"G2") (place "Rook2" (sites {"B11" "K11"})) (place "Knight2" (sites {"C11" "J11"})) (place "Elephant2" (sites {"D11" "I11"})) (place "Bishop2" (sites {"E11" "H11"})) (place "King2" coord:"F11") (place "Queen2" coord:"G11")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (is In (where "King" Mover) (sites Mover "OppositeExtraSquares")) (result Mover Draw)) (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
10x10 board, with an extra square placed diagonally behind each Rukh. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2x Dabbaba: any number of squares diagonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a Chess knight. 12 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the tenth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. If a player moves their king into one of the extra squares on the opposite side of the board, the game is a draw.
(game "Shatranj al-Husun" (players {(player N) (player S)}) (equipment {(board (merge {(square 10) (shift -1 -1 (square 1)) (shift 10 -1 (square 1)) (shift -1 10 (square 1)) (shift 10 10 (square 1))})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (regions "Promotion" P1 (sites Row 10)) (regions "Promotion" P2 (sites Row 1)) (regions "OppositeExtraSquares" P1 (sites Top)) (regions "OppositeExtraSquares" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 9)) (place "Rook1" (sites {"B2" "K2"})) (place "Knight1" (sites {"C2" "J2"})) (place "Elephant1" (sites {"D2" "I2"})) (place "Bishop1" (sites {"E2" "H2"})) (place "King1" coord:"F2") (place "Queen1" coord:"G2") (place "Rook2" (sites {"B11" "K11"})) (place "Knight2" (sites {"C11" "J11"})) (place "Elephant2" (sites {"D11" "I11"})) (place "Bishop2" (sites {"E11" "H11"})) (place "King2" coord:"F11") (place "Queen2" coord:"G11")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (is In (where "King" Mover) (sites Mover "OppositeExtraSquares")) (result Mover Draw)) (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
10x10 board, with an extra square placed diagonally behind each Rukh. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2x Dabbaba: any number of squares diagonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a Chess knight. 12 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the tenth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. If a player moves their king into one of the extra squares on the opposite side of the board, the game is a draw.
(game "Shatranj al-Husun" (players {(player N) (player S)}) (equipment {(board (merge {(square 10) (shift -1 -1 (square 1)) (shift 10 -1 (square 1)) (shift -1 10 (square 1)) (shift 10 10 (square 1))})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (regions "Promotion" P1 (sites Row 10)) (regions "Promotion" P2 (sites Row 1)) (regions "OppositeExtraSquares" P1 (sites Top)) (regions "OppositeExtraSquares" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 9)) (place "Rook1" (sites {"B2" "K2"})) (place "Knight1" (sites {"C2" "J2"})) (place "Elephant1" (sites {"D2" "I2"})) (place "Bishop1" (sites {"E2" "H2"})) (place "King1" coord:"F2") (place "Queen1" coord:"G2") (place "Rook2" (sites {"B11" "K11"})) (place "Knight2" (sites {"C11" "J11"})) (place "Elephant2" (sites {"D11" "I11"})) (place "Bishop2" (sites {"E11" "H11"})) (place "King2" coord:"F11") (place "Queen2" coord:"G11")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (is In (where "King" Mover) (sites Mover "OppositeExtraSquares")) (result Mover Draw)) (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
10x10 board. The pieces move as follows, with the number per player: 1 x Shah (king): one space orthogonally or diagonally; 1 x Fers (counselor): one square diagonally; 2 x Rukh (rook): any number of spaces orthogonally; 2x Dabbaba: one space orthogonally or diagonally; 2 x Pil (elephant): two squares diagonally, jumping over the first. Cannot capture another Pil; 2 x Asb (horse): one square orthogonally, and then one square diagonally, jumping over any intervening pieces; 10 x Sarbaz (soldier): one space forward orthogonally or one space forward diagonally to capture. No en passant. Sarbaz begins in the third rank, and is promoted to Fers when reaching the tenth rank, only if the Fers has been captured. Otherwise, the other player captures it. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins.
(game "Shatranj at-Tamma" (players {(player N) (player S)}) (equipment {(piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (= (where "Queen" Mover) -1) (promote (last To) (piece "Queen") Mover) (remove (last To))))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Wazir" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (board (square 10))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 7)) (place "Rook1" (sites {"A1" "J1"})) (place "Rook2" (sites {"A10" "J10"})) (place "Knight1" (sites {"B1" "I1"})) (place "Knight2" (sites {"B10" "I10"})) (place "Elephant1" (sites {"C1" "H1"})) (place "Elephant2" (sites {"C10" "H10"})) (place "Wazir1" (sites {"D1" "G1"})) (place "Wazir2" (sites {"D10" "G10"})) (place "Queen1" coord:"E1") (place "Queen2" coord:"F10") (place "King_noCross1" coord:"F1") (place "King_noCross2" coord:"E10")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
10x10 board. The pieces move as follows, with the number per player: 1 x Shah (king): one space orthogonally or diagonally; 1 x Fers (counselor): one square diagonally; 2 x Rukh (rook): any number of spaces orthogonally; 2x Dabbaba: one space orthogonally or diagonally; 2 x Pil (elephant): two squares diagonally, jumping over the first. Cannot capture another Pil; 2 x Asb (horse): one square orthogonally, and then one square diagonally, jumping over any intervening pieces; 10 x Sarbaz (soldier): one space forward orthogonally or one space forward diagonally to capture. No en passant. Sarbaz begins in the third rank, and is promoted to Fers when reaching the tenth rank, only if the Fers has been captured. Otherwise, the other player captures it. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins.
(game "Shatranj at-Tamma" (players {(player N) (player S)}) (equipment {(piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (= (where "Queen" Mover) -1) (promote (last To) (piece "Queen") Mover) (remove (last To))))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Wazir" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (board (square 10))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 7)) (place "Rook1" (sites {"A1" "J1"})) (place "Rook2" (sites {"A10" "J10"})) (place "Knight1" (sites {"B1" "I1"})) (place "Knight2" (sites {"B10" "I10"})) (place "Elephant1" (sites {"C1" "H1"})) (place "Elephant2" (sites {"C10" "H10"})) (place "Wazir1" (sites {"D1" "G1"})) (place "Wazir2" (sites {"D10" "G10"})) (place "Queen1" coord:"E1") (place "Queen2" coord:"F10") (place "King_noCross1" coord:"F1") (place "King_noCross2" coord:"E10")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
10x10 board. The pieces move as follows, with the number per player: 1 x Shah (king): one space orthogonally or diagonally; 1 x Fers (counselor): one square diagonally; 2 x Rukh (rook): any number of spaces orthogonally; 2x Dabbaba: one space orthogonally or diagonally; 2 x Pil (elephant): two squares diagonally, jumping over the first. Cannot capture another Pil; 2 x Asb (horse): one square orthogonally, and then one square diagonally, jumping over any intervening pieces; 10 x Sarbaz (soldier): one space forward orthogonally or one space forward diagonally to capture. No en passant. Sarbaz begins in the third rank, and is promoted to Fers when reaching the tenth rank, only if the Fers has been captured. Otherwise, the other player captures it. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins.
(game "Shatranj at-Tamma" (players {(player N) (player S)}) (equipment {(piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (= (where "Queen" Mover) -1) (promote (last To) (piece "Queen") Mover) (remove (last To))))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Wazir" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (board (square 10))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 7)) (place "Rook1" (sites {"A1" "J1"})) (place "Rook2" (sites {"A10" "J10"})) (place "Knight1" (sites {"B1" "I1"})) (place "Knight2" (sites {"B10" "I10"})) (place "Elephant1" (sites {"C1" "H1"})) (place "Elephant2" (sites {"C10" "H10"})) (place "Wazir1" (sites {"D1" "G1"})) (place "Wazir2" (sites {"D10" "G10"})) (place "Queen1" coord:"E1") (place "Queen2" coord:"F10") (place "King_noCross1" coord:"F1") (place "King_noCross2" coord:"E10")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Beirut chess follows all the rules and conventions of standard chess, with one difference: Before the game begins, each player secretly attaches a red dot to the bottom of one of their pieces (but not the king). This piece is called a bomb carrier. On any turn, instead of moving, a player may say "Boom!" and overturn their bomb carrier. All pieces of either color on squares adjacent to the bomb carrier are removed from the game, as well as the bomb carrier itself. There are two ways to win: Checkmate the opponent. Blow up the enemy king. A captured piece may not be inspected to see whether or not it was a bomb carrier.
(game "Beirut Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) phases:{(phase "Bomb" (play (forEach Site (sites Occupied by:Mover) (if (!= (what at:(site)) (id "King" Mover)) (move Select (from (site)) (then (and (set Value at:(last To) 1) (set Hidden Value at:(last To) to:Next))))))) (nextPhase Mover "Play")) (phase "Play" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (or (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (move Select (from (sites Occupied by:Mover) if:(= 1 (value Piece at:(from)))) (then (forEach Site (sites Around (last To) includeSelf:True) (if (is Occupied (site)) (remove (site))))))))))} (end {(if (or (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (= (where "King" Next) -1)) (result Mover Win)) (if (= (where "King" Mover) -1) (result Mover Loss)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Beirut chess follows all the rules and conventions of standard chess, with one difference: Before the game begins, each player secretly attaches a red dot to the bottom of one of their pieces (but not the king). This piece is called a bomb carrier. On any turn, instead of moving, a player may say "Boom!" and overturn their bomb carrier. All pieces of either color on squares adjacent to the bomb carrier are removed from the game, as well as the bomb carrier itself. There are two ways to win: Checkmate the opponent. Blow up the enemy king. A captured piece may not be inspected to see whether or not it was a bomb carrier.
(game "Beirut Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) phases:{(phase "Bomb" (play (forEach Site (sites Occupied by:Mover) (if (!= (what at:(site)) (id "King" Mover)) (move Select (from (site)) (then (and (set Value at:(last To) 1) (set Hidden Value at:(last To) to:Next))))))) (nextPhase Mover "Play")) (phase "Play" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (or (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (move Select (from (sites Occupied by:Mover) if:(= 1 (value Piece at:(from)))) (then (forEach Site (sites Around (last To) includeSelf:True) (if (is Occupied (site)) (remove (site))))))))))} (end {(if (or (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (= (where "King" Next) -1)) (result Mover Win)) (if (= (where "King" Mover) -1) (result Mover Loss)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Beirut chess follows all the rules and conventions of standard chess, with one difference: Before the game begins, each player secretly attaches a red dot to the bottom of one of their pieces (but not the king). This piece is called a bomb carrier. On any turn, instead of moving, a player may say "Boom!" and overturn their bomb carrier. All pieces of either color on squares adjacent to the bomb carrier are removed from the game, as well as the bomb carrier itself. There are two ways to win: Checkmate the opponent. Blow up the enemy king. A captured piece may not be inspected to see whether or not it was a bomb carrier.
(game "Beirut Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) phases:{(phase "Bomb" (play (forEach Site (sites Occupied by:Mover) (if (!= (what at:(site)) (id "King" Mover)) (move Select (from (site)) (then (and (set Value at:(last To) 1) (set Hidden Value at:(last To) to:Next))))))) (nextPhase Mover "Play")) (phase "Play" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (or (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (move Select (from (sites Occupied by:Mover) if:(= 1 (value Piece at:(from)))) (then (forEach Site (sites Around (last To) includeSelf:True) (if (is Occupied (site)) (remove (site))))))))))} (end {(if (or (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (= (where "King" Next) -1)) (result Mover Win)) (if (= (where "King" Mover) -1) (result Mover Loss)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
8x12 board. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Man (x1): moves one space in any direction; Fool (x1): moves orthogonally one space; Courier (x2): moves diagonally any distance; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x12): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. Each player must move the Rooks' Pawns and Queens' Pawn in this way in their first three moves. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Currierspiel" (players {(player N) (player S)}) (equipment {(board (rectangle 8 12)) (regions "StartingPawnRookQueen" P1 (sites {"A2" "G2" "L2"})) (regions "StartingPawnRookQueen" P2 (sites {"A7" "G7" "L7"})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (then (set State at:(last To) 0))))) (piece "Mann" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Fool" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Ferz" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))}))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Ferz1" {"C1" "J1"}) (place "Bishop1" {"D1" "I1"}) (place "Queen1" coord:"G1" state:1) (place "Fool1" coord:"H1") (place "Mann1" coord:"E1") (place "King1" coord:"F1") (place "Rook2" {"A8" "L8"}) (place "Knight2" {"B8" "K8"}) (place "Ferz2" {"C8" "J8"}) (place "Bishop2" {"D8" "I8"}) (place "Queen2" coord:"G8" state:1) (place "Fool2" coord:"H8") (place "Mann2" coord:"E8") (place "King2" coord:"F8")}) phases:{(phase "Opening" (play (forEach Site (intersection (sites Occupied by:Mover) (sites Mover)) (move (from (site)) (to (ahead (site) steps:2 Forward))))) (nextPhase Mover (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Mover)))) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
8x12 board. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Man (x1): moves one space in any direction; Fool (x1): moves orthogonally one space; Courier (x2): moves diagonally any distance; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x12): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. Each player must move the Rooks' Pawns and Queens' Pawn in this way in their first three moves. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Currierspiel" (players {(player N) (player S)}) (equipment {(board (rectangle 8 12)) (regions "StartingPawnRookQueen" P1 (sites {"A2" "G2" "L2"})) (regions "StartingPawnRookQueen" P2 (sites {"A7" "G7" "L7"})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (then (set State at:(last To) 0))))) (piece "Mann" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Fool" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Ferz" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))}))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Ferz1" {"C1" "J1"}) (place "Bishop1" {"D1" "I1"}) (place "Queen1" coord:"G1" state:1) (place "Fool1" coord:"H1") (place "Mann1" coord:"E1") (place "King1" coord:"F1") (place "Rook2" {"A8" "L8"}) (place "Knight2" {"B8" "K8"}) (place "Ferz2" {"C8" "J8"}) (place "Bishop2" {"D8" "I8"}) (place "Queen2" coord:"G8" state:1) (place "Fool2" coord:"H8") (place "Mann2" coord:"E8") (place "King2" coord:"F8")}) phases:{(phase "Opening" (play (forEach Site (intersection (sites Occupied by:Mover) (sites Mover)) (move (from (site)) (to (ahead (site) steps:2 Forward))))) (nextPhase Mover (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Mover)))) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
8x12 board. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Man (x1): moves one space in any direction; Fool (x1): moves orthogonally one space; Courier (x2): moves diagonally any distance; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x12): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. Each player must move the Rooks' Pawns and Queens' Pawn in this way in their first three moves. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Currierspiel" (players {(player N) (player S)}) (equipment {(board (rectangle 8 12)) (regions "StartingPawnRookQueen" P1 (sites {"A2" "G2" "L2"})) (regions "StartingPawnRookQueen" P2 (sites {"A7" "G7" "L7"})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (then (set State at:(last To) 0))))) (piece "Mann" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Fool" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Ferz" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))}))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Ferz1" {"C1" "J1"}) (place "Bishop1" {"D1" "I1"}) (place "Queen1" coord:"G1" state:1) (place "Fool1" coord:"H1") (place "Mann1" coord:"E1") (place "King1" coord:"F1") (place "Rook2" {"A8" "L8"}) (place "Knight2" {"B8" "K8"}) (place "Ferz2" {"C8" "J8"}) (place "Bishop2" {"D8" "I8"}) (place "Queen2" coord:"G8" state:1) (place "Fool2" coord:"H8") (place "Mann2" coord:"E8") (place "King2" coord:"F8")}) phases:{(phase "Opening" (play (forEach Site (intersection (sites Occupied by:Mover) (sites Mover)) (move (from (site)) (to (ahead (site) steps:2 Forward))))) (nextPhase Mover (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Mover)))) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Same rules as Chess. Dragons move like queens, but at most three squares.
(game "Dragonchess" (players {(player N) (player S)}) (equipment {(board (merge (square 10) (shift -3 3 (rectangle 4 16)))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Dragon" Each (move Slide (between (max 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "I1") (pair 2 "H10")}) (map "RookLeft" {(pair 1 "E1") (pair 2 "L10")}) (map "RookRight" {(pair 1 "L1") (pair 2 "E10")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 8)) (place "Dragon1" {"D1" "M1"}) (place "Rook1" {"E1" "L1"} state:1) (place "Knight1" {"F1" "K1"}) (place "Bishop1" {"G1" "J1"}) (place "Queen1" coord:"H1") (place "King1" coord:"I1" state:1) (place "Dragon2" {"D10" "M10"}) (place "Rook2" {"E10" "L10"} state:1) (place "Knight2" {"F10" "K10"}) (place "Bishop2" {"G10" "J10"}) (place "Queen2" coord:"I10") (place "King2" coord:"H10" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "Dragon"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Same rules as Chess. Dragons move like queens, but at most three squares.
(game "Dragonchess" (players {(player N) (player S)}) (equipment {(board (merge (square 10) (shift -3 3 (rectangle 4 16)))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Dragon" Each (move Slide (between (max 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "I1") (pair 2 "H10")}) (map "RookLeft" {(pair 1 "E1") (pair 2 "L10")}) (map "RookRight" {(pair 1 "L1") (pair 2 "E10")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 8)) (place "Dragon1" {"D1" "M1"}) (place "Rook1" {"E1" "L1"} state:1) (place "Knight1" {"F1" "K1"}) (place "Bishop1" {"G1" "J1"}) (place "Queen1" coord:"H1") (place "King1" coord:"I1" state:1) (place "Dragon2" {"D10" "M10"}) (place "Rook2" {"E10" "L10"} state:1) (place "Knight2" {"F10" "K10"}) (place "Bishop2" {"G10" "J10"}) (place "Queen2" coord:"I10") (place "King2" coord:"H10" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "Dragon"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Same rules as Chess. Dragons move like queens, but at most three squares.
(game "Dragonchess" (players {(player N) (player S)}) (equipment {(board (merge (square 10) (shift -3 3 (rectangle 4 16)))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Dragon" Each (move Slide (between (max 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "I1") (pair 2 "H10")}) (map "RookLeft" {(pair 1 "E1") (pair 2 "L10")}) (map "RookRight" {(pair 1 "L1") (pair 2 "E10")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 8)) (place "Dragon1" {"D1" "M1"}) (place "Rook1" {"E1" "L1"} state:1) (place "Knight1" {"F1" "K1"}) (place "Bishop1" {"G1" "J1"}) (place "Queen1" coord:"H1") (place "King1" coord:"I1" state:1) (place "Dragon2" {"D10" "M10"}) (place "Rook2" {"E10" "L10"} state:1) (place "Knight2" {"F10" "K10"}) (place "Bishop2" {"G10" "J10"}) (place "Queen2" coord:"I10") (place "King2" coord:"H10" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "Dragon"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
The rules are the same as for Chess with these differences: White wins by capturing all black pieces. Black wins by checkmating the white king. If no black piece can make a valid move, the game is a draw (stalemate). Black pawns can be promoted to a black queen, rook, bishop or knight if they reach the last row. Black pawns cannot move two spaces forward from any position except the second rank.
(game "Horde Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (and (= (who at:(from)) P1) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (union {(sites Row 5) (sites Row 6) (sites Row 4) (difference (sites Row 7) (sites {"D8" "E8"})) (difference (sites Row 3) (sites {"A4" "B4" "C4" "F4" "G4" "H4"}))})) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (is Mover P1) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (forEach Piece)))) (end {(if (and (is Mover P1) (no Pieces P2)) (result P1 Win)) (if (and {(is Mover P2) (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))}) (result P2 Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
The rules are the same as for Chess with these differences: White wins by capturing all black pieces. Black wins by checkmating the white king. If no black piece can make a valid move, the game is a draw (stalemate). Black pawns can be promoted to a black queen, rook, bishop or knight if they reach the last row. Black pawns cannot move two spaces forward from any position except the second rank.
(game "Horde Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (and (= (who at:(from)) P1) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (union {(sites Row 5) (sites Row 6) (sites Row 4) (difference (sites Row 7) (sites {"D8" "E8"})) (difference (sites Row 3) (sites {"A4" "B4" "C4" "F4" "G4" "H4"}))})) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (is Mover P1) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (forEach Piece)))) (end {(if (and (is Mover P1) (no Pieces P2)) (result P1 Win)) (if (and {(is Mover P2) (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))}) (result P2 Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
The rules are the same as for Chess with these differences: White wins by capturing all black pieces. Black wins by checkmating the white king. If no black piece can make a valid move, the game is a draw (stalemate). Black pawns can be promoted to a black queen, rook, bishop or knight if they reach the last row. Black pawns cannot move two spaces forward from any position except the second rank.
(game "Horde Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (and (= (who at:(from)) P1) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (union {(sites Row 5) (sites Row 6) (sites Row 4) (difference (sites Row 7) (sites {"D8" "E8"})) (difference (sites Row 3) (sites {"A4" "B4" "C4" "F4" "G4" "H4"}))})) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (is Mover P1) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (forEach Piece)))) (end {(if (and (is Mover P1) (no Pieces P2)) (result P1 Win)) (if (and {(is Mover P2) (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))}) (result P2 Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward, or one space diagonally forward to capture; Players agree at the beginning of the game whether pawns may move two spaces on their first turn. Two pawns may be moved by a player in their first turn of the game. Pawns may only be promoted to a piece that has already been captured. If none have been captured, the pawn must remain in place until a piece has been captured. Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. A King cannot castle if it has ever been checked. Players capture pieces by moving onto a space occupied by an opponent's piece. A player must say 'Gardez la reine' (Guard the Queen) when the queen is threatened. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. A player who causes a stalemate loses. The pawns can double step from the starting positions.
(game "Korkserschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (if (!= (last To) (from)) (or {(if (and (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))}) (is In (from) (sites Mover "Promotion"))) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Bishop"}) Mover))} (then (set Pending)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remember Value "CapturedPieces" (what at:(to))) (remove (to))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))})) (moveAgain)) (if (and (not (is Prev Mover)) (<= (count Turns) 2)) (and (set Pending) (moveAgain)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (and (not (is Pending)) (is Prev Mover)) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (if (is Pending) (or (move Pass) (forEach Piece "Pawn" Mover)) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and (if (or (is Threatened (id "Queen" P1)) (is Threatened (id "Queen" P2))) (note "Gardez la reine")) (if (and (= (state at:(where "King" Next)) 1) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0)))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward, or one space diagonally forward to capture; Players agree at the beginning of the game whether pawns may move two spaces on their first turn. Two pawns may be moved by a player in their first turn of the game. Pawns may only be promoted to a piece that has already been captured. If none have been captured, the pawn must remain in place until a piece has been captured. Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. A King cannot castle if it has ever been checked. Players capture pieces by moving onto a space occupied by an opponent's piece. A player must say 'Gardez la reine' (Guard the Queen) when the queen is threatened. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. A player who causes a stalemate loses. No double step for the pawns.
(game "Korkserschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (if (!= (last To) (from)) (or {(if (and (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))}) (is In (from) (sites Mover "Promotion"))) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Bishop"}) Mover))} (then (set Pending)))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remember Value "CapturedPieces" (what at:(to))) (remove (to))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))})) (moveAgain)) (if (and (not (is Prev Mover)) (<= (count Turns) 2)) (and (set Pending) (moveAgain)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (and (not (is Pending)) (is Prev Mover)) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (if (is Pending) (or (move Pass) (forEach Piece "Pawn" Mover)) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and (if (or (is Threatened (id "Queen" P1)) (is Threatened (id "Queen" P2))) (note "Gardez la reine")) (if (and (= (state at:(where "King" Next)) 1) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0)))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward, or one space diagonally forward to capture; Players agree at the beginning of the game whether pawns may move two spaces on their first turn. Two pawns may be moved by a player in their first turn of the game. Pawns may only be promoted to a piece that has already been captured. If none have been captured, the pawn must remain in place until a piece has been captured. Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. A King cannot castle if it has ever been checked. Players capture pieces by moving onto a space occupied by an opponent's piece. A player must say 'Gardez la reine' (Guard the Queen) when the queen is threatened. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. A player who causes a stalemate loses. The pawns can double step from the starting positions.
(game "Korkserschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (if (!= (last To) (from)) (or {(if (and (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))}) (is In (from) (sites Mover "Promotion"))) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Bishop"}) Mover))} (then (set Pending)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remember Value "CapturedPieces" (what at:(to))) (remove (to))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))})) (moveAgain)) (if (and (not (is Prev Mover)) (<= (count Turns) 2)) (and (set Pending) (moveAgain)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (and (not (is Pending)) (is Prev Mover)) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (if (is Pending) (or (move Pass) (forEach Piece "Pawn" Mover)) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and (if (or (is Threatened (id "Queen" P1)) (is Threatened (id "Queen" P2))) (note "Gardez la reine")) (if (and (= (state at:(where "King" Next)) 1) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0)))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
All movement of chessman’s are the same, just if you want to go on higher level, you can just go on first reachable chess box of higher level. And on next move, go on that level or to lower levels without restrictions. Knight goes without any restrictions. Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Four Players.
(game "Level Chess" (players {(player N) (player S) (player E) (player W)}) (equipment {(board (merge (shift 0 3 (rectangle 8 14)) (shift 3 0 (rectangle 14 8)))) (piece "Pawn" Each (if (is Active (who at:(from))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)) (apply if:(>= (+ (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) 1) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter)))))) (piece "Rook" Each (if (is Active (who at:(from))) (move Slide Orthogonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "King" Each (if (is Active (who at:(from))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Bishop" Each (if (is Active (who at:(from))) (move Slide Diagonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Knight" Each (if (is Active (who at:(from))) (move (from) (to (difference (forEach (sites Board) if:(and {(not (is Friend (who at:(site)))) (= 3 (count Steps Orthogonal (from) (site)))})) (sites To (slide (between if:True)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Queen" Each (if (is Active (who at:(from))) (move Slide (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (map "King" {(pair 1 "H1") (pair 2 "H14") (pair 3 "A7") (pair 4 "N7")}) (map "RookLeft" {(pair 1 "D1") (pair 2 "K14") (pair 3 "A11") (pair 4 "N4")}) (map "RookRight" {(pair 1 "K1") (pair 2 "D14") (pair 3 "A4") (pair 4 "N11")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "Promotion" P3 (sites Right)) (regions "Promotion" P4 (sites Left)) (regions "Level2" (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)}))) (regions "Level2Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)})))) (regions "Level2Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)})))) (regions "Level3" (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)}))) (regions "Level3Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)})))) (regions "Level3Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)}))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 12)) (place "Pawn3" (sites Column 1)) (place "Pawn4" (sites Column 12)) (place "Rook1" {"D1" "K1"} state:1) (place "Knight1" {"E1" "J1"}) (place "Bishop1" {"F1" "I1"}) (place "Queen1" coord:"G1") (place "King1" coord:"H1" state:1) (place "Rook2" {"D14" "K14"} state:1) (place "Knight2" {"E14" "J14"}) (place "Bishop2" {"F14" "I14"}) (place "Queen2" coord:"G14") (place "King2" coord:"H14" state:1) (place "Rook3" {"A11" "A4"} state:1) (place "Knight3" {"A10" "A5"}) (place "Bishop3" {"A6" "A9"}) (place "Queen3" coord:"A8") (place "King3" coord:"A7" state:1) (place "Rook4" {"N4" "N11"} state:1) (place "Knight4" {"N5" "N10"}) (place "Bishop4" {"N6" "N9"}) (place "Queen4" coord:"N8") (place "King4" coord:"N7" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or {(if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) N (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) S (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))}))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (and (is Threatened (id "King" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King" P1))))))) (remove (where (id "King" P1))))) (if (and (is Active P2) (not (is Mover P2))) (if (and (is Threatened (id "King" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King" P2))))))) (remove (where (id "King" P2))))) (if (and (is Active P3) (not (is Mover P3))) (if (and (is Threatened (id "King" P3)) (not (can Move (do (and (forEach Piece P3) (set NextPlayer (player 3))) ifAfterwards:(not (is Threatened (id "King" P3))))))) (remove (where (id "King" P3))))) (if (and (is Active P4) (not (is Mover P4))) (if (and (is Threatened (id "King" P4)) (not (can Move (do (and (forEach Piece P4) (set NextPlayer (player 4))) ifAfterwards:(not (is Threatened (id "King" P4))))))) (remove (where (id "King" P4)))))})))) (end {(forEach NonMover if:(= (where "King" Player) -1) (result Player Loss)) (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw))}))) 
All movement of chessman’s are the same, just if you want to go on higher level, you can just go on first reachable chess box of higher level. And on next move, go on that level or to lower levels without restrictions. Knight goes without any restrictions. Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Two Players.
(game "Level Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (if (is Active (who at:(from))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)) (apply if:(>= (+ (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) 1) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter)))))) (piece "Rook" Each (if (is Active (who at:(from))) (move Slide Orthogonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "King" Each (if (is Active (who at:(from))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Bishop" Each (if (is Active (who at:(from))) (move Slide Diagonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Knight" Each (if (is Active (who at:(from))) (move (from) (to (difference (forEach (sites Board) if:(and {(not (is Friend (who at:(site)))) (= 3 (count Steps Orthogonal (from) (site)))})) (sites To (slide (between if:True)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Queen" Each (if (is Active (who at:(from))) (move Slide (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "Level2" (expand (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:1) (expand (sites Right) steps:1)})))) (regions "Level2Phase0" (intersection (sites Phase 0) (expand (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:1) (expand (sites Right) steps:1)}))))) (regions "Level2Phase1" (intersection (sites Phase 1) (expand (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:1) (expand (sites Right) steps:1)}))))) (regions "Level3" (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:1) (expand (sites Right) steps:1)}))) (regions "Level3Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:1) (expand (sites Right) steps:1)})))) (regions "Level3Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:1) (expand (sites Right) steps:1)}))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or {(if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) N (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) S (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))}))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (and (is Threatened (id "King" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King" P1))))))) (remove (where (id "King" P1))))) (if (and (is Active P2) (not (is Mover P2))) (if (and (is Threatened (id "King" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King" P2))))))) (remove (where (id "King" P2)))))})))) (end {(forEach NonMover if:(= (where "King" Player) -1) (result Player Loss)) (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw))}))) 
All movement of chessman’s are the same, just if you want to go on higher level, you can just go on first reachable chess box of higher level. And on next move, go on that level or to lower levels without restrictions. Knight goes without any restrictions. Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Eight Players.
(game "Level Chess" (players {(player N) (player E) (player E) (player S) (player S) (player W) (player W) (player N)}) (equipment {(board (merge {(shift 0 3 (rectangle 8 23)) (shift 3 0 (rectangle 23 8)) (shift 0 12 (rectangle 8 23)) (shift 12 0 (rectangle 23 8))})) (piece "Pawn" Each (if (is Active (who at:(from))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)) (apply if:(>= (+ (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) 1) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter)))))) (piece "Rook" Each (if (is Active (who at:(from))) (move Slide Orthogonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "King" Each (if (is Active (who at:(from))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Bishop" Each (if (is Active (who at:(from))) (move Slide Diagonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Knight" Each (if (is Active (who at:(from))) (move (from) (to (difference (forEach (sites Board) if:(and {(not (is Friend (who at:(site)))) (= 3 (count Steps Orthogonal (from) (site)))})) (sites To (slide (between if:True)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Queen" Each (if (is Active (who at:(from))) (move Slide (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (map "King" {(pair 1 "H1") (pair 2 "A7") (pair 3 "A16") (pair 4 "H23") (pair 5 "Q23") (pair 6 "W16") (pair 7 "W7") (pair 8 "Q1")}) (map "RookLeft" {(pair 1 "D1") (pair 2 "A11") (pair 3 "A20") (pair 4 "K23") (pair 5 "T23") (pair 6 "W13") (pair 7 "W4") (pair 8 "M1")}) (map "RookRight" {(pair 1 "K1") (pair 2 "A4") (pair 3 "A13") (pair 4 "D23") (pair 5 "M23") (pair 6 "W20") (pair 7 "W11") (pair 8 "T1")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "Promotion" P3 (sites Right)) (regions "Promotion" P4 (sites Left)) (regions "Promotion" P5 (sites Top)) (regions "Promotion" P6 (sites Bottom)) (regions "Promotion" P7 (sites Right)) (regions "Promotion" P8 (sites Left)) (regions "Level2" (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)}))) (regions "Level2Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)})))) (regions "Level2Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)})))) (regions "Level3" (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)}))) (regions "Level3Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)})))) (regions "Level3Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)})))) (regions "Level4" (difference (sites Board) (union {(expand (sites Top) steps:6) (expand (sites Bottom) steps:6) (expand (sites Left) steps:6) (expand (sites Right) steps:6)}))) (regions "Level4Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:6) (expand (sites Bottom) steps:6) (expand (sites Left) steps:6) (expand (sites Right) steps:6)})))) (regions "Level4Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:6) (expand (sites Bottom) steps:6) (expand (sites Left) steps:6) (expand (sites Right) steps:6)})))) (regions "Level5" (difference (sites Board) (union {(expand (sites Top) steps:8) (expand (sites Bottom) steps:8) (expand (sites Left) steps:8) (expand (sites Right) steps:8)}))) (regions "Level5Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:8) (expand (sites Bottom) steps:8) (expand (sites Left) steps:8) (expand (sites Right) steps:8)})))) (regions "Level5Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:8) (expand (sites Bottom) steps:8) (expand (sites Left) steps:8) (expand (sites Right) steps:8)}))))}) (rules (start {(place "Pawn1" (sites {"D2" "E2" "F2" "G2" "H2" "I2" "J2" "K2"})) (place "Pawn2" (sites {"B4" "B5" "B6" "B7" "B8" "B9" "B10" "B11"})) (place "Pawn3" (sites {"B13" "B14" "B15" "B16" "B17" "B18" "B19" "B20"})) (place "Pawn4" (sites {"D22" "E22" "F22" "G22" "H22" "I22" "J22" "K22"})) (place "Pawn5" (sites {"M22" "N22" "O22" "P22" "Q22" "R22" "S22" "T22"})) (place "Pawn6" (sites {"V13" "V14" "V15" "V16" "V17" "V18" "V19" "V20"})) (place "Pawn7" (sites {"V4" "V5" "V6" "V7" "V8" "V9" "V10" "V11"})) (place "Pawn8" (sites {"M2" "N2" "O2" "P2" "Q2" "R2" "S2" "T2"})) (place "Rook1" {"D1" "K1"} state:1) (place "Knight1" {"E1" "J1"}) (place "Bishop1" {"F1" "I1"}) (place "Queen1" coord:"G1") (place "King1" coord:"H1" state:1) (place "Rook2" {"A11" "A4"} state:1) (place "Knight2" {"A10" "A5"}) (place "Bishop2" {"A6" "A9"}) (place "Queen2" coord:"A8") (place "King2" coord:"A7" state:1) (place "Rook3" {"A13" "A20"} state:1) (place "Knight3" {"A14" "A19"}) (place "Bishop3" {"A15" "A18"}) (place "Queen3" coord:"A17") (place "King3" coord:"A16" state:1) (place "Rook4" {"D23" "K23"} state:1) (place "Knight4" {"E23" "J23"}) (place "Bishop4" {"F23" "I23"}) (place "Queen4" coord:"G23") (place "King4" coord:"H23" state:1) (place "Rook5" {"M23" "T23"} state:1) (place "Knight5" {"N23" "S23"}) (place "Bishop5" {"O23" "R23"}) (place "Queen5" coord:"P23") (place "King5" coord:"Q23" state:1) (place "Rook6" {"W20" "W13"} state:1) (place "Knight6" {"W19" "W14"}) (place "Bishop6" {"W18" "W15"}) (place "Queen6" coord:"W17") (place "King6" coord:"W16" state:1) (place "Rook7" {"W4" "W11"} state:1) (place "Knight7" {"W10" "W5"}) (place "Bishop7" {"W6" "W9"}) (place "Queen7" coord:"W8") (place "King7" coord:"W7" state:1) (place "Rook8" {"M1" "T1"} state:1) (place "Knight8" {"N1" "S1"}) (place "Bishop8" {"O1" "R1"}) (place "Queen8" coord:"P1") (place "King8" coord:"Q1" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or {(if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) N (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) S (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))}))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (and (is Threatened (id "King" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King" P1))))))) (remove (where (id "King" P1))))) (if (and (is Active P2) (not (is Mover P2))) (if (and (is Threatened (id "King" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King" P2))))))) (remove (where (id "King" P2))))) (if (and (is Active P3) (not (is Mover P3))) (if (and (is Threatened (id "King" P3)) (not (can Move (do (and (forEach Piece P3) (set NextPlayer (player 3))) ifAfterwards:(not (is Threatened (id "King" P3))))))) (remove (where (id "King" P3))))) (if (and (is Active P4) (not (is Mover P4))) (if (and (is Threatened (id "King" P4)) (not (can Move (do (and (forEach Piece P4) (set NextPlayer (player 4))) ifAfterwards:(not (is Threatened (id "King" P4))))))) (remove (where (id "King" P4))))) (if (and (is Active P5) (not (is Mover P5))) (if (and (is Threatened (id "King" P5)) (not (can Move (do (and (forEach Piece P5) (set NextPlayer (player 5))) ifAfterwards:(not (is Threatened (id "King" P5))))))) (remove (where (id "King" P5))))) (if (and (is Active P6) (not (is Mover P6))) (if (and (is Threatened (id "King" P6)) (not (can Move (do (and (forEach Piece P6) (set NextPlayer (player 6))) ifAfterwards:(not (is Threatened (id "King" P6))))))) (remove (where (id "King" P6))))) (if (and (is Active P7) (not (is Mover P7))) (if (and (is Threatened (id "King" P7)) (not (can Move (do (and (forEach Piece P7) (set NextPlayer (player 7))) ifAfterwards:(not (is Threatened (id "King" P7))))))) (remove (where (id "King" P7))))) (if (and (is Active P8) (not (is Mover P8))) (if (and (is Threatened (id "King" P8)) (not (can Move (do (and (forEach Piece P8) (set NextPlayer (player 8))) ifAfterwards:(not (is Threatened (id "King" P8))))))) (remove (where (id "King" P8)))))})))) (end {(forEach NonMover if:(= (where "King" Player) -1) (result Player Loss)) (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw))}))) 
Mini Hexchess is played on a hexagonal board with each side having length 5, and each space oriented horizontally. The board has 37 spaces. Piece Movement: * Kings, Rooks, Bishops, and Knights move as in Glinski Chess. - Kings step one space in any of the 12 directions. They do not castle. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * There are no Queens in Mini Hexchess. * Pawns can advance one space forward without capturing. Pawns can never advance more than one space. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). There is no en passant capture. On reaching the farthest rank in a given file, Pawns are promoted to a Rook, Bishop, or Knight. Note that a Pawn cannot be promoted to a Queen, since there are no Queens in Mini Hexchess. The game ends on a checkmate or stalemate.
(game "Mini Hexchess" (players {(player N) (player S)}) (equipment {(board (rotate 90 (hex 4))) (piece "King" Each (move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 2)) (regions "Region-Light" (sites Phase 1)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King1" coord:"B2") (place "Rook1" coord:"B1") (place "Bishop1" coord:"A1") (place "Knight1" coord:"A2") (place "King2" coord:"F6") (place "Rook2" coord:"F7") (place "Bishop2" coord:"G7") (place "Knight2" coord:"G6") (place "Pawn1" {"A3" "B3" "C3" "C2" "C1"}) (place "Pawn2" {"E7" "E6" "E5" "F5" "G5"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Mini Hexchess is played on a hexagonal board with each side having length 5, and each space oriented horizontally. The board has 37 spaces. Piece Movement: * Kings, Rooks, Bishops, and Knights move as in Glinski Chess. - Kings step one space in any of the 12 directions. They do not castle. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * There are no Queens in Mini Hexchess. * Pawns can advance one space forward without capturing. Pawns can never advance more than one space. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). There is no en passant capture. On reaching the farthest rank in a given file, Pawns are promoted to a Rook, Bishop, or Knight. Note that a Pawn cannot be promoted to a Queen, since there are no Queens in Mini Hexchess. The game ends on a checkmate or stalemate.
(game "Mini Hexchess" (players {(player N) (player S)}) (equipment {(board (rotate 90 (hex 4))) (piece "King" Each (move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 2)) (regions "Region-Light" (sites Phase 1)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King1" coord:"B2") (place "Rook1" coord:"B1") (place "Bishop1" coord:"A1") (place "Knight1" coord:"A2") (place "King2" coord:"F6") (place "Rook2" coord:"F7") (place "Bishop2" coord:"G7") (place "Knight2" coord:"G6") (place "Pawn1" {"A3" "B3" "C3" "C2" "C1"}) (place "Pawn2" {"E7" "E6" "E5" "F5" "G5"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Mini Hexchess is played on a hexagonal board with each side having length 5, and each space oriented horizontally. The board has 37 spaces. Piece Movement: * Kings, Rooks, Bishops, and Knights move as in Glinski Chess. - Kings step one space in any of the 12 directions. They do not castle. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * There are no Queens in Mini Hexchess. * Pawns can advance one space forward without capturing. Pawns can never advance more than one space. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). There is no en passant capture. On reaching the farthest rank in a given file, Pawns are promoted to a Rook, Bishop, or Knight. Note that a Pawn cannot be promoted to a Queen, since there are no Queens in Mini Hexchess. The game ends on a checkmate or stalemate.
(game "Mini Hexchess" (players {(player N) (player S)}) (equipment {(board (rotate 90 (hex 4))) (piece "King" Each (move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 2)) (regions "Region-Light" (sites Phase 1)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King1" coord:"B2") (place "Rook1" coord:"B1") (place "Bishop1" coord:"A1") (place "Knight1" coord:"A2") (place "King2" coord:"F6") (place "Rook2" coord:"F7") (place "Bishop2" coord:"G7") (place "Knight2" coord:"G6") (place "Pawn1" {"A3" "B3" "C3" "C2" "C1"}) (place "Pawn2" {"E7" "E6" "E5" "F5" "G5"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
The following rules are additionally used to the chess rules: - Pawns can only advance one space on their first move. There is no en passant capturing. - A pawn can only promote to a captured piece. - There is no castling. - If 20 moves are played without a capture or promotion, the player with the most `points' on the board wins. (Pawn=1 pt., Bishop/Knight=3, Rook=5, Queen = 9.) The game starts like in the encyclopedia of Chess Variants.
(game "Quick Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 6 5)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remove (to)) (remember Value "CapturedPieces" (what at:(to)))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (can Move (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}))) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 4)) (place "Rook1" {"E1"}) (place "Knight1" {"A1"}) (place "Bishop1" {"D1"}) (place "Queen1" coord:"C1") (place "King1" coord:"B1") (place "Rook2" {"E6"}) (place "Knight2" {"A6"}) (place "Bishop2" {"D6"}) (place "Queen2" coord:"C6") (place "King2" coord:"B6")}) (play (if (is Prev Mover) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (if (= 19 (counter)) (and (forEach Player (forEach Site (sites Occupied by:Player) (if (= (what at:(site)) (id "Pawn" Player)) (addScore Player 1) (if (= (what at:(site)) (id "Rook" Player)) (addScore Player 5) (if (= (what at:(site)) (id "Queen" Player)) (addScore Player 9) (if (!= (what at:(site)) (id "King" Player)) (addScore Player 3))))))) (set Var "NoEnoughCapture" 1)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Draw)) (if (= (var "NoEnoughCapture") 1) (byScore))}))) 
The following rules are additionally used to the chess rules: - Pawns can only advance one space on their first move. There is no en passant capturing. - A pawn can only promote to a captured piece. - There is no castling. - If 20 moves are played without a capture or promotion, the player with the most `points' on the board wins. (Pawn=1 pt., Bishop/Knight=3, Rook=5, Queen = 9.) The game starts like in the Quickchess.site.
(game "Quick Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 6 5)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remove (to)) (remember Value "CapturedPieces" (what at:(to)))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (can Move (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}))) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 4)) (place "Rook1" {"A1"}) (place "Knight1" {"E1"}) (place "Bishop1" {"B1"}) (place "Queen1" coord:"D1") (place "King1" coord:"C1") (place "Rook2" {"A6"}) (place "Knight2" {"E6"}) (place "Bishop2" {"B6"}) (place "Queen2" coord:"D6") (place "King2" coord:"C6")}) (play (if (is Prev Mover) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (if (= 19 (counter)) (and (forEach Player (forEach Site (sites Occupied by:Player) (if (= (what at:(site)) (id "Pawn" Player)) (addScore Player 1) (if (= (what at:(site)) (id "Rook" Player)) (addScore Player 5) (if (= (what at:(site)) (id "Queen" Player)) (addScore Player 9) (if (!= (what at:(site)) (id "King" Player)) (addScore Player 3))))))) (set Var "NoEnoughCapture" 1)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Draw)) (if (= (var "NoEnoughCapture") 1) (byScore))}))) 
The following rules are additionally used to the chess rules: - Pawns can only advance one space on their first move. There is no en passant capturing. - A pawn can only promote to a captured piece. - There is no castling. - If 20 moves are played without a capture or promotion, the player with the most `points' on the board wins. (Pawn=1 pt., Bishop/Knight=3, Rook=5, Queen = 9.) The game starts like in the encyclopedia of Chess Variants.
(game "Quick Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 6 5)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remove (to)) (remember Value "CapturedPieces" (what at:(to)))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (can Move (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}))) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 4)) (place "Rook1" {"E1"}) (place "Knight1" {"A1"}) (place "Bishop1" {"D1"}) (place "Queen1" coord:"C1") (place "King1" coord:"B1") (place "Rook2" {"E6"}) (place "Knight2" {"A6"}) (place "Bishop2" {"D6"}) (place "Queen2" coord:"C6") (place "King2" coord:"B6")}) (play (if (is Prev Mover) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (if (= 19 (counter)) (and (forEach Player (forEach Site (sites Occupied by:Player) (if (= (what at:(site)) (id "Pawn" Player)) (addScore Player 1) (if (= (what at:(site)) (id "Rook" Player)) (addScore Player 5) (if (= (what at:(site)) (id "Queen" Player)) (addScore Player 9) (if (!= (what at:(site)) (id "King" Player)) (addScore Player 3))))))) (set Var "NoEnoughCapture" 1)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Draw)) (if (= (var "NoEnoughCapture") 1) (byScore))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap one, two, or three squares on its first move if it has not yet been checked and does not hop over an opponent's piece. The King cannot make this leap over an opponent's piece. A capture cannot be made with this special first move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. The Rook's, King's and Queen's Pawns may move two spaces on its first move. The King's and Queen's Pawns are restricted in having this ability only if no piece on the board has been captured. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted, but cannot capture with this move. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
(game "Schachzabel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between (range 1 3) if:(not (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (= 1 (state at:(from))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (and {(is In (from) (sites Start (piece (what at:(from))))) (= 1 (state at:(from))) (= 32 (count Sites in:(sites Occupied by:All)))}) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece (id "Queen" Mover))) (set State at:(last To) 1)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites {"A2" "D2" "E2" "H2"}) state:1) (place "Pawn2" (sites {"A7" "D7" "E7" "H7"}) state:1) (place "Pawn1" (sites {"B2" "C2" "F2" "G2"})) (place "Pawn2" (sites {"B7" "C7" "F7" "G7"})) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (and (= 1 (state at:(where "King" Next))) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap one, two, or three squares on its first move if it has not yet been checked and does not hop over an opponent's piece. The King cannot make this leap over an opponent's piece. A capture cannot be made with this special first move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. The Rook's, King's and Queen's Pawns may move two spaces on its first move. The King's and Queen's Pawns are restricted in having this ability only if no piece on the board has been captured. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted, but cannot capture with this move. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
(game "Schachzabel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between (range 1 3) if:(not (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (= 1 (state at:(from))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (and {(is In (from) (sites Start (piece (what at:(from))))) (= 1 (state at:(from))) (= 32 (count Sites in:(sites Occupied by:All)))}) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece (id "Queen" Mover))) (set State at:(last To) 1)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites {"A2" "D2" "E2" "H2"}) state:1) (place "Pawn2" (sites {"A7" "D7" "E7" "H7"}) state:1) (place "Pawn1" (sites {"B2" "C2" "F2" "G2"})) (place "Pawn2" (sites {"B7" "C7" "F7" "G7"})) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (and (= 1 (state at:(where "King" Next))) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap one, two, or three squares on its first move if it has not yet been checked and does not hop over an opponent's piece. The King cannot make this leap over an opponent's piece. A capture cannot be made with this special first move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. The Rook's, King's and Queen's Pawns may move two spaces on its first move. The King's and Queen's Pawns are restricted in having this ability only if no piece on the board has been captured. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted, but cannot capture with this move. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.
(game "Schachzabel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between (range 1 3) if:(not (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (= 1 (state at:(from))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (and {(is In (from) (sites Start (piece (what at:(from))))) (= 1 (state at:(from))) (= 32 (count Sites in:(sites Occupied by:All)))}) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece (id "Queen" Mover))) (set State at:(last To) 1)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites {"A2" "D2" "E2" "H2"}) state:1) (place "Pawn2" (sites {"A7" "D7" "E7" "H7"}) state:1) (place "Pawn1" (sites {"B2" "C2" "F2" "G2"})) (place "Pawn2" (sites {"B7" "C7" "F7" "G7"})) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (and (= 1 (state at:(where "King" Next))) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen: One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Queen when reaching the eighth rank. The pieces begin in the following position: Fils on the third and sixth spaces of the first row, King on the fifth space of the first row, Rooks on the third and sixth spaces of the second row, Knights on the fourth and fifth spaces of the second row, Pawns on the third row, the Queen sharing a space with the Pawn in the fifth space. Kings are on the same column. The only time two pieces can be on the same space is in this initial arrangement. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. Capturing all of an opponent's pieces except the King also results in a win.
(game "Short Assize" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (move Step (from (from) level:(level)) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Rook" Each (move Slide (from (from) level:(level)) Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Bishop" Each (move Hop (from (from) level:(level)) Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Knight" Each (move Leap (from (from) level:(level)) {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Queen" Each (move Step (from (from) level:(level)) Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Pawn" Each (or (move Step (from (from) level:(level)) Forward (to if:(is Empty (to)))) (move Step (from (from) level:(level)) (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (forEach Level (to) (remove (to) level:(level)))))) (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (id "Queen" Mover))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Bishop1" (sites {"C1" "F1"})) (place "Rook1" (sites {"C2" "F2"})) (place "Knight1" (sites {"D2" "E2"})) (place "King1" coord:"E1") (place Stack "Pawn1" (sites Row 2)) (place Stack "Queen1" (sites {"D3"})) (place "Bishop2" (sites {"C8" "F8"})) (place "Rook2" (sites {"C7" "F7"})) (place "Knight2" (sites {"D7" "E7"})) (place "King2" coord:"E8") (place Stack "Pawn2" (sites Row 5)) (place Stack "Queen2" (sites {"D6"}))}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen: One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Queen when reaching the eighth rank. The pieces begin in the following position: Fils on the third and sixth spaces of the first row, King on the fifth space of the first row, Rooks on the third and sixth spaces of the second row, Knights on the fourth and fifth spaces of the second row, Pawns on the third row, the Queen sharing a space with the Pawn in the fifth space. Kings are on the same column. The only time two pieces can be on the same space is in this initial arrangement. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. Capturing all of an opponent's pieces except the King also results in a win.
(game "Short Assize" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (move Step (from (from) level:(level)) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Rook" Each (move Slide (from (from) level:(level)) Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Bishop" Each (move Hop (from (from) level:(level)) Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Knight" Each (move Leap (from (from) level:(level)) {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Queen" Each (move Step (from (from) level:(level)) Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Pawn" Each (or (move Step (from (from) level:(level)) Forward (to if:(is Empty (to)))) (move Step (from (from) level:(level)) (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (forEach Level (to) (remove (to) level:(level)))))) (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (id "Queen" Mover))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Bishop1" (sites {"C1" "F1"})) (place "Rook1" (sites {"C2" "F2"})) (place "Knight1" (sites {"D2" "E2"})) (place "King1" coord:"E1") (place Stack "Pawn1" (sites Row 2)) (place Stack "Queen1" (sites {"D3"})) (place "Bishop2" (sites {"C8" "F8"})) (place "Rook2" (sites {"C7" "F7"})) (place "Knight2" (sites {"D7" "E7"})) (place "King2" coord:"E8") (place Stack "Pawn2" (sites Row 5)) (place Stack "Queen2" (sites {"D6"}))}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen: One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Queen when reaching the eighth rank. The pieces begin in the following position: Fils on the third and sixth spaces of the first row, King on the fifth space of the first row, Rooks on the third and sixth spaces of the second row, Knights on the fourth and fifth spaces of the second row, Pawns on the third row, the Queen sharing a space with the Pawn in the fifth space. Kings are on the same column. The only time two pieces can be on the same space is in this initial arrangement. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. Capturing all of an opponent's pieces except the King also results in a win.
(game "Short Assize" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (move Step (from (from) level:(level)) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Rook" Each (move Slide (from (from) level:(level)) Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Bishop" Each (move Hop (from (from) level:(level)) Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Knight" Each (move Leap (from (from) level:(level)) {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Queen" Each (move Step (from (from) level:(level)) Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Pawn" Each (or (move Step (from (from) level:(level)) Forward (to if:(is Empty (to)))) (move Step (from (from) level:(level)) (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (forEach Level (to) (remove (to) level:(level)))))) (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (id "Queen" Mover))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Bishop1" (sites {"C1" "F1"})) (place "Rook1" (sites {"C2" "F2"})) (place "Knight1" (sites {"D2" "E2"})) (place "King1" coord:"E1") (place Stack "Pawn1" (sites Row 2)) (place Stack "Queen1" (sites {"D3"})) (place "Bishop2" (sites {"C8" "F8"})) (place "Rook2" (sites {"C7" "F7"})) (place "Knight2" (sites {"D7" "E7"})) (place "King2" coord:"E8") (place Stack "Pawn2" (sites Row 5)) (place Stack "Queen2" (sites {"D6"}))}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win))}))) 
<b>The Pieces</b> - <i>White</i> (the Persians) has orthodox chess pieces in standard spaces: 2 Rooks (A1, H1); 2 Knights (B1, G1); 2 Bishops (C1, F1); 1 Queen (D1); 1 King (E1); 8 Pawns (A2-H2). - <i>Black</i> (the Spartans) has: 2 Lieutenants (A8, H8); 1 General (B8); 1 Warlord (G8); 2 Kings (C8, F8); 2 Captains (D8, E8); 8 Hoplites (A7-H7). <b>The Moves</b> - <i>Pawns</i> can move (but not capture) one space forward. On their first move they can move two spaces forward. They capture one space diagonally forward. There is no en passant rule. - <i>Rooks</i> can move and capture any number of spaces orthogonally. - <i>Bishops</i> can move and capture any number of spaces diagonally. - <i>Knights</i> can move one space orthogonally with one space forward diagonally leaping over intervening pieces and capturing what they land on. - The <i>Queen</i> can move and capture any number of spaces orthogonally or diagonally. - <i>Kings</i> can move and capture one space orthogonally or diagonally. - <i>Lieutenants</i> (shown as crosses) can move and capture diagonally upto two spaces, jumping over any piece if necessary. They can also move (but not capture) one space sideways. - The <i>General</i> (shown as an upside-down rook) can move and capture any number of spaces orthogonally or one space diagonally. - The <i>Warlord</i> (shown as an upside-down bishop) can move and capture any number of spaces diagonally or like a knight. - <i>Captains</i> (shown as squares) can move and capture upto spaces orthogonally and may jump if necessary. - <i>Hoplites</i> (shown as an upside-down pawns) can move (but not capture) one space diagonally forward. On their first move they can move two spaces diagonally forward, jumping if necessary. They capture one space forward. <b>Winning</b> The Spartan and Persian have different victory conditions. <i>Spartan Victory</i>: The Spartan wins when the Persian King is checkmated as in orthodox chess. <i>Persians Victory</i>: The Persian wins once one of the Spartan Kings is captured and the remaining Spartan King is checkmated or when both Spartan Kings are placed under simultaneous attack (duple-check) and neither King can be removed from attack on the next move (Duple-Check and Mate). <b>First Move</b> The Persians, being the aggressors historically and White, always move first. <b>Check Immunity</b> When the Spartan has two Kings in play a Spartan King is immune from check. Thus, the Spartan may move a King onto an enemy attacked square, leave a King under attack or move a piece that would expose a King to attack. <b>Duple-Check & Mate</b> If both Spartan Kings are placed under simultaneous attack this is a form of check called duple-check. It is illegal for the Spartan to make a move that will place both of his Kings underattack. With both Kings under attack, the Spartan loses if on his move he is unable to remove at least one King from attack. In such case the game ends in checkmate. <b>Promotion</b> A hoplite, upon reaching its 8th rank, may promote to any Spartan piece including a King but only if the Spartan has only one king in play. A pawn, upon reaching its 8th rank, may promote to any Persian piece apart from the King. <b>Capturing en passant</b> There is no capturing en passant in Spartan Chess. <b>Castling</b> Spartan Kings may not castle. Persian Kings may castle as normal.
(game "Spartan Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" P1 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FL FR}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Hoplite" P2 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop (directions {FL FR}) (to if:(is Empty (to))))) (move Step (directions {FL FR}) (to if:(is Empty (to)))) (move Step Forward (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" P1 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "General" P2 (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Warlord" P2 (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Lieutenant" P2 (or {(move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Diagonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step (directions {W E}) (to if:(is Empty (to))))})) (piece "Captain" P2 (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Orthogonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "King" Each (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" P1 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" P1 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" P1 (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Hoplite2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Lieutenant2" {"A8" "H8"}) (place "Warlord2" {"G8"}) (place "General2" {"B8"}) (place "King2" {"C8" "F8"} state:0) (place "Captain2" {"D8" "E8"})}) (play (if (is Prev Mover) (if (= (mover) (id P1)) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (= 1 (count Sites in:(sites Occupied by:P2 component:"King"))) (move Promote (last To) (piece {"King" "Captain" "General" "Warlord" "Lieutenant"}) Mover) (move Promote (last To) (piece {"Captain" "General" "Warlord" "Lieutenant"}) Mover))) (do (or (forEach Piece) (if (and {(= (what at:4) (id "King" Mover)) (= (state at:4) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:0) 1) (can Move (move Slide (from 0) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from 4) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 0) E (between (exact 3) if:True)))))) (if (and (= (state at:7) 1) (can Move (move Slide (from 7) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from 4) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 7) W (between (exact 2) if:True))))))))) ifAfterwards:(not (all Sites (sites Occupied by:Mover component:"King") if:(is Threatened at:(site))))))) (end {(if (and (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site)))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
<b>The Pieces</b> - <i>White</i> (the Persians) has orthodox chess pieces in standard spaces: 2 Rooks (A1, H1); 2 Knights (B1, G1); 2 Bishops (C1, F1); 1 Queen (D1); 1 King (E1); 8 Pawns (A2-H2). - <i>Black</i> (the Spartans) has: 2 Lieutenants (A8, H8); 1 General (B8); 1 Warlord (G8); 2 Kings (C8, F8); 2 Captains (D8, E8); 8 Hoplites (A7-H7). <b>The Moves</b> - <i>Pawns</i> can move (but not capture) one space forward. On their first move they can move two spaces forward. They capture one space diagonally forward. There is no en passant rule. - <i>Rooks</i> can move and capture any number of spaces orthogonally. - <i>Bishops</i> can move and capture any number of spaces diagonally. - <i>Knights</i> can move one space orthogonally with one space forward diagonally leaping over intervening pieces and capturing what they land on. - The <i>Queen</i> can move and capture any number of spaces orthogonally or diagonally. - <i>Kings</i> can move and capture one space orthogonally or diagonally. - <i>Lieutenants</i> (shown as crosses) can move and capture diagonally upto two spaces, jumping over any piece if necessary. They can also move (but not capture) one space sideways. - The <i>General</i> (shown as an upside-down rook) can move and capture any number of spaces orthogonally or one space diagonally. - The <i>Warlord</i> (shown as an upside-down bishop) can move and capture any number of spaces diagonally or like a knight. - <i>Captains</i> (shown as squares) can move and capture upto spaces orthogonally and may jump if necessary. - <i>Hoplites</i> (shown as an upside-down pawns) can move (but not capture) one space diagonally forward. On their first move they can move two spaces diagonally forward, jumping if necessary. They capture one space forward. <b>Winning</b> The Spartan and Persian have different victory conditions. <i>Spartan Victory</i>: The Spartan wins when the Persian King is checkmated as in orthodox chess. <i>Persians Victory</i>: The Persian wins once one of the Spartan Kings is captured and the remaining Spartan King is checkmated or when both Spartan Kings are placed under simultaneous attack (duple-check) and neither King can be removed from attack on the next move (Duple-Check and Mate). <b>First Move</b> The Persians, being the aggressors historically and White, always move first. <b>Check Immunity</b> When the Spartan has two Kings in play a Spartan King is immune from check. Thus, the Spartan may move a King onto an enemy attacked square, leave a King under attack or move a piece that would expose a King to attack. <b>Duple-Check & Mate</b> If both Spartan Kings are placed under simultaneous attack this is a form of check called duple-check. It is illegal for the Spartan to make a move that will place both of his Kings underattack. With both Kings under attack, the Spartan loses if on his move he is unable to remove at least one King from attack. In such case the game ends in checkmate. <b>Promotion</b> A hoplite, upon reaching its 8th rank, may promote to any Spartan piece including a King but only if the Spartan has only one king in play. A pawn, upon reaching its 8th rank, may promote to any Persian piece apart from the King. <b>Capturing en passant</b> There is no capturing en passant in Spartan Chess. <b>Castling</b> Spartan Kings may not castle. Persian Kings may castle as normal.
(game "Spartan Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" P1 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FL FR}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Hoplite" P2 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop (directions {FL FR}) (to if:(is Empty (to))))) (move Step (directions {FL FR}) (to if:(is Empty (to)))) (move Step Forward (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" P1 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "General" P2 (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Warlord" P2 (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Lieutenant" P2 (or {(move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Diagonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step (directions {W E}) (to if:(is Empty (to))))})) (piece "Captain" P2 (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Orthogonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "King" Each (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" P1 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" P1 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" P1 (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Hoplite2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Lieutenant2" {"A8" "H8"}) (place "Warlord2" {"G8"}) (place "General2" {"B8"}) (place "King2" {"C8" "F8"} state:0) (place "Captain2" {"D8" "E8"})}) (play (if (is Prev Mover) (if (= (mover) (id P1)) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (= 1 (count Sites in:(sites Occupied by:P2 component:"King"))) (move Promote (last To) (piece {"King" "Captain" "General" "Warlord" "Lieutenant"}) Mover) (move Promote (last To) (piece {"Captain" "General" "Warlord" "Lieutenant"}) Mover))) (do (or (forEach Piece) (if (and {(= (what at:4) (id "King" Mover)) (= (state at:4) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:0) 1) (can Move (move Slide (from 0) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from 4) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 0) E (between (exact 3) if:True)))))) (if (and (= (state at:7) 1) (can Move (move Slide (from 7) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from 4) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 7) W (between (exact 2) if:True))))))))) ifAfterwards:(not (all Sites (sites Occupied by:Mover component:"King") if:(is Threatened at:(site))))))) (end {(if (and (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site)))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
<b>The Pieces</b> - <i>White</i> (the Persians) has orthodox chess pieces in standard spaces: 2 Rooks (A1, H1); 2 Knights (B1, G1); 2 Bishops (C1, F1); 1 Queen (D1); 1 King (E1); 8 Pawns (A2-H2). - <i>Black</i> (the Spartans) has: 2 Lieutenants (A8, H8); 1 General (B8); 1 Warlord (G8); 2 Kings (C8, F8); 2 Captains (D8, E8); 8 Hoplites (A7-H7). <b>The Moves</b> - <i>Pawns</i> can move (but not capture) one space forward. On their first move they can move two spaces forward. They capture one space diagonally forward. There is no en passant rule. - <i>Rooks</i> can move and capture any number of spaces orthogonally. - <i>Bishops</i> can move and capture any number of spaces diagonally. - <i>Knights</i> can move one space orthogonally with one space forward diagonally leaping over intervening pieces and capturing what they land on. - The <i>Queen</i> can move and capture any number of spaces orthogonally or diagonally. - <i>Kings</i> can move and capture one space orthogonally or diagonally. - <i>Lieutenants</i> (shown as crosses) can move and capture diagonally upto two spaces, jumping over any piece if necessary. They can also move (but not capture) one space sideways. - The <i>General</i> (shown as an upside-down rook) can move and capture any number of spaces orthogonally or one space diagonally. - The <i>Warlord</i> (shown as an upside-down bishop) can move and capture any number of spaces diagonally or like a knight. - <i>Captains</i> (shown as squares) can move and capture upto spaces orthogonally and may jump if necessary. - <i>Hoplites</i> (shown as an upside-down pawns) can move (but not capture) one space diagonally forward. On their first move they can move two spaces diagonally forward, jumping if necessary. They capture one space forward. <b>Winning</b> The Spartan and Persian have different victory conditions. <i>Spartan Victory</i>: The Spartan wins when the Persian King is checkmated as in orthodox chess. <i>Persians Victory</i>: The Persian wins once one of the Spartan Kings is captured and the remaining Spartan King is checkmated or when both Spartan Kings are placed under simultaneous attack (duple-check) and neither King can be removed from attack on the next move (Duple-Check and Mate). <b>First Move</b> The Persians, being the aggressors historically and White, always move first. <b>Check Immunity</b> When the Spartan has two Kings in play a Spartan King is immune from check. Thus, the Spartan may move a King onto an enemy attacked square, leave a King under attack or move a piece that would expose a King to attack. <b>Duple-Check & Mate</b> If both Spartan Kings are placed under simultaneous attack this is a form of check called duple-check. It is illegal for the Spartan to make a move that will place both of his Kings underattack. With both Kings under attack, the Spartan loses if on his move he is unable to remove at least one King from attack. In such case the game ends in checkmate. <b>Promotion</b> A hoplite, upon reaching its 8th rank, may promote to any Spartan piece including a King but only if the Spartan has only one king in play. A pawn, upon reaching its 8th rank, may promote to any Persian piece apart from the King. <b>Capturing en passant</b> There is no capturing en passant in Spartan Chess. <b>Castling</b> Spartan Kings may not castle. Persian Kings may castle as normal.
(game "Spartan Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" P1 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FL FR}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Hoplite" P2 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop (directions {FL FR}) (to if:(is Empty (to))))) (move Step (directions {FL FR}) (to if:(is Empty (to)))) (move Step Forward (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" P1 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "General" P2 (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Warlord" P2 (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Lieutenant" P2 (or {(move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Diagonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step (directions {W E}) (to if:(is Empty (to))))})) (piece "Captain" P2 (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Orthogonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "King" Each (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" P1 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" P1 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" P1 (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Hoplite2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Lieutenant2" {"A8" "H8"}) (place "Warlord2" {"G8"}) (place "General2" {"B8"}) (place "King2" {"C8" "F8"} state:0) (place "Captain2" {"D8" "E8"})}) (play (if (is Prev Mover) (if (= (mover) (id P1)) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (= 1 (count Sites in:(sites Occupied by:P2 component:"King"))) (move Promote (last To) (piece {"King" "Captain" "General" "Warlord" "Lieutenant"}) Mover) (move Promote (last To) (piece {"Captain" "General" "Warlord" "Lieutenant"}) Mover))) (do (or (forEach Piece) (if (and {(= (what at:4) (id "King" Mover)) (= (state at:4) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:0) 1) (can Move (move Slide (from 0) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from 4) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 0) E (between (exact 3) if:True)))))) (if (and (= (state at:7) 1) (can Move (move Slide (from 7) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from 4) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 7) W (between (exact 2) if:True))))))))) ifAfterwards:(not (all Sites (sites Occupied by:Mover component:"King") if:(is Threatened at:(site))))))) (end {(if (and (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site)))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
Starchess is played on a star-shaped hexagonal board that can be thought of as a hexagon-shaped board with each side having length 6, but with four spaces removed from each corner. The board has 37 spaces. Starchess starts off with the non-Pawn pieces being placed behind the Pawns. This happens one piece at a time, in alternating turns, until all non-Pawn pieces have been placed. Then the 'movement phase' of the game begins as usual. Piece Movement: * Knights move as in Glinsky Chess. - They move two spaces in any adjacent direction, then one space in another direction. * Kings can move one space in any of those same six adjacent directions. There is no castling. * Queens can slide in any of the six adjacent directions from their current space---North, South, or 60 degrees off either of those. * Rooks can slide forward or backward only in their given column. * Bishops can slide in only four of the adjacent directions: they cannot slide North or South. * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance two spaces forward, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. Pawns capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. On reaching the farthest rank in any of the innermost five columns, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses. The game ends on a checkmate or stalemate. Some terminology: a Pawn off to the side, in one of the two spaces at the extremes of the middle row is called a 'mummy', while a Pawn in one of the spaces adjacent to that is called a 'dead Pawn'. Mummies and dead Pawns cannot be promoted until they return to one of the innermost five columns.
(game "Starchess" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex Star 2))) (piece "King" Each (move Step Orthogonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide (directions {N S}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide (directions {WNW ENE WSW ESE}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and (set Pending (ahead (last To) Backward)) (set Var (last To)))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (hand Each size:5) (regions "Home" P1 (sites {"A3" "B3" "C3" "C2" "C1"})) (regions "Home" P2 (sites {"G9" "G8" "G7" "H7" "I7"})) (regions "PromotionZone" P1 (sites P2 "Home")) (regions "PromotionZone" P2 (sites P1 "Home")) (regions "Region-Dark" (sites Phase 1)) (regions "Region-Light" (sites Phase 2)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King" "Hand" count:1) (place "Queen" "Hand" count:1) (place "Rook" "Hand" count:1) (place "Bishop" "Hand" count:1) (place "Knight" "Hand" count:1) (place "Pawn1" {"B4" "C4" "D4" "D3" "D2"}) (place "Pawn2" {"F8" "F7" "F6" "G6" "H6"})}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (intersection (sites Mover "Home") (sites Empty))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Starchess is played on a star-shaped hexagonal board that can be thought of as a hexagon-shaped board with each side having length 6, but with four spaces removed from each corner. The board has 37 spaces. Starchess starts off with the non-Pawn pieces being placed behind the Pawns. This happens one piece at a time, in alternating turns, until all non-Pawn pieces have been placed. Then the 'movement phase' of the game begins as usual. Piece Movement: * Knights move as in Glinsky Chess. - They move two spaces in any adjacent direction, then one space in another direction. * Kings can move one space in any of those same six adjacent directions. There is no castling. * Queens can slide in any of the six adjacent directions from their current space---North, South, or 60 degrees off either of those. * Rooks can slide forward or backward only in their given column. * Bishops can slide in only four of the adjacent directions: they cannot slide North or South. * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance two spaces forward, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. Pawns capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. On reaching the farthest rank in any of the innermost five columns, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses. The game ends on a checkmate or stalemate. Some terminology: a Pawn off to the side, in one of the two spaces at the extremes of the middle row is called a 'mummy', while a Pawn in one of the spaces adjacent to that is called a 'dead Pawn'. Mummies and dead Pawns cannot be promoted until they return to one of the innermost five columns.
(game "Starchess" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex Star 2))) (piece "King" Each (move Step Orthogonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide (directions {N S}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide (directions {WNW ENE WSW ESE}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and (set Pending (ahead (last To) Backward)) (set Var (last To)))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (hand Each size:5) (regions "Home" P1 (sites {"A3" "B3" "C3" "C2" "C1"})) (regions "Home" P2 (sites {"G9" "G8" "G7" "H7" "I7"})) (regions "PromotionZone" P1 (sites P2 "Home")) (regions "PromotionZone" P2 (sites P1 "Home")) (regions "Region-Dark" (sites Phase 1)) (regions "Region-Light" (sites Phase 2)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King" "Hand" count:1) (place "Queen" "Hand" count:1) (place "Rook" "Hand" count:1) (place "Bishop" "Hand" count:1) (place "Knight" "Hand" count:1) (place "Pawn1" {"B4" "C4" "D4" "D3" "D2"}) (place "Pawn2" {"F8" "F7" "F6" "G6" "H6"})}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (intersection (sites Mover "Home") (sites Empty))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Starchess is played on a star-shaped hexagonal board that can be thought of as a hexagon-shaped board with each side having length 6, but with four spaces removed from each corner. The board has 37 spaces. Starchess starts off with the non-Pawn pieces being placed behind the Pawns. This happens one piece at a time, in alternating turns, until all non-Pawn pieces have been placed. Then the 'movement phase' of the game begins as usual. Piece Movement: * Knights move as in Glinsky Chess. - They move two spaces in any adjacent direction, then one space in another direction. * Kings can move one space in any of those same six adjacent directions. There is no castling. * Queens can slide in any of the six adjacent directions from their current space---North, South, or 60 degrees off either of those. * Rooks can slide forward or backward only in their given column. * Bishops can slide in only four of the adjacent directions: they cannot slide North or South. * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance two spaces forward, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. Pawns capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. On reaching the farthest rank in any of the innermost five columns, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses. The game ends on a checkmate or stalemate. Some terminology: a Pawn off to the side, in one of the two spaces at the extremes of the middle row is called a 'mummy', while a Pawn in one of the spaces adjacent to that is called a 'dead Pawn'. Mummies and dead Pawns cannot be promoted until they return to one of the innermost five columns.
(game "Starchess" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex Star 2))) (piece "King" Each (move Step Orthogonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide (directions {N S}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide (directions {WNW ENE WSW ESE}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and (set Pending (ahead (last To) Backward)) (set Var (last To)))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (hand Each size:5) (regions "Home" P1 (sites {"A3" "B3" "C3" "C2" "C1"})) (regions "Home" P2 (sites {"G9" "G8" "G7" "H7" "I7"})) (regions "PromotionZone" P1 (sites P2 "Home")) (regions "PromotionZone" P2 (sites P1 "Home")) (regions "Region-Dark" (sites Phase 1)) (regions "Region-Light" (sites Phase 2)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King" "Hand" count:1) (place "Queen" "Hand" count:1) (place "Rook" "Hand" count:1) (place "Bishop" "Hand" count:1) (place "Knight" "Hand" count:1) (place "Pawn1" {"B4" "C4" "D4" "D3" "D2"}) (place "Pawn2" {"F8" "F7" "F6" "G6" "H6"})}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (intersection (sites Mover "Home") (sites Empty))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
8x8. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x8): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. When a Pawn reaches the row on the opposite side of the board from which it began, it must move two spaces backward to the sixth row, then to the fourth, and then to the second, and then is promoted to Queen. It cannot jump over any pieces or taken a piece during these moves. A Pawn is immune from capture on the eight rank, but not on the others while making these promotion moves. Each player must move the Rooks' Pawns and Queens' Pawn in this way, as well as the jump of the Queen, in their first four moves. There is no castling. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Welschschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (not (= (what at:(to)) (id "Pawn" Next))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" (move Step Diagonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" (move Hop Diagonal (between if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" (move Slide Orthogonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (= 0 (state at:(from))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (remove (to))))) (then (if (is In (last To) (sites Mover "Promotion")) (set State at:(last To) 1)))) (move Slide Backward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Start (piece (what at:(last To))))) (promote (last To) (piece "Queen") Mover)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) phases:{(phase "Opening" (play (or {(forEach Piece "Queen" (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Diagonal (between (exact 1) if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) Mover) (forEach Piece "Pawn" (if (is In (from) (intersection (sites {"A2" "D2" "H2" "A7" "H7" "E7"}) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) Mover)})) (nextPhase (= 8 (count Moves)) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))))} (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x8): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. When a Pawn reaches the row on the opposite side of the board from which it began, it must move two spaces backward to the sixth row, then to the fourth, and then to the second, and then is promoted to Queen. It cannot jump over any pieces or taken a piece during these moves. A Pawn is immune from capture on the eight rank, but not on the others while making these promotion moves. Each player must move the Rooks' Pawns and Queens' Pawn in this way, as well as the jump of the Queen, in their first four moves. There is no castling. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Welschschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (not (= (what at:(to)) (id "Pawn" Next))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" (move Step Diagonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" (move Hop Diagonal (between if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" (move Slide Orthogonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (= 0 (state at:(from))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (remove (to))))) (then (if (is In (last To) (sites Mover "Promotion")) (set State at:(last To) 1)))) (move Slide Backward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Start (piece (what at:(last To))))) (promote (last To) (piece "Queen") Mover)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) phases:{(phase "Opening" (play (or {(forEach Piece "Queen" (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Diagonal (between (exact 1) if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) Mover) (forEach Piece "Pawn" (if (is In (from) (intersection (sites {"A2" "D2" "H2" "A7" "H7" "E7"}) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) Mover)})) (nextPhase (= 8 (count Moves)) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))))} (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x8): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. When a Pawn reaches the row on the opposite side of the board from which it began, it must move two spaces backward to the sixth row, then to the fourth, and then to the second, and then is promoted to Queen. It cannot jump over any pieces or taken a piece during these moves. A Pawn is immune from capture on the eight rank, but not on the others while making these promotion moves. Each player must move the Rooks' Pawns and Queens' Pawn in this way, as well as the jump of the Queen, in their first four moves. There is no castling. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Welschschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (not (= (what at:(to)) (id "Pawn" Next))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" (move Step Diagonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" (move Hop Diagonal (between if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" (move Slide Orthogonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (= 0 (state at:(from))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (remove (to))))) (then (if (is In (last To) (sites Mover "Promotion")) (set State at:(last To) 1)))) (move Slide Backward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Start (piece (what at:(last To))))) (promote (last To) (piece "Queen") Mover)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) phases:{(phase "Opening" (play (or {(forEach Piece "Queen" (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Diagonal (between (exact 1) if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) Mover) (forEach Piece "Pawn" (if (is In (from) (intersection (sites {"A2" "D2" "H2" "A7" "H7" "E7"}) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) Mover)})) (nextPhase (= 8 (count Moves)) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))))} (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
The board has nine vertical lines and ten horizontal rows, and the pieces are placed on the intersections of these lines. Centreed along the back lines of each side is a three by three square with diagonals known as the palace. Pieces have special movement values: Janggun (general): May move one spot along the lines within the palace but cannot leave it. Sa (guards): Same movement as the Janggun. Ma (horses): Move one spot forward orthogonally and then one forward diagonally. Sang (elephants): Move one spot orthogonally forward then two spots diagonally forward. A Ma and Sang can be switched in the initial setup. Cha (chariots): Move like a rook in Chess, but also diagonally within the palace. Po (cannons): Jump over exactly one piece, over any distance horizontally or vertically, but cannot jump over or capture another cannon. Byeong/Jol (soldiers): Move and capture one point forward or sideways. Play continues until Woetong (checkmate) of the Janggun.
(game "Janggi" (players 2) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Han" P1 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Cho" P2 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sa" Each (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sang" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (between (exact 2) if:(is Empty (between))) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Cha" Each (or {(move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Slide Diagonal (between (max 2) if:(and (is Empty (between)) (is In (between) (union (sites P1 "Palace") (sites P2 "Palace"))))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))})) (piece "Po" Each (or {(move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)) (apply if:(and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (remove (to))))) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Hop Diagonal (between if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(and (and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (is In (to) (union (sites P1 "Palace") (sites P2 "Palace")))) (apply (remove (to))))))})) (piece "Byeong" P1 N (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Jol" P2 S (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceOrthoP1" P1 {4 12 14 22}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "PalaceOrthoP2" P2 {67 75 77 85})}) (rules (start {(place "Han1" coord:"E2") (place "Sa1" {"D1" "F1"}) (place "Sang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Cha1" {"A1" "I1"}) (place "Po1" {"B3" "H3"}) (place "Byeong1" {"A4" "C4" "E4" "G4" "I4"}) (place "Cho2" coord:"E9") (place "Sa2" {"D10" "F10"}) (place "Sang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Cha2" {"A10" "I10"}) (place "Po2" {"B8" "H8"}) (place "Jol2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (if (is Mover P2) (id "Cho2") (id "Han1")))) (then (if (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (if (!= (var) 1) (set Var 1) (set Var 0)) (set Var 0))))) (end {(if (and (is Threatened (if (is Next P2) (id "Cho2") (id "Han1"))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (if (is Next P2) (id "Cho2") (id "Han1")))))))) (result Mover Win)) (if (and (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (= (var) 0)) (result Mover Draw))}))) 
The board has nine vertical lines and ten horizontal rows, and the pieces are placed on the intersections of these lines. Centreed along the back lines of each side is a three by three square with diagonals known as the palace. Pieces have special movement values: Janggun (general): May move one spot along the lines within the palace but cannot leave it. Sa (guards): Same movement as the Janggun. Ma (horses): Move one spot forward orthogonally and then one forward diagonally. Sang (elephants): Move one spot orthogonally forward then two spots diagonally forward. A Ma and Sang can be switched in the initial setup. Cha (chariots): Move like a rook in Chess, but also diagonally within the palace. Po (cannons): Jump over exactly one piece, over any distance horizontally or vertically, but cannot jump over or capture another cannon. Byeong/Jol (soldiers): Move and capture one point forward or sideways. Play continues until Woetong (checkmate) of the Janggun.
(game "Janggi" (players 2) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Han" P1 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Cho" P2 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sa" Each (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sang" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (between (exact 2) if:(is Empty (between))) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Cha" Each (or {(move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Slide Diagonal (between (max 2) if:(and (is Empty (between)) (is In (between) (union (sites P1 "Palace") (sites P2 "Palace"))))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))})) (piece "Po" Each (or {(move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)) (apply if:(and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (remove (to))))) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Hop Diagonal (between if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(and (and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (is In (to) (union (sites P1 "Palace") (sites P2 "Palace")))) (apply (remove (to))))))})) (piece "Byeong" P1 N (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Jol" P2 S (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceOrthoP1" P1 {4 12 14 22}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "PalaceOrthoP2" P2 {67 75 77 85})}) (rules (start {(place "Han1" coord:"E2") (place "Sa1" {"D1" "F1"}) (place "Sang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Cha1" {"A1" "I1"}) (place "Po1" {"B3" "H3"}) (place "Byeong1" {"A4" "C4" "E4" "G4" "I4"}) (place "Cho2" coord:"E9") (place "Sa2" {"D10" "F10"}) (place "Sang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Cha2" {"A10" "I10"}) (place "Po2" {"B8" "H8"}) (place "Jol2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (if (is Mover P2) (id "Cho2") (id "Han1")))) (then (if (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (if (!= (var) 1) (set Var 1) (set Var 0)) (set Var 0))))) (end {(if (and (is Threatened (if (is Next P2) (id "Cho2") (id "Han1"))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (if (is Next P2) (id "Cho2") (id "Han1")))))))) (result Mover Win)) (if (and (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (= (var) 0)) (result Mover Draw))}))) 
The board has nine vertical lines and ten horizontal rows, and the pieces are placed on the intersections of these lines. Centreed along the back lines of each side is a three by three square with diagonals known as the palace. Pieces have special movement values: Janggun (general): May move one spot along the lines within the palace but cannot leave it. Sa (guards): Same movement as the Janggun. Ma (horses): Move one spot forward orthogonally and then one forward diagonally. Sang (elephants): Move one spot orthogonally forward then two spots diagonally forward. A Ma and Sang can be switched in the initial setup. Cha (chariots): Move like a rook in Chess, but also diagonally within the palace. Po (cannons): Jump over exactly one piece, over any distance horizontally or vertically, but cannot jump over or capture another cannon. Byeong/Jol (soldiers): Move and capture one point forward or sideways. Play continues until Woetong (checkmate) of the Janggun.
(game "Janggi" (players 2) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Han" P1 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Cho" P2 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sa" Each (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sang" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (between (exact 2) if:(is Empty (between))) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Cha" Each (or {(move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Slide Diagonal (between (max 2) if:(and (is Empty (between)) (is In (between) (union (sites P1 "Palace") (sites P2 "Palace"))))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))})) (piece "Po" Each (or {(move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)) (apply if:(and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (remove (to))))) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Hop Diagonal (between if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(and (and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (is In (to) (union (sites P1 "Palace") (sites P2 "Palace")))) (apply (remove (to))))))})) (piece "Byeong" P1 N (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Jol" P2 S (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceOrthoP1" P1 {4 12 14 22}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "PalaceOrthoP2" P2 {67 75 77 85})}) (rules (start {(place "Han1" coord:"E2") (place "Sa1" {"D1" "F1"}) (place "Sang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Cha1" {"A1" "I1"}) (place "Po1" {"B3" "H3"}) (place "Byeong1" {"A4" "C4" "E4" "G4" "I4"}) (place "Cho2" coord:"E9") (place "Sa2" {"D10" "F10"}) (place "Sang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Cha2" {"A10" "I10"}) (place "Po2" {"B8" "H8"}) (place "Jol2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (if (is Mover P2) (id "Cho2") (id "Han1")))) (then (if (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (if (!= (var) 1) (set Var 1) (set Var 0)) (set Var 0))))) (end {(if (and (is Threatened (if (is Next P2) (id "Cho2") (id "Han1"))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (if (is Next P2) (id "Cho2") (id "Han1")))))))) (result Mover Win)) (if (and (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (= (var) 0)) (result Mover Draw))}))) 
Played on a board with 9x10 intersecting lines. Pieces are placed on the intersections of the lines. Centered on opposite sides of the boards are two areas, known as the gong ("castle"). Bisecting the board is a blank space known as the he ("river"). Pieces are double-sided, with different colors and names of the pieces indicating to which player they belong. Jiang("general")/shuai("marshal")(1): may move one space orthogonally and cannot leave the gong except when opposite the opponent's jiang/shuai, in which case the piece can capture the opponent's jiang/shuai. Shi("guard")(2): moves one space diagonally and cannot leave the gong. Xiang("elephant")/xiang("minister")(2): move two places diagonally and cannot cross the river. Ma("horse")(2): move orthogonally one and then diagonally one space. Can be blocked by a piece next to it orthogonally. Ju("chariot"(2): moves any number of spaces orthogonally. Pao("catapult")/pao("cannon") (2): can move orthogonally any number of spaces, captures by jumping one piece (of either player). Zu("private"/zu("soldier")(5): can move one space forward. Once they cross the river, can also move one space horizontally. The goal is to checkmate the opponent's jiang/shuai.
(game "Xiangqi" (players {(player N) (player S)}) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (directions {Forward Rightward Leftward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "Home" P1 (expand (sites Bottom) steps:4)) (regions "Home" P2 (expand (sites Top) steps:4))}) (rules (start {(place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"}) (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Played on a board with 9x10 intersecting lines. Pieces are placed on the intersections of the lines. Centered on opposite sides of the boards are two areas, known as the gong ("castle"). Bisecting the board is a blank space known as the he ("river"). Pieces are double-sided, with different colors and names of the pieces indicating to which player they belong. Jiang("general")/shuai("marshal")(1): may move one space orthogonally and cannot leave the gong except when opposite the opponent's jiang/shuai, in which case the piece can capture the opponent's jiang/shuai. Shi("guard")(2): moves one space diagonally and cannot leave the gong. Xiang("elephant")/xiang("minister")(2): move two places diagonally and cannot cross the river. Ma("horse")(2): move orthogonally one and then diagonally one space. Can be blocked by a piece next to it orthogonally. Ju("chariot"(2): moves any number of spaces orthogonally. Pao("catapult")/pao("cannon") (2): can move orthogonally any number of spaces, captures by jumping one piece (of either player). Zu("private"/zu("soldier")(5): can move one space forward. Once they cross the river, can also move one space horizontally. The goal is to checkmate the opponent's jiang/shuai.
(game "Xiangqi" (players {(player N) (player S)}) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (directions {Forward Rightward Leftward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "Home" P1 (expand (sites Bottom) steps:4)) (regions "Home" P2 (expand (sites Top) steps:4))}) (rules (start {(place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"}) (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Played on a board with 9x10 intersecting lines. Pieces are placed on the intersections of the lines. Centered on opposite sides of the boards are two areas, known as the gong ("castle"). Bisecting the board is a blank space known as the he ("river"). Pieces are double-sided, with different colors and names of the pieces indicating to which player they belong. Jiang("general")/shuai("marshal")(1): may move one space orthogonally and cannot leave the gong except when opposite the opponent's jiang/shuai, in which case the piece can capture the opponent's jiang/shuai. Shi("guard")(2): moves one space diagonally and cannot leave the gong. Xiang("elephant")/xiang("minister")(2): move two places diagonally and cannot cross the river. Ma("horse")(2): move orthogonally one and then diagonally one space. Can be blocked by a piece next to it orthogonally. Ju("chariot"(2): moves any number of spaces orthogonally. Pao("catapult")/pao("cannon") (2): can move orthogonally any number of spaces, captures by jumping one piece (of either player). Zu("private"/zu("soldier")(5): can move one space forward. Once they cross the river, can also move one space horizontally. The goal is to checkmate the opponent's jiang/shuai.
(game "Xiangqi" (players {(player N) (player S)}) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (directions {Forward Rightward Leftward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "Home" P1 (expand (sites Bottom) steps:4)) (regions "Home" P2 (expand (sites Top) steps:4))}) (rules (start {(place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"}) (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, exiting at the opposing team's home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the opposing team's home field, the piece may be re-entered on that player's team's own home field. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captured piece is placed on top of the piece that captured it, and the stack continues toward the opposing team's home space. If the player successfully carries the captured piece to the opposing team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the their opposing team's side. Any pieces captured belonging to the team which brings them off the board are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces. The game has 6 players.
(game "Aj Sakakil" (players 6) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, exiting at the opposing team's home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the opposing team's home field, the piece may be re-entered on that player's team's own home field. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captured piece is placed on top of the piece that captured it, and the stack continues toward the opposing team's home space. If the player successfully carries the captured piece to the opposing team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the their opposing team's side. Any pieces captured belonging to the team which brings them off the board are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces. The game has 8 players.
(game "Aj Sakakil" (players 8) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True) (track "Track7" {25 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P7 directed:True) (track "Track8" {26 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P8 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3 P4}) (set Team 2 {P5 P6 P7 P8}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5) (place Stack "Stick7" (handSite P7) count:5) (place Stack "Stick8" (handSite P8) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, exiting at the opposing team's home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the opposing team's home field, the piece may be re-entered on that player's team's own home field. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captured piece is placed on top of the piece that captured it, and the stack continues toward the opposing team's home space. If the player successfully carries the captured piece to the opposing team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the their opposing team's side. Any pieces captured belonging to the team which brings them off the board are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces. The game has 10 players.
(game "Aj Sakakil" (players 10) (equipment {(board (rectangle 1 25) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} P1 directed:True) (track "Track2" {25 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} P2 directed:True) (track "Track3" {26 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} P3 directed:True) (track "Track4" {27 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} P4 directed:True) (track "Track5" {28 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} P5 directed:True) (track "Track6" {29 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True) (track "Track7" {30 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P7 directed:True) (track "Track8" {31 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P8 directed:True) (track "Track9" {32 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P9 directed:True) (track "Track10" {33 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P10 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3 P4 P5}) (set Team 2 {P6 P7 P8 P9 P10}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5) (place Stack "Stick7" (handSite P7) count:5) (place Stack "Stick8" (handSite P8) count:5) (place Stack "Stick9" (handSite P9) count:5) (place Stack "Stick10" (handSite P10) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
4x22 board. 22 pieces per player, four kings and eighteen regular pieces. Kings have no difference in movement or power than regular pieces. Moves are determined by four two-sided sticks, black on one side and white on the other. The moves are determined by the number of white sides that land face up: 1= a move of 1. A throw of 1 is known as "tab." 2= a move of 2, 3=2, 4=6, 0=4. Throws of 1, 4, and 6 grant the player an additional throw. To begin, a player must roll tab to move their first piece, and every tab after that must be used to move a piece which has not moved yet. Pieces move from left to right in the home row, then circulate in a clockwise direction in the central two rows. Multiple pieces cannot occupy the same space. When a player's piece lands on a space occupied by an opponent's piece, that piece is captured. The player to capture all of the opponent's pieces wins.
(game "Kioz" (players 2) (equipment {(board (rectangle 4 22) {(track "Track1" "0,E,N1,W," P1 directed:True) (track "Track2" "87,W,S1,E" P2 directed:True) (track "MiddleTrack" "44,E,S1,W" loop:True)}) (dice d:2 from:0 num:4) (piece "Marker" Each) (piece "King" Each) (map "Throw" {(pair 0 4) (pair 1 1) (pair 2 2) (pair 3 2) (pair 4 6)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Marker1" (intersection (sites Bottom) (expand (sites Left) steps:17))) (place "King1" (intersection (sites Bottom) (expand (sites Right) steps:3))) (place "Marker2" (intersection (sites Top) (expand (sites Right) steps:17))) (place "King2" (intersection (sites Top) (expand (sites Left) steps:3)))}) (play (do (roll) next:(if (= 1 (mapEntry "Throw" (count Pips))) (priority {(forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips)))) (not (!= 0 (state at:(from))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to))))))))) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))}) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 4 6})) (moveAgain))))) (end (if (no Pieces Next) (result Next Loss))))) 
4x22 board. 22 pieces per player, four kings and eighteen regular pieces. Kings have no difference in movement or power than regular pieces. Moves are determined by four two-sided sticks, black on one side and white on the other. The moves are determined by the number of white sides that land face up: 1= a move of 1. A throw of 1 is known as "tab." 2= a move of 2, 3=2, 4=6, 0=4. Throws of 1, 4, and 6 grant the player an additional throw. To begin, a player must roll tab to move their first piece, and every tab after that must be used to move a piece which has not moved yet. Pieces move from left to right in the home row, then circulate in a clockwise direction in the central two rows. Multiple pieces cannot occupy the same space. When a player's piece lands on a space occupied by an opponent's piece, that piece is captured. The player to capture all of the opponent's pieces wins.
(game "Kioz" (players 2) (equipment {(board (rectangle 4 22) {(track "Track1" "0,E,N1,W," P1 directed:True) (track "Track2" "87,W,S1,E" P2 directed:True) (track "MiddleTrack" "44,E,S1,W" loop:True)}) (dice d:2 from:0 num:4) (piece "Marker" Each) (piece "King" Each) (map "Throw" {(pair 0 4) (pair 1 1) (pair 2 2) (pair 3 2) (pair 4 6)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Marker1" (intersection (sites Bottom) (expand (sites Left) steps:17))) (place "King1" (intersection (sites Bottom) (expand (sites Right) steps:3))) (place "Marker2" (intersection (sites Top) (expand (sites Right) steps:17))) (place "King2" (intersection (sites Top) (expand (sites Left) steps:3)))}) (play (do (roll) next:(if (= 1 (mapEntry "Throw" (count Pips))) (priority {(forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips)))) (not (!= 0 (state at:(from))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to))))))))) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))}) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 4 6})) (moveAgain))))) (end (if (no Pieces Next) (result Next Loss))))) 
4x22 board. 22 pieces per player, four kings and eighteen regular pieces. Kings have no difference in movement or power than regular pieces. Moves are determined by four two-sided sticks, black on one side and white on the other. The moves are determined by the number of white sides that land face up: 1= a move of 1. A throw of 1 is known as "tab." 2= a move of 2, 3=2, 4=6, 0=4. Throws of 1, 4, and 6 grant the player an additional throw. To begin, a player must roll tab to move their first piece, and every tab after that must be used to move a piece which has not moved yet. Pieces move from left to right in the home row, then circulate in a clockwise direction in the central two rows. Multiple pieces cannot occupy the same space. When a player's piece lands on a space occupied by an opponent's piece, that piece is captured. The player to capture all of the opponent's pieces wins.
(game "Kioz" (players 2) (equipment {(board (rectangle 4 22) {(track "Track1" "0,E,N1,W," P1 directed:True) (track "Track2" "87,W,S1,E" P2 directed:True) (track "MiddleTrack" "44,E,S1,W" loop:True)}) (dice d:2 from:0 num:4) (piece "Marker" Each) (piece "King" Each) (map "Throw" {(pair 0 4) (pair 1 1) (pair 2 2) (pair 3 2) (pair 4 6)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Marker1" (intersection (sites Bottom) (expand (sites Left) steps:17))) (place "King1" (intersection (sites Bottom) (expand (sites Right) steps:3))) (place "Marker2" (intersection (sites Top) (expand (sites Right) steps:17))) (place "King2" (intersection (sites Top) (expand (sites Left) steps:3)))}) (play (do (roll) next:(if (= 1 (mapEntry "Throw" (count Pips))) (priority {(forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips)))) (not (!= 0 (state at:(from))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to))))))))) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))}) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 4 6})) (moveAgain))))) (end (if (no Pieces Next) (result Next Loss))))) 
